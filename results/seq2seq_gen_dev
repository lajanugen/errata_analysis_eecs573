The Combination of a Page-Split Lock Access And Data Accesses That Are Split Across Cacheline Boundaries May Lead to Processor Livelock
IA32_MC5_CTL2 is Not Cleared by a Warm Reset
Performance Monitor Counters May Produce Incorrect Results
The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged
Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations
Processor May Livelock During On Demand Clock Modulation
Some Performance Monitoring Events in AnyThread Mode May Get Incorrect Count
An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang
Processor May Hold-off / Delay a PECI Transaction Longer than Specified by the PECI Protocol
End Agent PCIe* Packet Errors May Result in a System Hang
Instruction Fetch May Cause a Livelock During Snoops of the L1 Data Cache
PECI Temperature Data Values in the IQ Following Reset When a Code Breakpoint is Set on a # GP Instruction
Values for LBR/BTS/BTM Will Be Incorrect after an Exit from SMM
High Temperature Circuit Marginality Issue May Cause the System to Hang or Auto
Update of Read/Write ( R/W ) or User/Supervisor ( U/S ) or Present ( P ) Bits without TLB Shootdown May Cause Unexpected Processor Behavior
PCIe* Presence Detect State May Not be Accurate After a Warm Reset
High Temperature Circuit Marginality Issue May Cause the System to Hang or Auto
Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set
Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work
A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE
LBR/BTM/BTS Information Immediately After a Transition From Legacy/Compatibility Mode to 64-bit Mode May be Incorrect
When BIST is Enabled , Warm Reset Incorrectly Clears IA32_FEATURE_CONTROL MSR and the Last Exception Record MSRs IA32_FEATURE_CONTROL MSR ( 3AH ) , MSR_LER_FROM_LIP MSR ( 1DDH ) , and MSR_LER_TO_LIP MSR ( Bus 1 ) on RSM 1 )
GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events
VM Exit Occurring in IA-32e Mode May Not Produce VMX Abort When Expected
C6 Request May Cause a Machine Check if the Other Logical Processor is in C4 or C6
For the steppings affected , see the Summary Tables of Changes . A 64-bit Register IP-relative Instruction May Return Unexpected Results Under an unlikely and complex sequence of conditions in 64-bit mode , a register IPrelative instruction result may be incorrect .
EOI Transaction May Not be Sent if Software Enters Core C6 During an Interrupt Service Routine
Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints
PCIe Ports May Not Enter Slave Loopback Mode From the Configuration LTSSM State
An Unexpected Page Fault May Occur After Writing a Large Value to IA32_FIXED_CTR2
A VM Exit Due to a Fault While Delivering a Software Interrupt May Save Incorrect Data into the VMCS
Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results
RDMSR From The APIC-Timer CCR May Disarm The APIC Timer in TSC Deadline Mode
Unexpected Interrupts May Occur on C6 Exit If Using APIC Timer to Generate Interrupts
PMIs during Core C6 Transitions May Cause the System to Hang
HSYNC/VSYNC Buffer Does Not Meet VESA Rise & Undershoot Specification
CPUID Reports Architectural Performance Monitoring Version 2 is Supported , When Only Version 1 Capabilities are Available
Updating Code Page Directory Attributes without TLB Invalidation May Result in Improper Handling of Code # PF
Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set
VM Entry Loading an Unusable SS Might Not Set SS.B to 1
VERW/VERR/LSL/LAR Instructions May Unexpectedly Update the Last Exception Record ( LER ) MSR
Performance Monitoring Event MISALIGN_MEM_REF May Over Count
VM Entry May Use Wrong Address to Access Virtual-APIC Page
General Protection Fault ( # GP ) for Instructions Greater Than 15 Bytes May Be Preempted
Pending x87 FPU Exceptions ( # MF ) Following STI May Be Serviced Before Higher Priority Interrupts
The Processor May Report a # TS Instead of a # GP Fault
Single Step Interrupts with Floating Point Exception Pending May Be Mishandled
A Write to an APIC Register Sometimes May Appear to Have Not Occurred
Programming the Digital Thermal Sensor ( DTS ) Threshold May Cause Unexpected Thermal Interrupts
Count Value for Performance-Monitoring Counter PMH_PAGE_WALK May Be Incorrect
LER MSRs May Be Incorrectly Updated
NA
Performance Monitoring Events for Retired Instructions ( C0H ) May Not Be Accurate
Performance Monitoring Event for Outstanding Bus Requests Ignores AnyThread Bit
Using 2M/4M Pages When A20M # Is Asserted May Result in Incorrect Address Translations
Writing Shared Unaligned Data that Crosses a Cache Line without Proper Semaphores or Barriers May Expose a Memory Ordering Issue
Code Segment Limit Violation May Occur on 4 Gigabyte Limit Check
PDIR May Not Function Properly With FREEZE_PERFMON_ON_PMI
PECI MbxGet ( ) Followed by a GetTemp ( ) May Cause System Hang in Package C6 State
VM Entry May Use Wrong Address to Access Virtual-APIC Page
PCMPESTRI , PCMPESTRM , VPCMPESTRI and VPCMPESTRM Always Operate with 32-bit Length Registers
EFLAGS , CR0 , CR4 and the EXF4 Signal May be Incorrect after Shutdown
Some Performance Monitoring Event IA32_FIXED_CTR2 May Not Be Accurate
L1 Data Cache Errors May be Logged With Level Set to 1 Instead of 0
VM Entry May Omit Consistency Checks Related to Bit 14 ( BS ) of the Pending Debug Exception Field in Guest-State Area of the VMCS
IA32_MC5_CTL2 is Not Cleared by a Warm Reset
# GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions
FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode
Performance Monitoring Events for Retired Loads ( CBH ) and Instructions Retired ( C0H ) May Not Be Accurate
Enabling Opportunistic Self-Refresh When in Traffic State May Cause System Hang
Intel® VT-d Interrupt Remapping Will Not Report a Fault if Interrupt Index Exceeds FFFFH
The Combination of a Page-Split Lock Access And Data Accesses That Are Split Across Cacheline Boundaries May Lead to Processor Livelock
Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update
NA
NA
NA
REP CMPS/SCAS Operations May Terminate Early in 64-bit Mode When RCX > = 0X100000000
PCIe Ports May Not Enter Slave Loopback Mode From the Configuration LTSSM State
Processor Forward Progress Mechanism Interacting With Certain MSR/CSR Writes May Cause Unpredictable System Behavior
Processor May Hang During a Function Level Reset of the Display
CPUID Instruction Returns Incorrect Value For Leaf 0xA
Certain Local Memory Read / Load Retired PerfMon Events May Undercount
Processor May Not Wake Up from an Inactive State When an Enhanced Intel® SpeedStep Technology Transition is Pending
Performance Monitor Event SEGMENT_REG_LOADS Counts Inaccurately
Values for LBR/BTS/BTM Will Be Incorrect after an Exit from SMM
Shutdown Condition May Disable Non-Bootstrap Processors
The Value in IA32_MC3_ADDR MSR May Not be Accurate When MCACOD 0119H is Reported in IA32_MC3_Status
Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack
VM Entry May Omit Consistency Checks Related to Bit 14 ( BS ) of the Pending Debug Exception Field in Guest-State Area of the VMCS
CPUID Instruction Returns Incorrect Brand String
Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack
Last Branch Records ( LBR ) Updates May Be Incorrect after a Task Switch
NA
IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly
INIT Does Not Clear Global Entries in the TLB
Using Memory Type Aliasing with Memory Types WB/WT May Lead to Unpredictable Behavior
Reception of Certain Malformed Transactions May Cause PCIe* Port to Hang Rather Than Reporting an Error
L1 Cache Uncorrected Errors May be Recorded as Correctable in 16K Mode
Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown
Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures
MOV To/From Debug Registers Causes Debug Exception
LBR , BTM or BTS Records May have Incorrect Branch From Information After an EIST/T-state/S-state/C1E Transition or Adaptive Thermal Throttling
VM Exits Due to EPT Violations Do Not Record Information about PreIRET NMI Blocking
LBR , BTS , BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode
Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior
A Thermal Interrupt is Not Generated when the Current Temperature is Invalid
PCIe Link Speed May Not Train to x16 Link Width
IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception
Performance Monitoring Event MISALIGN_MEM_REF May Over Count
CPL-Qualified BTS May Report Incorrect Branch-From Instruction Address
