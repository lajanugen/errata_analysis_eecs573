Query: 11136 aips : unaligned access causes abort on writes to the internal registers
NNs
Failure: 
 07298    ENGcm07298    AIPS: Unaligned access causes abort on writes to the internal registers    
Details: 
 :    Unaligned access to AIPS can be driven high by SAHARA, DAP, and FEC. If they access the AIPS    internal registers during an unaligned access, an ABORT occurs.     Projected ImpactJEEHEHRECONSTRUCT:    Unaligned accesses to the AIPS internal registers fail.    

Failure: 
 11203      M4IF: Reading M4IF status registers of an inactive AXI master or slave stalls entire system    
Details: 
 :    Reading the M4IF status registers of an inactive AXI master or slave ports stalls the entire IC    system. This occurs when a specific master or slave clock is not provided to the M4IF, but the ARM/JTAG tries to read that masterâs status bits.    When the master or slave clock is not active, the read request fails to propagate the status bits that go through synchronization (IPG_CLK to *_clk), acknowledge never comes back, and the entire chipâs IP bus is stuck.    Some M4IF status registers bundle the status of several masters or slaves. If one of the masters or slaves is inactive, accessing such a register stalls the entire system, even if the user is interested only in the status of other active ports.    Table 4 lists the impacted registers and the clock signals that should be active for read access to succeed.    Table 4. List of Impacted Registers12SPACEJEEHEHRegisters      Required Master/Slave to be Active for Read Action to Succeed MDCR    fast, slow, int1, int2    WMIS0    fast    WMIS1    fast    MLEN    m0, m1, m2, m3, m4, m5, m6, m7, fast, slow, int1, int2    FDPS    fast    SSRL0    fast    SSRL1    fast    SSRH0    fast    SSRH1    fast    MDSR0    The arbitration domain selected by MDCR/RARB    MDSR1    The arbitration domain selected by MDCR/RARB    MDSR2    The arbitration domain selected by MDCR/RARB    MDSR3    The arbitration domain selected by MDCR/RARB    MDSR4    The arbitration domain selected by MDCR/RARB    MDSR5    The arbitration domain selected by MDCR/RARB    MDSR6    The arbitration domain selected by MDCR/RARB    MDSR7    The arbitration domain selected by MDCR/RARB    MDSR8    The arbitration domain selected by MDCR/RARB    SBS0    The arbitration domain selected by MDCR/RARB    SBS1    The arbitration domain selected by MDCR/RARB    Chip Errata for the i.MX53, Rev. 6    Freescale Semiconductor    65

Failure: 
 11084-8    ENGcm11084-8    SATA: BIST responder re-timed loopback mode may drop data due to FIFO overflow    
Details: 
 :    The DWC SATA AHCI core removes and replaces all ALIGNs in the far-end re-timed BIST    responder loopback mode. This can cause overflow in the BIST FIFO, if the Tx frequency of the device is faster than the Host Tx frequency (clk_asic). According to the SATA specification, the link can consume up to two ALIGNs and prevent the overflow.     DescriptionJEEHEHRECONSTRUCT:    Under certain conditions, the Host controller fails to wake up from the low power mode. The problem arises when the Host issues a COMRESET (software requested reset of system) at the exact time when the Device is disconnected and then reconnected, and when both the Host and the Device were previously in the power down mode. The series of events to cause this error are described as follows:    1. The Host sends a partial power mode request.    2. The Device issues a partial power mode request (collision).    3. The Host backs off and accepts the device power mode request.    4. Both the Host and the Device go into slumber power mode (phy_slumber asserted).    5. The Device is disconnected and reconnected, after which it sends COMINIT.    6. The Host does not respond to COMINIT as it issued a COMRESET from the application software at the exact time COMINIT is detected.    7. The Host does not detect COMINIT, but phy_slumber is de-asserted and asserted again and remains asserted.    8. The Host hangs in the power down mode.    This problem is caused by signals from the clk_asic clock domain remaining asserted after clk_asic is restored, and the signals cause another power mode to be asserted.     Projected ImpactJEEHEHRECONSTRUCT:    The loopback data is corrupted when the BIST FIFO overflows.    The severity is high. The probability is medium.     Projected ImpactJEEHEHRECONSTRUCT:    The Host may not wake up from the low power mode.    The severity is medium. The probability is low.    

Failure: 
 11206      ARM: Cache maintenance operations by MVA for a    non-cacheable memory region can result in processor deadlock 
Details: 
 :    If a Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is performed in a memory region that is marked non-cacheable, device, or strongly ordered, it is possible for the processor to deadlock or have stale data left in the processor. This erratum occurs when the address hits the cache in a way that is not predicted by the Hash Virtual Address Buffer (HVAB), which is a cache way predictor inside the processor. This erratum can occur only for the cache maintenance operations that are performed by MVA. It does not occur for the set/way based cache maintenance operations.    The conditions are as follows:    1. A memory region is marked cacheable in a page table entry, and a cache line from that region is placed in the data cache    2. A second page table entry marks the same memory region as non-cacheable, device, or strongly ordered. This can occur by changing the memory attributes in the existing page table entry, or through an alternative page table entry that maps the same virtual to physical address but with non-cacheable, device, or strongly ordered attributes rather than cacheable 3. A Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is done to this address    4. The maintenance operation receives a false hit indication from the HVAB array 5. The maintenance operation receives a true hit indication from the Tag lookup, which implies that the data is present in the array, but located in a different way that is not predicted by the HVAB    6. An eviction of the dirty line has started but not finished, and the processor leaves stale data in the cache and can potentially enter a deadlock state    The issue is reported by ARM, erratum ID 728018, Category 21.     Projected ImpactJEEHEHRECONSTRUCT:    If stale data is left in the cache, the processor does not work as intended. If deadlock state occurs, it can only be exited by asserting the RESET pin on the processor.    

Failure: 
 04759    ENGcm04759    ARM: NEON load data can be incorrectly forwarded to a    subsequent request    
Details: 
 :    Under very specific set of conditions, data from a Neon load request can be incorrectly forwarded to a subsequent, unrelated memory request.    The conditions are as follows:    â¢ Neon loads and stores must be in use    â¢ Neon L1 caching must be disabled    â¢ Trustzone must be configured and in use    â¢ The secure memory address space and the non-secure memory address space both use the same physical addresses, either as an alias or the same memory location or for separate memory locations    The issue is reported by ARM, erratum ID 468414, Category 21.     Projected ImpactJEEHEHRECONSTRUCT:    If this erratum is encountered, it is possible for a load request to receive the wrong data value which can likely result in incorrect operation of the program.    

-------------
Query: 09831 arm : load and store operations on the shared device memory regions may not complete in program order
NNs
Failure: 
 09830    ENGcm09830    ARM: Load and Store operations on the shared device memory regions may not complete in program order    
Details: 
 :    If a sequence of load and store operations are performed to different address locations in a memory region that is marked as shared device, then a load can incorrectly bypass a store.    The issue is reported by ARM, erratum ID 709718, Category 21.     Projected ImpactJEEHEHRECONSTRUCT:    If the load address and store address are mapped to access the memory region of the same device, and the device relies on memory operations to occur in program order, then this device may not operate as intended.    

Failure: 
 11206      ARM: Cache maintenance operations by MVA for a    non-cacheable memory region can result in processor deadlock 
Details: 
 :    If a Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is performed in a memory region that is marked non-cacheable, device, or strongly ordered, it is possible for the processor to deadlock or have stale data left in the processor. This erratum occurs when the address hits the cache in a way that is not predicted by the Hash Virtual Address Buffer (HVAB), which is a cache way predictor inside the processor. This erratum can occur only for the cache maintenance operations that are performed by MVA. It does not occur for the set/way based cache maintenance operations.    The conditions are as follows:    1. A memory region is marked cacheable in a page table entry, and a cache line from that region is placed in the data cache    2. A second page table entry marks the same memory region as non-cacheable, device, or strongly ordered. This can occur by changing the memory attributes in the existing page table entry, or through an alternative page table entry that maps the same virtual to physical address but with non-cacheable, device, or strongly ordered attributes rather than cacheable 3. A Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is done to this address    4. The maintenance operation receives a false hit indication from the HVAB array 5. The maintenance operation receives a true hit indication from the Tag lookup, which implies that the data is present in the array, but located in a different way that is not predicted by the HVAB    6. An eviction of the dirty line has started but not finished, and the processor leaves stale data in the cache and can potentially enter a deadlock state    The issue is reported by ARM, erratum ID 728018, Category 21.     Projected ImpactJEEHEHRECONSTRUCT:    If stale data is left in the cache, the processor does not work as intended. If deadlock state occurs, it can only be exited by asserting the RESET pin on the processor.    

Failure: 
 11413      ARM: A Neon load from device memory type can result in data abort    
Details: 
 :    When Neon performs a single byte load from Strongly Ordered or Device type memory with an access size of more than 8 bytes, the system AXI bus issues a burst access which is longer than 8    beats of a single byte.    However, the M4IF is capable of supporting only access with a burst length of less than or equal to 8, as indicated in the i.MX53 Applications Processor Reference Manual (MCIMX53RM). When an access with burst length greater than 8 beat is detected by the M4IF, it is not forwarded to the memory controllers. Instead, a DECERR AXI bus error is indicated and data abort exception is sent back to the master.    Conditions for this issue:    1. A single byte Neon load is issued with more than 8 bytes access, for example: Vld1.8 {d0,d1,d2,d3}, [Rs]!    2. The source address is Strongly Ordered or Device memory type  Projected ImpactJEEHEHRECONSTRUCT:    The Neon access to memory region marked as Strongly Ordered or Device are not usually a practical case in general. Note that there are also other reported limitations for Neon access to    Device type memory such as ENGcm10729.    

Failure: 
 11133      ARM: NEON load data can be incorrectly forwarded to a12SPACEJEEHEHsubsequent request      
Details: 
 :      Under very specific set of conditions, data from a Neon load request can be incorrectly forwarded to a subsequent, unrelated memory request.    The conditions are as follows:    â¢ Neon loads and stores must be in use    â¢ Neon L1 caching must be disabled    â¢ Trustzone must be configured and in use    â¢ The secure memory address space and the non-secure memory address space both use the same physical addresses, either as an alias or the same memory location or for separate memory locations    The issue is reported by ARM, erratum ID 468414, Category 21.     Projected ImpactJEEHEHRECONSTRUCT:    If this erratum is encountered, it is possible for a load request to receive the wrong data value which can likely result in incorrect operation of the program.    

Failure: 
 11084-8    ENGcm11084-8    SATA: BIST responder re-timed loopback mode may drop data due to FIFO overflow    
Details: 
 :    The DWC SATA AHCI core removes and replaces all ALIGNs in the far-end re-timed BIST    responder loopback mode. This can cause overflow in the BIST FIFO, if the Tx frequency of the device is faster than the Host Tx frequency (clk_asic). According to the SATA specification, the link can consume up to two ALIGNs and prevent the overflow.     DescriptionJEEHEHRECONSTRUCT:    Under certain conditions, the Host controller fails to wake up from the low power mode. The problem arises when the Host issues a COMRESET (software requested reset of system) at the exact time when the Device is disconnected and then reconnected, and when both the Host and the Device were previously in the power down mode. The series of events to cause this error are described as follows:    1. The Host sends a partial power mode request.    2. The Device issues a partial power mode request (collision).    3. The Host backs off and accepts the device power mode request.    4. Both the Host and the Device go into slumber power mode (phy_slumber asserted).    5. The Device is disconnected and reconnected, after which it sends COMINIT.    6. The Host does not respond to COMINIT as it issued a COMRESET from the application software at the exact time COMINIT is detected.    7. The Host does not detect COMINIT, but phy_slumber is de-asserted and asserted again and remains asserted.    8. The Host hangs in the power down mode.    This problem is caused by signals from the clk_asic clock domain remaining asserted after clk_asic is restored, and the signals cause another power mode to be asserted.     Projected ImpactJEEHEHRECONSTRUCT:    The loopback data is corrupted when the BIST FIFO overflows.    The severity is high. The probability is medium.     Projected ImpactJEEHEHRECONSTRUCT:    The Host may not wake up from the low power mode.    The severity is medium. The probability is low.    

-------------
