Query: arm : 740657global timer can send two interrupts for the same event
NNs
Failure: 
ERR003733 ARM: 751480âConditional failed LDREXcc can set the exclusive monitor 
Details: 
 A conditional LDREX might set the internal exclusive monitor of the Cortex-A9 even when its condition fails. So, any subsequent STREX that depends on this LDREXcc might succeed when it should not. 

Failure: 
FlexCAN: FlexCAN does not transmit a message that is enabled to be transmitted in a specific moment during the arbitration process 
Details: 
 FlexCAN does not transmit a message that is enabled to be transmitted in a specific moment during the arbitration process. The following conditions are necessary for the issue to occur: â¢ Only one message buffer is configured to be transmitted â¢ The write which enables the message buffer to be transmitted (write on Control/Status word) happens during a specific clock during the arbitration process. â¢ After this arbitration process occurs, the bus goes to the Idle state and no new message is received on the bus. For example: 1. Message buffer 13 is deactivated on RxIntermission (write 0x0 to the CODE field from the Control/Status word) [First write to CODE] 2. Reconfigure the ID and data fields 3. Enable the message buffer 13 to be transmitted on BusIdle (write 0xC on CODE field) [Second write to CODE] 4. CAN bus keeps in Idle state 5. No write on the Control/Status from any message buffer happens. During the second write to CODE (step 3), the write must happen one clock before the current message buffer 13 to be scanned by arbitration process. In this case, it does not detect the new code (0xC) and no new arbitration is scheduled. The problem can be detected only if the message traffic ceases and the CAN bus enters into Idle state after the described sequence of events. There is no issue if any of the conditions below holds: â¢ Any message buffer (either Tx or Rx) is reconfigured (by writing to its CS field) just after the Intermission field. â¢ There are other configured message buffers to be transmitted â¢ A new incoming message sent by any external node starts just after the Intermission field. 

Failure: 
ARM: 743623âBad interaction between a minimum of seven PLDs and one Non-Cacheable LDM can lead to a deadlock 
Details: 
 Under very rare circumstances, a deadlock can happen in the processor when it is handling a minimum of seven PLD instructions, shortly followed by one LDM to an uncacheable memory location. The LDM is treated as uncacheable in the following cases: â¢ The LDM is performed while the Data Cache is OFF â¢ The LDM is targeting a memory region marked as Strongly Ordered, Device, Normal Memory Non-Cacheable, or Normal Memory Write-Through â¢ The LDM is targeting a memory region marked as Shareable Normal Memory Write-Back, and the CPU is in AMP mode. Conditions: The code sequence that exhibits this erratum requires at least seven PLDs, shortly followed by one LDM, to an uncacheable memory region. The erratum happens when the LDM appears on the AXI bus before any of the seven PLDs. This can possibly happen if the first PLD is a miss in the micro-TLB; in that case, it needs to perform a TLB request which might not be serviced immediately because the mainTLB is already performing a Page Table Walk for another resource (for example, instruction side), or because the PLD request itself to the mainTLB is missing and causing a Page Table Walk. Also note that the above conditions are not sufficient to recreate the failure, as additional rare conditions on the internal state of the processor are necessary to exhibit the errata. 

Failure: 
ARM: 751470âImprecise abort on the last data of a cache linefill may not be detected 
Details: 
 Data linefills are returned as 4-beat bursts of 64-bit data on the AXI bus. When the first three beat of data are valid, and the fourth one aborts, then the abort is not detected by the processor logic and no abort exception is taken. The processor then behaves as if no abort is reported on the line. It can allocate the line in its Data Cache, and use the aborted data during its program flow. Conditions: The processor needs to work with Data Cache enabled, and access some cacheable memory regions (Write Back, either Shared or Non-Shared). The memory system underneath the processor needs to be able to generate aborts in this memory region, and must be able to generate aborts with a granularity smaller than the cache line. 

Failure: 
ENET: Only the ENET wake-up interrupt request can wake the system from Wait mode [i.MX 6Dual/6Quad Only] 
Details: 
 The ENET block generates many interrupts. Only one of these interrupt lines is connected to the General Power Controller (GPC) block, but a logical OR of all of the ENET interrupts is connected to the General Interrupt Controller (GIC). When the system enters Wait mode, a normal RX Done or TX Done does not wake up the system because the GPC cannot see this interrupt. This impacts performance of the ENET block because its interrupts are serviced only when the chip exits Wait mode due to an interrupt from some other wake-up source. 

-------------
Query: analog : transition from deep sleep mode to ldo bypass mode may cause the slow response of the vddarm_cap output
NNs
Failure: 
ENET: Only the ENET wake-up interrupt request can wake the system from Wait mode [i.MX 6Dual/6Quad Only] 
Details: 
 The ENET block generates many interrupts. Only one of these interrupt lines is connected to the General Power Controller (GPC) block, but a logical OR of all of the ENET interrupts is connected to the General Interrupt Controller (GIC). When the system enters Wait mode, a normal RX Done or TX Done does not wake up the system because the GPC cannot see this interrupt. This impacts performance of the ENET block because its interrupts are serviced only when the chip exits Wait mode due to an interrupt from some other wake-up source. 

Failure: 
ARM (CA9): 845369 â Under very rare timing circumstances, transition into streaming mode might create a data corruption 
Details: 
 Under very rare timing circumstances, a data corruption might occur on a dirty cache line that is evicted from the L1 Data Cache due to another cache line being entirely written. The erratum requires the following conditions: â¢ The CPU contains a dirty line in its data cache. â¢ The CPU performs at least four full cache line writes, one of which is causing the eviction of the dirty line. â¢ Another CPU, or the ACP, is performing a read or write operation on the dirty line. The defect requires very rare timing conditions to reach the point of failure. These timing conditions depend on the CPU micro-architecture, and are not controllable in software: â¢ The CPU must be in a transitional mode that might be triggered by the detection of the first two full cache line writes. â¢ The evicted line must remain stalled in the eviction buffer, which is likely to be caused by a congested write traffic. â¢ The other coherent agent, either another CPU in the cluster or the ACP, must perform its coherency request on the evicted line while it is in the eviction buffer. This erratum only occurs when two or more processors are enabled. 

Failure: 
ERR005194 MIPI: On MIPI DSI, there is a possible corruption of the video packets caused by overlapping of the current line over the next line, if the configuration is programmed incorrectly when using the DPI interface 
Details: 
 For an incorrectly programmed configuration that enables the Null Packets and disables the Multiple Packets, the delay calculation is incorrectly done. Calculation of the delay time applied to the synchronization events when the Null Packets are enabled does not consider that the delay should only be applied when Multiple Packets are also enabled. This inaccuracy in the delay time might lead to an eventual overlap of current line with next line transmission resulting in the corruption of the packets. 

Failure: 
ERR003743 ARM/PL310: 754670âA continuous write flow can stall a read targeting the same memory area 
Details: 
 In the ARM L2 cache controller, PL310, hazard checking is done on bits [31:5] of the address. When a read with Normal Memory (cacheable or not) attributes is received by PL310, hazard checking is performed with the active writes of the store buffer. If an address matching is detected, the read is stalled till the write completes. Due to this erratum, a continuous flow of writes can stall a read targeting the same memory area. Conditions: The erratum occurs when the following conditions are met: â¢ PL310 receives a continuous write traffic targeting the same address marked with Normal Memory attributes â¢ While treating this flow, PL310 receives a read targeting the same 32-byte memory area 

Failure: 
ERR005185 ARM/MP: 771225âSpeculative cacheable reads to aborting memory region clear the internal exclusive monitor, may lead to livelock 
Details: 
 On Cortex-A9, when a cacheable read receives an external abort, the aborted line is allocated as invalid in the Data Cache, and any allocation in the Data Cache clears the internal exclusive monitor. So, if a program executes a LDREX/STREX loop which keeps on receiving an abort answer in the middle of the LDREX/STREX sequence, then the LDREX/STREX sequence never succeeds, leading to a possible processor livelock. As an example, the following code sequence might exhibit the erratum: loop LDREX ... DSB STREX CMP BNE loop .... LDR (into aborting region) The LDREX/STREX does not succeed on the first pass of the loop, and the BNE is mispredicted, so, the LDR afterwards is speculatively executed. So, the processor keeps on executing: LDR to aborting region (this speculative LDR now appears âbeforeâ the LDREX and DSB) LDREX DSB STREX The LDR misses in L1, and never gets allocated as valid because it is aborting The LDREX is executed, and sets the exclusive monitor The DSB is executed. It waits for the LDR to complete, which aborts, causing an allocation (as invalid) in the Data Cache, which clears the exclusive monitor The STREX is executed, but the exclusive monitor is now cleared, so the STREX fails The BNE might be mispredicted again, so the LDR is speculatively executed again, and the code loops back on the same failing LDREX/STREX sequence. Conditions: The erratum happens in systems which might generate external aborts in answer to cacheable memory requests. If the program reaches a stable state where the internal exclusive monitor keeps on being cleared in the middle of the LDREX/STREX sequence, then the processor might encounter a livelock situation. In practice, this scenario seems very unlikely to happen because several conditions might prevent the erratum from happening: â¢ Usual LDREX/STREX code sequences do not contain any DSB, so that it is very unlikely that the system would return the abort answer precisely in the middle of the LDREX/STREX sequence on each iteration. â¢ Some external irritators (for example, interrupts) might happen and cause timing changes which might exit the processor from its livelock situation. â¢ Branch prediction is very usually enabled, so the final branch in the loop will usually be correctly predicted after a few iterations of the loop, preventing the speculative LDR to be issued, so that the next iteration of the LDREX/STREX sequence will succeed. Workarounds: The following two workarounds are available for this erratum: â¢ Turn on the branch prediction. â¢ Remove the DSB in the middle of the LDREX/STREX sequence. If a DSB is truly required, it is strongly recommended to place it before the LDREX/STREX sequence, and implement the LDREX/STREX sequence as recommended by the ARM architecture. Proposed Solution: No fix scheduled Linux BSP Status: Software workaround implemented in Linux BSP codebase in all releases. Software workaround is to enable branch prediction which is enabled by default in the BSP GA release

-------------
