title	Problem:	Implication:	Workaround:	Status:
  IO_SMI Indication in SMRAM State Save Area May Be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4h is set to “1” by the processor to indicate that a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: • An SMI that is pending while a lower priority event is executing • A REP I/O read • A I/O read that redirects to MWAIT  	  SMM handlers may get a false IO_SMI indication.  	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  No Fix. 
  Writes to IA32_DEBUGCTL MSR May Fail When FREEZE_LBRS_ON_PMI Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9h) bit [11], is set, future writes to the IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	  Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software.  	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  No Fix. 
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May Be Incorrect  	  When an L2 Cache error occurs (error code 010Ah or 110Ah reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  	  Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors.  	 None identified. 	  No Fix. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the  Intel® Atom™ Processor E6xx Series 16  May 2012 Document Number: 324209-012   interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep® Technologyθ transitions or Intel® Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts. 	  Software may observe #MF being serviced before higher priority interrupts.  	 None identified. 	  No Fix. 
  Benign Exception After Double Fault May Not Cause Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference,” if another exception occurs while attempting to call the double fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call the double fault handler will not cause a shutdown. However, Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  	  If a benign exception occurs while attempting to call the double fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  No Fix. 
  IA32_MC1_STATUS MSR Bit [60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405h) bit [60] (EN - Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404h) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit [60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	  IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update.  	 None identified. 	  No Fix. 
  If Two Logical Processors Use Same CR3 Value but Configure APIC Virtualization Differently, Either May Operate as if APIC Virtualization Were Disabled  	  If a logical processor is in VMX non-root operation with the “virtual APIC accesses” VMexecution control set to 1, it may incorrectly operate as if the “virtual APIC accesses” VM-execution control was cleared to 0 if another logical processor has the same value in CR3 and one of the following is true: • The other logical processor is not in VMX non-root operation. • The other logical processor has the “virtual APIC accesses” VM-execution control cleared to 0. • The other logical processor’s value of the “APIC-access address” VM-execution control field is different than that of the first logical processor.  	  A logical processor may fail to support the APIC-virtualization features properly if a virtual-machine monitor (VMM) uses the same page tables as a virtual machine (VM) using the APIC-virtualization features, or if two VMs (or two virtual CPUs within a VM) use the same page tables but operate with different settings of the APIC-virtualization features.  May 2012 Document Number: 324209-012  Intel® Atom™ Processor E6xx Series 17   	 A VMM should not use for itself the same page tables as a VM using the APICvirtualization features, and it should configure two virtual CPUs to use the same page tables only if they use the same settings of the APIC-virtualization features. 	  No Fix. 
  VM Exit Due to Fault While Delivering Software Interrupt May Save Incorrect Data Into VMCS  	  If a fault occurs during delivery of a software interrupt (INTn) in virtual-8086 mode when virtual mode extensions are in effect and that fault causes a VM exit, incorrect data may be saved into the VMCS. Specifically, information about the software interrupt may not be reported in the IDT-vectoring information field. In addition, the interruptibility-state field may indicate blocking by STI or by MOV SS if such blocking were in effect before execution of the INTn instruction or before execution of the VMentry instruction that injected the software interrupt.  	  In general, VMM software that follows the guidelines given in the section “Handling VM Exits Due to Exceptions” of the Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3B: System Programming Guide should not be affected. If the erratum improperly causes indication of blocking by STI or by MOV SS, the ability of a VMM to inject an interrupt may be delayed by one instruction.  	 VMM software should follow the guidelines given in the section “Handling VM Exits Due to Exceptions” of the Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3B: System Programming Guide. 	  No Fix. 
  VM Exit Occurring in IA-32e Mode May Not Produce VMX Abort When Expected  	  If a VM exit occurs while the processor is in IA-32e mode and the “host address-space size” VM-exit control is 0, a VMX abort should occur. Due to this erratum, the expected VMX aborts may not occur and instead the VM Exit will occur normally. The conditions required to observe this erratum are a VM entry that returns from SMM with the “IA32e guest” VM-entry control set to 1 in the SMM VMCS and the “host address-space size” VM-exit control cleared to 0 in the executive VMCS.  	  A VM exit will occur when a VMX abort was expected.  	 An SMM VMM should always set the “IA-32e guest” VM-entry control in the SMM VMCS to be the value that was in the LMA bit (IA32_EFER.LMA.LMA[bit 10]) in the IA32_EFER MSR (C0000080h) at the time of the last SMM VM exit. If this guideline is followed, that value will be 1 only if the “host address-space size” VM-exit control is 1 in the executive VMCS. 	  No Fix. 
  Performance Monitoring Event for Outstanding Bus Requests Ignores AnyThread Bit  	  The Performance Monitoring Event of Outstanding Bus Requests will ignore the AnyThread bit (IA32_PERFEVTSEL0 MSR (186h)/IA32_PERFEVTSEL1 MSR (187h) bit [21]) and will instead always count all transactions across all logical processors, even when AnyThread is clear.  	  The performance monitor count may be incorrect when counting only the current logical processor’s outstanding bus requests on a processor supporting Intel® HyperThreading Technologyα.  	 None identified. 	  No Fix.  Intel® Atom™ Processor E6xx Series 18  May 2012 Document Number: 324209-012  
  Thermal Interrupts Dropped During and While Exiting Deep PowerDown State  	  Thermal interrupts are ignored while the processor is in the Deep Power-Down State as well as during a small window of time while exiting from the Deep Power-Down State. During this window, if the PROCHOT signal is driven or the internal value of the sensor reaches the programmed thermal trip point, the associated thermal interrupt may be lost.  	  In the event of a thermal event while a processor is waking up from the Deep PowerDown State, the processor will initiate an appropriate throttle response. However, the associated thermal interrupt generated may be lost.  	 None identified. 	  No Fix. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	  The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. The Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A: System Programming Guide, Part 1, in the section titled “Switching to Protected Mode,” recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  No Fix. 
  Performance Monitoring Counter With AnyThread Bit Set May Not Count on Non-Active Thread  	  A performance counter with the AnyThread bit (IA32_PERFEVTSEL0 MSR (186h)/IA32_PERFEVTSEL1 MSR (187h) bit [21], IA32_FIXED_CTR_CTRL MSR (38Dh) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2) set should count that event on all logical processors on that core. Due to this erratum, a performance counter on a logical processor which has requested to be placed in the Deep Power-Down State may not count events that occur on another logical processor.  	  The performance monitor count may be incorrect when the logical processor is asleep but still attempting to count another logical processor’s events. This will only occur on processors supporting Intel® Hyper-Threading Technologyα (Intel® HT Technologyα).  	 None identified. 	  No Fix. 
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL MSR (38Dh) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186h)/IA32_PERFEVTSEL1 MSR (187h) bit [21]) set may not count correctly when  May 2012 Document Number: 324209-012  Intel® Atom™ Processor E6xx Series 19   counting only OS (ring 0) events or only USR (ring > 0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear. 	  A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core.  	 None identified. 	  No Fix. 
  PMI Request Not Generated on Counter Overflow if Its OVF Bit Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh), future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	  If software does not clear the OVF bit corresponding to a performance counter, future counter overflows may not cause PMI requests.  	 Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler. 	  No Fix. 
  Processor May Use Incorrect Translation if TLBs Contain Two Different Translations for Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4 kByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	  Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE.  	 Software can avoid this problem by ensuring that the TLBs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type. 	  No Fix. 
  Write to APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example, if an instruction that masks the interrupt flag, for example, CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, in other words, by an STI instruction. Interrupts will remain pending and are not lost.  	  In this example, the processor may allow interrupts to be accepted but may delay their service.  	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  No Fix.  Intel® Atom™ Processor E6xx Series 20  May 2012 Document Number: 324209-012  
  xTPR Update Transaction Cycle, if Enabled, May Be Issued to FSB After Processor Issued Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	  When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher, the result could be a system hang. 	NA	NA
 	NA	NA	NA	  No Fix. 
  Processor May Report #TS Instead of #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get an invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  No Fix. 
  Writing Local Vector Table (LVT) When Interrupt Pending May Cause Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	  An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector, the system will GP fault. If the ISR does not do an End of Interrupt (EOI), the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.  	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI; therefore, the spurious vector should not be used when writing the LVT. 	  No Fix. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from debug registers, a generalprotection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	  With debug-register protection enabled (in other words, the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  No Fix.  May 2012 Document Number: 324209-012  Intel® Atom™ Processor E6xx Series 21  
  Using 2M/4M Pages When A20M# Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit 20 to be masked (forced to zero) to emulate real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit 20 may not be masked. • Paging is enabled. • A linear address has bit 20 set. • The address references a large page. • A20M# is enabled.  	  When A20M# is enabled and an address references a large page, the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system.  	 Operating systems should not allow A20M# to be enabled if the masking of address bit 20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  No Fix. 
  Values for LBR/BTS/BTM Will Be Incorrect After Exit From SMM  	  After a return from SMM (System Management Mode), the processor will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence, rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the three above mentioned debug support facilities is used.  	  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified. 	  No Fix. 
  Incorrect Address Computed for Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64 kB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4 GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected, but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  No Fix. 
  Thermal Interrupt Not Generated When Current Temperature Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit [31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	  When the temperature reaches an invalid temperature the processor does not generate a thermal interrupt even if a programmed threshold is crossed.  	 None identified. 	  No Fix.  Intel® Atom™ Processor E6xx Series 22  May 2012 Document Number: 324209-012  
  Programming Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming the DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	  Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold.  	 In the ACPI/OS, implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  No Fix. 
  Returning to Real Mode From SMM With EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	  If SMM software changes the values of EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software.  	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  No Fix. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (in other words, residual stack data as a result of processing the fault).  	  Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to “Procedure Calls For Block-Structured Languages” in the Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 1: Basic Architecture for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0, and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  No Fix. 
  With TF (Trap Flag) Asserted, FP Instruction That Triggers Unmasked FP Exception May Take Single Step Trap Before Retirement of Instruction  	  If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  	  A single step trap will be taken when not expected.  	 None identified. 	  No Fix.  May 2012 Document Number: 324209-012  Intel® Atom™ Processor E6xx Series 23  
  Enabled Debug Breakpoint or Single Step Trap May Be Taken After MOV SS/POP SS Instruction if Followed by Floating Point Exception Signaling Instruction  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed automatically.  	  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software or system.  	 As recommended in the Intel® 64 and IA-32 Architectures Software Developer's Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  No Fix. 
  Code Segment Limit/Canonical Faults on RSM May Be Serviced Before Higher Priority Interrupts/Exceptions and May Push Wrong Address Onto Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to the execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority interrupt or exception (for example, NMI (Non-Maskable Interrupt), Debug break (#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  Operating systems may observe a #GP fault being serviced before higher priority interrupts and exceptions. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  No Fix. 
  BTS (Branch Trace Store) and PEBS (Precise Event Based Sampling) May Update Memory Outside BTS/PEBS Buffer  	  If the BTS/PEBS buffer is defined such that: • The difference between the BTS/PEBS buffer base and the BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes. • The BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space. • The record that would cross the BTS/PEBS absolute maximum will also continue past the end of the virtual address space.  Intel® Atom™ Processor E6xx Series 24  May 2012 Document Number: 324209-012   A BTS/PEBS record can be written that will wrap at the 4G boundary (legacy mode) or 264 boundary (IA-32e mode, including both 64-bit mode and compatibility mode), and write memory outside of the BTS/PEBS buffer. 	  Software that uses BTS/PEBS near the 4G boundary (legacy mode) or 264 boundary (IA-32e mode, including both 64-bit mode and compatibility mode) and defines the buffer such that it does not hold an integer multiple of records can update memory outside the BTS/PEBS buffer.  	 Define the BTS/PEBS buffer such that the BTS/PEBS absolute maximum minus the BTS/PEBS buffer base is an integer multiple of the corresponding record sizes as recommended in the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B. 	  No Fix. 
  Single Step Interrupts With Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single step execution, processing of the single step debug exception (#DB) may be mishandled.  	  When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (interrupt 16). • #DB is generated twice on the same instruction.  	 None identified. 	  No Fix. 
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	  In this case, the phrase “unexpected or unpredictable execution behavior” encompasses the generation of most of the exceptions listed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors.  	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, section “Handling Self- and CrossModifying Code.” 	  No Fix. 
  LBR Stack May Not Be Frozen on PMI Request When FREEZE_LBRS_ON_PMI Set  	  When the FREEZE_LBRS_ON_PMI flag (IA32_DEBUGCTL MSR (1D9h) bit [11]) is set on an Intel® Atom™ Processor E6xx Series, a PMI (performance monitor interrupt) request should cause the LBR and TR flags (IA32_DEBUGCTL MSR (1D9h) bit [1:0]) to be cleared and the LBR (last branch record) stack to stop being updated by branches/interrupts/exceptions. Due to this erratum, the processor may clear the LBR  May 2012 Document Number: 324209-012  Intel® Atom™ Processor E6xx Series 25   and TR flags but not stop the LBR stack from FREEZE_LBRS_ON_PMI is set and a PMI request occurs. 	  being  updated  when  Following a PMI request, the LBRs may continue to be updated by branches/interrupts/exceptions even when FREEZE_LBRS_ON_PMI is set. The LBRs may contain values recorded after the PMI request.  	 None identified. 	  No Fix. 
  PMI Request Not Generated on Counter Overflow if Its OVF Bit Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh), future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	  If software does not clear the OVF bit corresponding to a performance counter, future counter overflows may not cause PMI requests.  	 Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler. 	  No Fix. 
  Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7h, E8h) increments to its maximum value of FFFF_FFFF_FFFF_FFFFh, both MSRs are supposed to synchronously reset to 0h on the next clock. Due to this erratum, IA32_MPERF may not be reset when IA32_APERF overflows. Instead, IA32_MPERF may continue to increment without being reset.  	  Due to this erratum, software cannot reply on the synchronous reset of the IA32_MPERF register. The typical usage of IA32_MPERF/IA32_APERF is to initialize them with a value of 0; in this case, the overflow of the counter would not happen for ten years.  	 None identified. 	  No Fix. 
  Processor May Not Recognize Signal PWROK on Its Initial Assertion  	  During any system power-on event in which power had been removed from the processor (including S3), the processor may fail to recognize the PWROK input signal during power-up. This missed observation is dependent upon the processor temperature and can cause the system not to boot.  	  The system may fail to boot. Each processor may be affected at different temperature ranges.  	 An external hardware workaround has been identified and may be implemented for this erratum. 	  Plan Fix. 
  Image on SDVO Display Clipped When Multiple Display Planes and SDVO Port Enabled  	  An internal timing generator and the SDVO (Serial Digital Video Output) timing generator may become out of synch with each other. This condition only manifests when any combination of multiple display planes and the SDVO port are concurrently enabled and can result in a clipped image.  	  A clipped image will be observed on the SDVO display.  Intel® Atom™ Processor E6xx Series 26  May 2012 Document Number: 324209-012   	 A software change has been identified and may be implemented as a workaround for this erratum. 	  Plan Fix. 
  Large Amounts of LPC Bus Memory Reads and Writes May Temporarily Starve Other I/O Devices  	  During heavy memory read and memory write traffic to the LPC (Low Pin Count) Bus, downstream transactions to I/O devices may be blocked for periods of 3.2 µs.  	  I/O devices may suffer a performance impact (for example, audio glitches).  	 None identified. 	  No Fix. 
  Delayed I/O Device Memory Transactions Can Cause System Hang  	  Back-to-back uncacheable write transactions issued by the processor to downstream I/O devices can cause indeterminate delays to completions of upstream memory transactions from I/O devices.  	  Long bursts of downstream transactions may cause system hangs and/or audio glitches. 	NA	NA
 identified. 	NA	NA	NA	  No Fix. 
  Software Can Inadvertently Change SDVO Base Class Code Register  	  Software that programs the unused SDVO (Serial Digital Video Out) base address register at offset 1Ch (Bus 0; Device 3; Function 0) inadvertently modifies the SDVO base class code register (Bus 0; Device 3; Function 0; Offset 9h) to an incorrect value.  	  Software that relies on the base class code could fail to function properly or will report the SDVO device incorrectly. 	NA	NA
 	NA	NA	NA	  Plan Fix. 
  Voltage Supplied to Internal RTC Logic Violates Design Specification  	  An internal voltage regulator for the RTC (Real Time Clock) logic produces an overvoltage condition and potential damage to the internal logic.  	  The processor is not guaranteed to meet a 10 year reliability lifetime. The system may fail to boot over a period of time or exhibit inaccurate RTC clock operation.  	 A workaround has been identified. Please refer to the Intel® Atom™ Processor E6xx Series Erratum: “Voltage Supplied to Internal RTC (Real Time Clock) Logic Violates Design Specification” FAQ, order number 324702, for further details 	  Plan Fix. 
  Flickering May be Observed on Display while Running Intensive Graphics and Video Decoding Activities  	  During intensive graphics and video playback activities, and with large numbers of display read requests, the display may experience flickering.  	  Flickering may be observed on displays connected to the integrated display engine. 	NA	NA
 	NA	NA	NA	  Plan Fix.  May 2012 Document Number: 324209-012  Intel® Atom™ Processor E6xx Series 27  
  C6 Request May Cause a Machine Check if the Other Logical Processor is in C4 or C6  	  A machine check may be generated if a logical processor requests the C6 C-state and the other logical processor is in either the C4 or C6 C-states.  	  This erratum may result in unexpected machine-check exceptions. 	NA	NA
 	NA	NA	NA	  No Fix. 
  EOI Transaction May Not be Sent if Software Enters Core C6 During an Interrupt Service Routine  	  If core C6 is entered after the start of an interrupt service routine but before a write to the APIC EOI (End of Interrupt) register, and the core is woken up by an event other than a fixed interrupt source the core may drop the EOI transaction the next time APIC EOI register is written and further interrupts from the same or lower priority level will be blocked.  	  EOI transactions may be lost and interrupts may be blocked when core C6 is used during interrupt service routines.  	 Software should check the ISR register and if any interrupts are in service only enter C1. 	  No Fix. 
  PCNT Throttling May Cause System Hang During TM1 Thermal Event  	  The TM1 (Thermal Monitor 1) thermal event and PCNT (Processor Control) mechanism can each independently control processor throttling and should work at the same time without issues. Due to this erratum, if PCNT throttling is enabled during a TM1 thermal event, the two throttling mechanisms may conflict with each other and leading to a system hang.  	  When this erratum occurs, the system may hang. 	NA	NA
 this erratum. 	NA	NA	NA	  No fix. 
  VMX Transitions May Set Bits 63:32 of the IA32_FMASK MSR  	  Bits 63:32 of the IA32_FMASK MSR (C0000084H) are reserved and attempts to set them should fail. Due to this erratum, loads of this MSR as part of a VMX transition (from either the VM-exit MSR-load area or the VM-entry MSR-load area) may set any of these bits without causing the transition to fail.  	  Subsequent reads of the IA32_FMASK MSR (e.g. by RDMSR) will return a non-zero value for bits 63:32. Intel has not observed this erratum with any commercially available software.  	 Software should ensure that bits 63:32 are all 0 in any entry for the IA32_FMASK MSR in any VM-exit MSR-load area or VM-entry MSR-load area. 	  No Fix 
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	  An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does  Intel® Atom™ Processor E6xx Series 28  May 2012 Document Number: 324209-012   not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  No Fix. 
  Clearing PCIe* Root Port's BME Bit With Pending Upstream Traffic Will Cause Internal Bus to Hang  	  When there are upstream transactions in any of the PCIe root port's buffers and the BME (Bus Master Enable) bit of that root port is cleared to disable the port as bus master, the completion from the BME clear configuration cycle becomes blocked by the pending upstream transactions. Given these conditions, the processor will time out waiting for the blocked configuration cycle.  	  Due to this erratum an internal bus will hang leading to: IERR, NMI, Reset, etc. 	NA	NA
 BMEs after the attached end point devices are put into idle state with no pending	NA	NA	NA	NA
 OS. 	NA	NA	NA	  No Fix. 
  CPUID Instruction Returns Incorrect Brand String  	  When a CPUID instruction is executed with EAX = 80000002H, 80000003H and 80000004H on an Intel® Atom™ processor, the return value contains the brand string Genuine Intel (R) CPU when it should have Intel(R) Atom(TM) CPU with the corresponding SKU (e.g.,: E620 or E660).  	  When this erratum occurs, the processor will report the incorrect brand string. 	NA	NA
 	NA	NA	NA	  No Fix. 
  The APIC Timer May Drift When Bus Ratios Less Than 6 Are Used  	  The APIC Timer may not decrement correctly when using bus ratios lower than 6. This may cause limited amounts of drift.  	  Due to this erratum, in the worst case of a nominal bus frequency of 100 MHz, a DCR (Divide Configuration Register) of 128 and a bus ratio of 4, the counter can drift by up to ~60 µs per timer countdown. 	NA	NA
 will disable bus ratios less than 6. 	NA	NA	NA	  No fix for B0. Ultra Low Frequency Mode is de-featured in B1. 
  Extended Tags Are Always Used But Not Reported on PCIe* Root Ports  	  Although the device's PCIe root ports do not report 8-bit Extended Tag support in the DCAP.EFTS register and don't allow the enabling of Extended Tags in the DCTL.ETFE register, they will still generate transactions with Extended Tags.  	  PCIe end points that do not support extended tags as required by the PCIe Base Specification may fail.  	 None identified. 	  No fix  May 2012 Document Number: 324209-012  Intel® Atom™ Processor E6xx Series 29  
  Outbound MSI From The PMU Can Result in Live Lock And/or System Hang When Simultaneously Occurring With an Inbound I/O Read  	  The Power Management Unit (PMU) is capable of generating Message Signaled Interrupts (MSI) to the processor. In specific corner cases, an outbound MSI from the PMU may occur simultaneously with an inbound I/O read resulting in live lock and/or a system hang.  	  When this erratum occurs, the processor may live lock and/or result in a system hang. The PMU will not be able to support MSI for display power up and thermal trip events.  	 PMU MSIs have been disabled in firmware. Software is required to not enable the MSIs for thermal events and Display power up. 	  No Fix 
  SMBus Timing Violation  	  Due to this erratum, there is a violation of the specified requirement for SMB Hold Time. The processor hold time from the falling edge of SMB Data to the falling edge of SMB CLK is 1/4 the programmed SMB CLK period. In the case of a 100 kHz bus, this becomes 10 µs / 4 = 2.5 µs, which violates the 4.0 µs specification.  	  Intel has not observed any functional failures with any commercially available systems.  	 Customers have the option to program for slower SMB CLK. 	  No Fix. 
  RTC Does Not Detect a Coin Cell Battery Low Voltage Condition  	  The RTC's (Real Time Clock) TRC.RTCIO bit in the GPE0BLK (Offset 34H; bit 2) is not set to 1 when the coin cell battery voltage is below the replacement threshold.  	  Software is unable to report when the RTC battery voltage is below the replacement threshold.  	 None identified. 	  No Fix.
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, e.g. CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  In this example the processor may allow interrupts to be accepted but may delay their service. This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	NA	  BIOS must leave the xTPR update transactions disabled (default).  	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software. None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes.   15  
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault. In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	NA	NA	  16  For the steppings affected, see the Summary Tables of Changes.   
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit 20 may not be masked. • paging is enabled • a linear address has bit 20 set • the address references a large page • A20M# is enabled  When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system. Operating systems should not allow A20M# to be enabled if the masking of address bit 20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes.   17  
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	NA	NA	  18  For the steppings affected, see the Summary Tables of Changes.   
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. SMM software should not change the value of EFLAGS.VM in SMRAM. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software. 	NA	  None  	  For the steppings affected, see the Summary Tables of Changes. 
  With TF (Trap Flag) Asserted, FP Instruction That Triggers an Unmasked FP Exception May Take Single Step Trap before Retirement of Instruction  	  If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  A Single Step trap will be taken when not expected. 	NA	 	  None  For the steppings affected, see the Summary Tables of Changes.   19  
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. None 	NA	NA	  20  For the steppings affected, see the Summary Tables of Changes.   
  BTS(Branch Trace Store) and PEBS(Precise Event Based Sampling) May Update Memory outside the BTS/PEBS Buffer  	  If the BTS/PEBS buffer is defined such that: • The difference between BTS/PEBS buffer base and BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes • BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space • The record that would cross BTS/PEBS absolute maximum will also continue past the end of the virtual address space  A BTS/PEBS record can be written that will wrap at the 4G boundary (IA32) or 2^64 boundary (EM64T mode), and write memory outside of the BTS/PEBS buffer. Software that uses BTS/PEBS near the 4G boundary (IA32) or 2^64 boundary (EM64T mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the BTS/PEBS buffer. Define BTS/PEBS buffer such that BTS/PEBS absolute maximum minus BTS/PEBS buffer base is integer multiple of the corresponding record sizes as recommended in the IA-32 Intel® Architecture Software Developer’s Manual, Volume 3. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes.   21  
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors. In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Section: Handling Self- and Cross-Modifying Code. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: •  A SMI that is pending while a lower priority event is executing  • A REP I/O read • A I/O read that redirects to MWAIT SMM handlers may get false IO_SMI indication. The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	NA	NA	  22  For the steppings affected, see the Summary Tables of Changes.   
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software. Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May be Incorrect  	  When an L2 Cache error occurs (Error code 0x010A or 0x110A reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors. None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  Software may observe #MF being serviced before higher priority interrupts. None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes.   23  
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC1_STATUS MSR Bit [60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit [60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. None 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  Split Locked Stores or Locked Stores Through Certain Segments May not Trigger the Monitoring Hardware  	  Logical processors normally resume program execution following the MWAIT, when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation. Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store within the monitored address range that either spans across cache lines or uses a segment register whose segment base is noncacheline aligned.  The logical processor that executed the MWAIT instruction may not resume execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is either split across cache lines or through a segment whose segment base bits 5 to 0 are non-zero. Avoid accessing the monitored address range using either locked stores that split cache lines or locked stores that use a segment with a non-cacheline aligned segment base. It is possible for the BIOS to contain a workaround for this erratum 	NA	NA	  24  For the steppings affected, see the Summary Tables of Changes.   
  When BIST is Enabled, Warm Reset Incorrectly Clears IA32_FEATURE_CONTROL MSR and the Last Exception Record MSRs  	  IA32_FEATURE_CONTROL MSR (3AH), MSR_LER_FROM_LIP MSR (1DDH), and MSR_LER_TO_LIP MSR (1DEH) are cleared during warm reset when BIST (BuiltIn Self Test) is enabled. These MSRs should only be cleared on a power-up reset and not on a warm reset. A warm reset is different from a power-up reset in that PWRGOOD remains active throughout the assertion of RESET#.  Due to this erratum, any warm reset will clear IA32_FEATURE_CONTROL MSR, MSR_LER_FROM_LIP MSR, and MSR_LER_TO_LIP MSR content when BIST is enabled. BIOS or other firmware software must save IA32_FEATURE_CONTROL MSR, MSR_LER_FROM_LIP MSR, and MSR_LER_TO_LIP MSR information before warm reset and restore and reprogram the MSRs after the warm reset. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  LBR/BTM/BTS Information Immediately After a Transition From Legacy/Compatibility Mode to 64-bit Mode May be Incorrect  	  If a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any FROM address recorded by LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) on that second event may incorrectly report the upper 32-bits as zero.  Due to this erratum, bits 63:32 of the ‘FROM’ value for LBR/BTM/BTS may be improperly zeroed after a transition to 64 bite mode when the RIP (Instruction Pointer Register) is greater than 4 Gigabyte. None identified. This erratum may be detected by a ‘FROM’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘TO’ address recorded. 	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction Returns Incorrect Brand String  	  When a CPUID instruction is executed with EAX = 80000002H, 80000003H and 80000004H on an Intel® Atom™ processor, the return value contains the brand string Intel(R) Core(TM) CPU when it should have Intel(R) Atom(TM) CPU.  	 When this erratum occurs, the processor will report the incorrect brand string. 	  It is possible for the BIOS to contain a workaround for this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  A Logical Processor May Incorrectly Clear Thermal Status Log Indicator During Intel Deep Power Down Technology State Transition  	  When a logical processor enters the Intel Deep Power Down Technology State (e.g. as requested by MWAIT or I/O redirection), it may incorrectly clear the sticky Thermal Status Log flag (bit 1) in IA32_THERM_STATUS MSR (19CH). This erratum will not occur when Hyper-Threading (HT) is disabled.   25   	 When Hyper-Threading is enabled, a logical processor may incorrectly indicate that the thermal sensor has not tripped since last power-up. 	  It is possible for the BIOS to contain a workaround for this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  The Instruction Cache Does Not Respond to Snoops When All Logical Processors on a Core Are in an Inactive State  	  When all logical processors on a core enter an inactive state (e.g. MWAIT or HLT), the processor may incorrectly stop flushing lines in its instruction cache in response to snoops. This may cause the processor to not detect that memory has been modified and to execute the old instructions after waking up instead of the new contents of memory.  	 The processor may execute incorrect instructions after waking up from an inactive state. 	  It is possible for the BIOS to contain a workaround for this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  LINT0 Assertion and Deassertion During an Inactive State May Cause Unexpected Operation When APIC is Disabled  	  An interrupt delivered via LINT0 pins when the APIC is hardware disabled (IA32_APIC_BASE MSR (1BH) bit [11] is cleared) will usually keep the pin asserted until after the interrupt is acknowledged. However, if LINT0 is asserted and then deasserted before the interrupt is acknowledged and both of the following are true; •  the APIC is hardware disabled (IA32_APIC_BASE MSR bit [11] is clear) and  •  the processor is in an inactive state that was requested by MWAIT, I/O redirection, VM-entry or RSM, then the processor may operate incorrectly.  	 Due to this erratum, the processor may run unexpected code and/or generate an unexpected exception. Intel has not observed this erratum with any commercially available software. 	 If LINT0 is used, it is recommended to either leave the APIC enabled (IA32_APIC_BASE MSR bit [11] set to 1) or do not use MWAIT, I/O redirection, VMentry or RSM to enter an inactive state. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  Processor May Not Wake Up from an Inactive State When an Enhanced Intel® SpeedStep Technology Transition is Pending  	  Due to this erratum, the processor may hang in rare scenarios when it is in an inactive state and there is an Enhanced Intel® SpeedStep Technology transition pending.  	 The processor may hang and be unable to resume execution. A processor reset will be needed to restart processor execution. Intel has not observed this erratum with any commercially available software. 	  It is possible for the BIOS to contain a workaround to this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	  Software should not generate misaligned stack frames for use with IRET.  	  For the steppings affected, see the Summary Tables of Changes. 
  Thermal Interrupts are Dropped During and While Exiting Intel® Deep Power-Down State  	  Thermal interrupts are ignored while the processor is in Intel Deep Power-Down State as well as during a small window of time while exiting from Intel Deep Power-Down State. During this window, if the PROCHOT signal is driven or the internal value of the sensor reaches the programmed thermal trip point, then the associated thermal interrupt may be lost.  	 In the event of a thermal event while a processor is waking up from Intel Deep PowerDown State, the processor will initiate an appropriate throttle response. However, the associated thermal interrupt generated may be lost. 	 	  None identified.  For the steppings affected, see the Summary Tables of Changes.   27  
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	  None identified.  	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction Returns Incorrect Value For Leaf 0xA  	  When a CPUID instruction is executed with EAX = 0AH, the value returned in EDX is 0x2501, which reports support for only one fixed-function performance counter and also has an undefined bit [bit 13] set . The value of EDX should be 0x0503, reflecting that three fixed-function performance counters are supported.  	 When this erratum occurs, the processor will report an incorrect value in EDX. 	  None  	  For the steppings affected, see the Summary Tables of Changes. 
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring >0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core. 	 	  28  None  For the steppings affected, see the Summary Tables of Changes.   
  PMI Request is Not Generated on a Counter Overflow if Its OVF Bit is Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh) then future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	 If software does not clear the OVF bit corresponding to a performance counter then future counter overflows may not cause PMI request. 	  Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler  	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Indicates Wrong L2 Associativity in Leaf 80000006H  	  When a CPUID instruction is executed with EAX= 80000006H on a processor with a 512K L2 cache, it incorrectly returns 08H in ECX[15:12] which indicates a 16-way set associative L2. The return value in ECX[15:12] should have been 06H to indicate a 8way set associative L2.  	 CPUID will report the L2 set associativity as 16-way when it should report 8-way. 	  None  	  For the steppings affected, see the Summary Tables of Changes. 
  Code Fetch May Occur to Incorrect Address After a Large Page is Split Into 4-KByte Pages  	  If software clears the PS (page size) bit in a present PDE (page directory entry), that will cause linear addresses mapped through this PDE to use 4-KByte pages instead of using a large page after old TLB entries are invalidated. Due to this erratum, if a code fetch uses this PDE before the TLB entry for the large page is invalidated then it may fetch from a different physical address than specified by either the old large page translation or the new 4-KByte page translation. This erratum may also cause speculative code fetches from incorrect addresses.  	 The processor may fetch code from an incorrect address after a large page is converted into 4-Kbyte pages. 	 	  None  For the steppings affected, see the Summary Tables of Changes.   29  
  Processor May Contain Incorrect Data and Hang Upon a Snoop When Combined with Specific Other Internal Conditions  	  In a specific corner case a snoop to a processor may cause incorrect data that will be followed by a hang.  	 Due to this erratum, the processor may contain incorrect data and hang in this specific circumstance. 	  It is possible for the BIOS to contain a workaround for this erratum  	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Use an Incorrect Translation if the TLBs Contain Two Different Translations For a Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4-KByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	 Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE. 	 Software can avoid this problem by ensuring that the TLBs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Feature Flag Incorrectly Indicates TM2 as Supported  	  Processors with no support for TM2 (Intel® Thermal Monitor 2) falsely report support for TM2 as indicated by TM2 (bit 8) being set in the Feature Flag returned in ECX when executing CPUID with EAX=01H.  	 CPUID Feature Flag TM2 cannot be used to identify processors where TM2 is not supported. 	 	  30  None identified.  For the steppings affected, see the Summary Tables of Changes.   
  IA32_MC2_STATUS [OVERFLOW] Bit is Not Set When Single-Bit Correctable ECC Error Occurs  	  The OVERFLOW bit should be set if the VAL bit (IA32_MC2_STATUS (409H) bit [63]) is set when a new error occurs. Due to this erratum, the OVERFLOW bit (IA32_MC2_STATUS (409H) bit [62]) is only set when a prior uncorrected error (as indicated by the UC bit (IA32_MC2_STATUS (409H) bit [61])) is present at the time the second error occurs.  	 Any L2 correctable error will not set the IA32_MC2_STATUS.OVERFLOW bit when overwriting a prior L2 correctable error. 	 The frequency of occurrence of this problem is reduced greatly if an operating system regularly polls and clears the machine check banks as this reduces the likelihood of an overflow condition 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software 	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary 	  For the steppings affected, see the Summary Tables of Changes.   31  
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software 	 If the FP Data Operand Pointer is used in an operating system which may run 16bit FP code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary 	NA
  Intel® High Definition Audio (Intel® HD Audio) Buffer Slew Rate Rise Does Not Meet Specification  	  Intel HD Audio rising edge slew rate is less than 1-V/ns. This violates the High Definition Audio Specification of being greater than 1-V/ns. 	 Intel HD Audio will not meet the High Definition Audio specification. This does not impact platform functionality.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  PLL Misaligned Clock Sources on Boot May Cause System Hang or Reset  	  The DMI, DDR3 and processor reference clock may become misaligned due to clock jitter on system startup (cold boot, warm reset or S3 resume) causing unpredictable system behavior including additional resets. 	 Due to this erratum, excessive clock jitter may cause unpredictable system behavior.  	 A CK NET clock chip must be used that meets jitter specification of 85 ps. The processor clocks (HPLL_REFCLK, DMI_REFCLK & DDR3_REF) and Intel® NM10 chipset (DMI_CLK) require clocks that are from the same PLL source. 	  For the steppings affected, see the Summary Table of Changes. 
  Extreme Stress on Multiple USB Devices May Cause Unexpected Noise on USB Speaker Device While Connected Behind a Hub  	  When multiple USB devices are generating heavy traffic and audio is playing through an USB speaker device behind a hub, up to several clicks per minute may be heard on the USB speaker device on back to back I/O accesses. An example of the configuration in which this occurs is USB audio behind a hub with a USB 8MP webcam and 2 USB thumb drives transferring data. Failures were not observed after reducing the USB webcam bandwidth. 	 Due to the limitations on bus transactions and heavy traffic on back to back I/O accesses, users may hear up to several clicks per minute on USB audio devices.  	 None Identified. 	  14  For the steppings affected, see the Summary Table of Changes.   
  Sporadic Scan Lines Artifacts May be Seen While Running HD Video  	  When the media player software uses the graphics engine for video post processing and the OS provided synchronization between graphics and display engine is not used, occasional scan line artifacts may be seen with certain HD video clips on high resolution displays if media player does not use overlay. 	 If the media player software uses the graphics engine for video post processing and writes to the same frame buffer that display engine is reading (scanning), partial scan line artifacts may be seen occasionally during certain HD video playback. This does not impact functionality.  	 A. Run media player software in an environment with OS provided sync enabled (using double buffer or buffer chains). An example in the Windows environment is with aero on. Or B. Use of overlay interface by the media player software. 	  For the steppings affected, see the Summary Table of Changes. 
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected. 	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software.  	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  For the steppings affected, see the Summary Table of Changes.   15  
  Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. Due to this erratum, IA32_MPERF may not be reset when IA32_APERF overflows. Instead, IA32_MPERF may continue to increment without being reset. 	 Due to this erratum, software cannot rely on synchronous reset of the IA32_MPERF register. The typical usage of IA32_MPERF/IA32_APERF is to initialize them with a value of 0; in this case the overflow of the counter wouldn’t happen for over 10 years.  	 None Identified. 	  For the steppings affected, see the Summary Table of Changes. 
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to it being set. 	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.  	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1”. 	  For the steppings affected, see the Summary Table of Changes. 
  LBR/BTM/BTS Information Immediately after a Transition from Legacy/Compatibility Mode to 64-bit Mode May be Incorrect  	  If a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any FROM address recorded by LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) on that second event may incorrectly report the upper 32-bits as zero. 	 Due to this erratum, bits 63:32 of the ‘FROM’ value for LBR/BTM/BTS may be improperly zeroed after a transition to 64-bit mode when the RIP (Instruction Pointer Register) is greater than 4 Gigabyte.  	 None identified. This erratum may be detected by a ‘FROM’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘TO’ address recorded. 	  16  For the steppings affected, see the Summary Table of Changes.   
  VID Information in IA32_PERF_STS MSR Bits [7:0] May be Incorrect  	  IA32_PERF_STS MSR (198H) bits [7:0] are supposed to indicate the VID (Voltage ID) after an EIST (Enhanced Intel SpeedStep® Technology) transition. Due to this erratum, one core in a dual-core CPU may report incorrect VID values in certain corner cases. 	 IA32_PERF_STS MSR bits [7:0] may contain incorrect VID values after certain EIST transitions.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  GP and Fixed Performance Monitoring Counters with Any Thread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the Any Thread bit (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring >0) events. The counters will count correctly if they are counting both OS and USR events or if the Any Thread bit is clear. 	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core.  	 None Identified. 	  For the steppings affected, see the Summary Table of Changes. 
  C6 Auto-Demotion Does Not Occur as Expected  	  C6 auto-demotion is enabled by setting PMG_CST_CONFIG_CONTROL MSR (E2H) bit 25 to 1. When enabled, C6 C-state is demoted to a lower C-state if average C6 residency time is low. Due to this erratum auto-demotion will not occur even when this bit is set and the average C6 residency time is low. 	 Due to this erratum the C6 transition may occur more frequently than desired.  	 The BIOS contains a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.   17  
  APIC Timer Can Expire Earlier Than Expected  	  Under certain circumstances, the APIC Timer may expire early on the first expiration after the CCR (Current Count Register) of the Local APIC is programmed. If the CCR in the APIC is written when BUS clock frequency is twice as fast as the nominal BUS clock, the first countdown of the APIC Timer may or may not expire ‘n’ nominal BUS clocks early, where n can be [1, 2, 4, 8, 16, 32, 64, 128] as determined by the DCR (Divide Configuration Register) in the Local APIC. In the worst case, for a nominal BUS frequency of 100 MHz and a DCR of 128 the APIC Timer can expire, 1280 ns early. 	 When CCR is written while BUS clock frequency is twice as fast as the normal BUS clock. The APIC timer may expire early on the first expiration.  	 None Identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Core C-state Residency MSR Values Are Incorrect  	  RDMSR of the core C-state residency MSRs will return a value of zero regardless of the actual residency time. This affects the following MSRs: C2_RESIDENCY_TIMER (3F8H) C4_RESIDENCY_TIMER (3F9H) C6_RESIDENCY_TIMER (3FAH) 	 Software cannot determine core C-state residencies by reading these MSRs.  	 The BIOS contains a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes 
  Local APIC Timer Expiration May Not be Honored if Software Requests Different Deep C-states For Each Logical Processor  	  If one logical processor requests the C6 state and the other logical processor requests the C4 state in close temporal proximity, the local APIC timer expiration event of the logical processor going to C6 may be dropped. 	 The platform will wake based only on the local APIC timer of the logical processor going to C4, or can hang if the timer is disabled.  	 The BIOS contains a workaround for this erratum. 	  18  For the steppings affected, see the Summary Table of Changes.   
  Task-switching IRET May Not Guarantee That All Memory Writes Have Become Globally Visible  	  Serializing instructions ensure that all preceding memory writes have become globally visible before any subsequent load or store instruction. An IRET is a serializing instruction. Due to this erratum, an IRET instruction that performs a task-switch does not guarantee serializing behavior. 	 Memory writes may not be observed in the correct order with respect to the task-switching IRET instruction.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  An Indirect Jump Instruction May Execute to An Incorrect Target  	  An indirect jump instruction may execute incorrectly to the target from a previous instance of the jump instead of the correct target. This may occur only when the indirect jump is part of a short loop. 	 Due to this erratum, an indirect jump may cause unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  A VM Exit as a Result of a Task-switching IRET May Not Properly Save the Status of NMI Blocking  	  A VM exit due to a fault or an EPT violation caused by an IRET instruction should set bit 12 (NMI unblocking due to IRET) of the VM-exit interruption-information field or the exit qualification. This is required if IRET begins execution when either (1) the “NMI exiting” VM-execution control w is 0 and blocking by NMI is in effect; or (2) the “virtual NMIs” VM-execution control w is 1 and virtual-NMI blocking w is in effect. Due to this erratum, such VM exits may clear this bit if the IRET was causing a task switch. 	 If a VMM resumes a guest at the IRET instruction after handling such a VM exit, an NMI or a VM exit due to the 1-setting of the “NMI-window exiting”, VM-execution control may be delivered prematurely.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  680 Ohms Pull Down Resistor for CRT_IREF May Violate VESA Spec  	  At maximum luminance, the RGB output may be up to 3% below the “max luminance specification”(0.665V) on some system when using a 680 Ohms IREF resistor. 	 Customers may observe lower brightness on a CRT monitor.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   19  
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code. 	 In this case, the phrase “unexpected or unpredictable execution behavior” encompassed the generation of the most of the exception listed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors.  	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Section: Handling Self- and CrossModifying Code. 	  For the steppings affected, see the Summary Table of Changes. 
  Software Requested or Thermal Based Clock Modulation May Not Result in an Accurate Stop-Clock Duty Cycle  	  Clock modulation can be requested either by software through the IA32_CLOCK_MODULATION MSR (19AH) or based on thermal conditions through the TM1 feature enabled (bit 3) in IA32_MISC_ENABLE (1A0H). Both engage internal stopclock circuitry to create the requested duty cycle. This duty cycle ranges from 12.5% to 87.5%. The actual measured duty cycle may not be accurate if either clock modulation method is enabled.  	 Software which is sensitive to the accuracy of the requested clock modulation duty cycle may not operate properly 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes 
  Programming MSR_PKG_CST_CONFIG_CONTROL Package C-state Limit Field to 0x3 May Result in a System Hang  	  When software requests an MWAIT with a target state of 2 or greater and the MSR_PKG_CST_CONFIG_CONTROL MSR (0E2H) Package C-state Limit (bits 2:0) is programmed with a value of 0x3 it is possible for the system to hang .  	 Due to this erratum, an MWAIT instruction could result in a system hang 	 It is possible for the BIOS to contain a workaround for this erratum. 	 
 20  For the steppings affected, see the Summary Table of Changes  Display Corruption May be Observed   	  Anomalies in graphics sampler cache may cause the cache to return incorrect data, which may result in unexpected graphics subsystem behavior.  	 Due to this erratum visual artifacts, sometimes in form of single horizontal line, or other unexpected graphics subsystem behavior may be observed during normal operation. In some cases, these artifacts may persist across an S3/S4/reboot cycle. 	 The Intel® Graphics Media Accelerator Driver 3600 Series Hot Fix Production Version  8.0.0.3.1075 or later, contains a Workaround for this Erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  The Value Reported For Last C-state May be Incorrect  	  The value of last C-state as reported in the C6C entry bits of 30:27 of PMBA register (70H) may be incorrect.  	 Due to this erratum, the value of last C-state may be incorrect. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  CS Limit Violations May Not be Detected After VM Entry  	  The processor may fail to detect a CS limit violation on fetching the first instruction after VM entry if the first byte of that instruction is outside the CS limit but the last byte of the instruction is inside the limit.  	 The processor may erroneously execute an instruction that  should have caused a general protection exception. 	 When a VMM emulates a branch instruction, it should inject a general  protection exception if the instruction’s target EIP is beyond the CS limit. 	  For the steppings affected, see the Summary Table of Changes. 
  Non-BSP Core May Hang When Exiting Processor C-state With DDR Self Refresh Enabled  	  Exiting processor C-state with DDR Self Refresh enabled may cause non-BSP core to hang.  	 Due to this erratum, the non-BSP core may hang while exiting  the processor C-state. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  GFX Throttling above 12.5% May Cause a System Hang  	  When throttling is set to above 12.5% the graphics processor may hang.   21   	 Due to this erratum, the graphics processor may hang, leading  to a system hang. 	 It is possible for the BIOS to contain a workaround for this erratum. This  workaround will limit the GFX throttling to 12.5%. 	  For the steppings affected, see the Summary Table of Changes. 
  Graphics Unit May Not Thermal Throttle  	  At high temperature the graphics unit may fail to thermal throttle.  	 Due to this erratum, under periods of high temperature the absence of thermal throttling may cause the processor to experience a thermal shut down event . 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  CPUID Instruction Returns Incorrect Brand String  	  When the CPUID instruction is executed with EAX = 80000002H, 80000003H, or 80000004H, the returned brand string will be incorrect; it will be missing D2 or N2 prefix.  	 When this erratum occurs, the processor will report an incorrect model number in the brand string. 	 It is possible for the BIOS to contain a workaround for this erratum .	NA
  REP MOVS/STOS Executing With Fast Strings Enabled And Crossing Page Boundaries With Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under the conditions described in the Software Developers Manual section “Fast String Operation,” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum, fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary, the following may occur, dependent on the new page  memory type:   UC: The data size of each read and write may be different than the original data size.    WP: The data size of each read and write may be different than the original data size and there may be a memory ordering violation.    WT: There may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC,  WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  22  For the steppings affected, see the Summary Table of Changes.   
  Complex Conditions Associated With Instruction Page Remapping or Self/Cross-Modifying Code Execution May Lead to Unpredictable System Behavior  	  Under a complex set of internal conditions, instruction page remapping, or self/cross modifying code events may lead to unpredictable system behavior.  	 Due to this Erratum, unpredictable system behavior may be observed. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Paging Structure Entry May be Used Before Accessed And Dirty Flags Are Updated  	  If software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a TLB (or an entry in a paging structure cache) and then update the entry’s new value to set the accessed flag or dirty flag. This will occur only if both the old and new values of the entry result in valid translations.  	 Incorrect behavior may occur with algorithms that atomically check that the accessed flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation. 	 Affected algorithms must ensure that appropriate TLB invalidation is done before assuming that future accesses do not use translations based on the old value of the paging structure entry. 	NA
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit-23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	 BIOS must leave the xTPR update transactions disabled (default). 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Report a #TS Instead of a #GP Fault  	  During system reset, there is insufficient time for handshake between ICH and GMCH LVDS logic. As a result, timing from panel backlight enable going low to LVDS data going low (TX) and timing from LVDS data going low to panel VCC enable going low (T3) do not match the programmed values. Panel backlight enable (LBKLT_EN), panel Vcc enable (LVDD_EN) and LVDS data lines go low at the same time.  	 A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception). 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector is left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI; therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes.   13  
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception is generated instead of the expected general-protection fault. 	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, for example CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  14  For the steppings affected, see the Summary Tables of Changes.   
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit-20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit-20 may not be masked. • paging is enabled • a linear address has bit-20 set • the address references a large page • A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system. 	 Operating systems should not allow A20M# to be enabled if the masking of address bit-20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  Value for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes.   15  
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  For the steppings affected, see the Summary Tables of Changes. 
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the value of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  16  For the steppings affected, see the Summary Tables of Changes.   
  Fault on ENTER Instruction May Result in Unexpected Value on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected value (i.e. residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  With TF (Trap Flag) Asserted, FP Instruction That Triggers an Unmasked FP Exception May Take Single Step Trap before Retirement of Instruction  	  If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  	 A Single Step trap is taken when not expected. 	 None. 	  For the steppings affected, see the Summary Tables of Changes.   17  
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (for example NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None. 	  18  For the steppings affected, see the Summary Tables of Changes.   
  BTS(Branch Trace Store) and PEBS(Precise Event Based Sampling) May Update Memory outside the BTS/PEBS Buffer  	  If the BTS/PEBS buffer is defined such that: • The difference between BTS/PEBS buffer base and BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes • BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space • The record that would cross BTS/PEBS absolute maximum will also continue past the end of the virtual address space A BTS/PEBS record can be written that will wrap at the 4G boundary (IA32) or 264 boundary (EM64T mode), and write memory outside of the BTS/PEBS buffer. 64  	 Software that uses BTS/PEBS near the 4G boundary (IA32) or 2 boundary (EM64T mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the BTS/PEBS buffer. 	 Define BTS/PEBS buffer such that BTS/PEBS absolute maximum minus BTS/PEBS buffer base is integer multiple of the corresponding record sizes as recommended in the IA-32 Intel® Architecture Software Developer’s Manual, Volume 3. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB is incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	 None. 	  For the steppings affected, see the Summary Tables of Changes.   19  
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel Architecture Software Developer's Manual Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel Architecture Software Developer's Manual Volume 3A: System Programming Guide, Section: Handling Self- and Cross-Modifying Code. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1”. 	  20  For the steppings affected, see the Summary Tables of Changes.   
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: • A SMI that is pending while a lower priority event is executing • A REP I/O read • A I/O read that redirects to MWAIT  	 SMM handlers may get false IO_SMI indication. 	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software. 	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  For the steppings affected, see the Summary Tables of Changes. 
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May be Incorrect  	  When an L2 Cache error occurs (Error code 0x010A or 0x110A reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors. 	 None. 	  For the steppings affected, see the Summary Tables of Changes.   21  
  Performance Monitoring Event for Outstanding Bus Requests Ignores AnyThread Bit  	  The Performance Monitoring Event of Outstanding Bus Requests will ignore the AnyThread bit (IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) and will instead always count all transactions across all logical processors, even when AnyThread is clear.  	 The performance monitor count may be incorrect when counting only the current logical processor’s outstanding bus requests on a processor supporting HyperThreading Technology. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL_MSR (38DH) bit[2] for IA32_FIXED_CTR0, bit[6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring>0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core. 	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.   
  PMI Request is Not Generated on a Counter Overflow if its OVF Bit is Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh) then future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	 If software does not clear the OVF bit corresponding to a performance counter then future counter overflows may not cause PMI requests. 	 Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Use an Incorrect Translation if the TLBs Contain Two Different Translations For a Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4-KByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	 Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE. 	 Software can avoid this problem by ensuring that the TLBs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS Record not Updated When in Probe Mode  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflows of the counter can result in storage of a PEBS record in the PEBS buffer. Due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new PEBS record may not be added to the PEBS buffer.  	 Due to this erratum, the PEBS buffer may not be updated by overflows that occur during probe mode. 	 None. 	  For the steppings affected, see the Summary Tables of Changes.   23  
  LBR/BTM/BTS Information Immediately After a Transition From Legacy/Compatibility Mode to 64-bit Mode May be Incorrect  	  If a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any FROM address recorded by LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) on that second event may incorrectly report the upper 32-bits as zero.  	 Due to this erratum, bits 63:32 of the ‘FROM’ value for LBR/BTM/BTS may be improperly zeroed after a transition to 64 bite mode when the RIP (Instruction Pointer Register) is greater than 4 Gigabyte. 	 None identified. This erratum may be detected by a ‘FROM’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘TO’ address recorded. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.   
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LINT0 Assertion and De-assertion During an Inactive State May Cause Unexpected Operation When APIC is Disabled  	  An interrupt delivered via LINT0 pins when the APIC is hardware disabled (IA32_APIC_BASE MSR (1BH) bit [11] is cleared) will usually keep the pin asserted until after the interrupt is acknowledged. However, if LINT0 is asserted and then deasserted before the interrupt is acknowledged and both of the following are true: • The APIC is hardware disabled (IA32_APIC_BASE MSR bit [11] is clear) and • The processor is in an inactive state that was requested by MWAIT, I/O redirection, VM-entry or RSM, then the processor may operate incorrectly  	 Due to this erratum, the processor may run unexpected code and/or generate an unexpected exception. Intel has not observed this erratum with any commercially available software. 	 If LINT0 is used, it is recommended to either leave the APIC enabled (IA32_APIC_BASE MSR bit [11] set to 1) or do not use MWAIT, I/O redirection, VMentry or RSM to enter an inactive state. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	 Software should not generate misaligned stack frames for use with IRET.   25   	  For the steppings affected, see the Summary Tables of Changes. 
  HSYNC/VSYNC Buffer Does Not Meet VESA Rise & Undershoot Specification  	  Both HSYNC (horizontal Sync) and VSYNC (vertical sync) signals are violating VESA (Video Electronics Standards Association) specification due to non-monotonic slow rise time on both signals.  	 HSYNC and VSYNC signals may not meet VESA specification. 	 Insert a buffer in the HSYNC/VSYNC signal path before the video connector. Refer to Platform Design Guide and Customer Reference Board (CRB) schematic for reference. 	  For the steppings affected, see the Summary Tables of Changes. 
  Glitch on LVDS Display Interface Clocks and Data Lines May be Observed during Power-Up Sequences  	  During power up sequence (transition to S0 state from G3, S3, S4 or S5 states) when LVDS (Low Voltage Differential Signal) power supply (1.8V source) ramps up, a glitch on LVDS clocks (LVD_A_CLKP, LVD_A_CLKN) and data lines (LVD_A_DAPAP[2:0], LVD_A_DATAN[2:0]) may be observed.  	 Due to this erratum, a glitch may be seen during power up sequence. The glitch is not seen once the LVDS power supply is stable. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction Returns Incorrect Brand String  	  When the CPUID instructions is executed with EAX = 80000002H, 80000003H and 80000004H, the returned brand string may be incorrect. The model number in the brand string may be prefixed with a “K” instead of the expected “D”.  	 When this erratum occurs, the processor will report an incorrect model number in the brand string. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  IA32_MC2_STATUS [OVERFLOW] Bit is Not Set When Single-Bit Correctable ECC Error Occurs  	  The OVERFLOW bit should be set if the VAL bit (IA32_MC2_STATUS (409H) bit [63]) is set when a new error occurs. Due to this erratum, the OVERFLOW bit (IA32_MC2_STATUS (409H) bit [62]) is only set when a prior uncorrected error (as indicated by the UC bit (IA32_MC2_STATUS (409H) bit [61])) is present at the time the second error occurs.  	 Any L2 correctable error will not set the IA32_MC2_STATUS.OVERFLOW bit when overwriting a prior L2 correctable error. 	 The frequency of occurrence of this problem is reduced greatly if an operating system regularly polls and clears the machine check banks as this reduces the likelihood of an overflow condition. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writes to Set IA32_MCG_STATUS.MCIP Will Fail  	  An MSR write that attempts to set the IA32_MCG_STATUS MSR (17AH) MCIP (machine check in progress) bit [2] will fail (e.g. #GP fault on WRMSR) instead of setting the bit. An MSR write that specifies 0 for the MCIP bit will function correctly.  	 Due to this erratum, software writes to set this bit will not succeed and may cause an unexpected General Protection fault. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   27  
  Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work  	  Under a precise set of conditions, a processor waking from a C-state due to a pending external interrupt may not complete the exiting process and the system may hang.  	 Due to this erratum, the system may hang. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  High Temperature Circuit Marginality Issue May Cause the System to Hang or Auto Reboot  	  A subset of processors may experience circuit marginality issues when operating at high temperature. Due to this erratum a system hang may occur or the processor may proceed to reboot.  	 Due to this erratum, the system may hang or auto reboot. 	 A BIOS workaround has been identified. Please refer to memory reference code version 1.12 or later. 	  28  For the steppings affected, see the Summary Tables of Changes.   
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	 If the FP Data Operand Pointer is used in an operating system which may run 16-bit FP code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  Executing LTR in 64-bit Mode May Access Segment Descriptor Before Checking for Null Selector  	  When executing the LTR instruction with a null segment selector, #GP(0) should be delivered without accessing the memory in the GDT (Global Descriptor Table). Due to this erratum, such an execution of the LTR instruction in 64-bit mode may access that memory. Side effects of this memory access (e.g. a page fault or EPT violation) that occur may prevent the #GP(0) from being delivered.  	 Executing the LTR instruction with a null segment selector may incorrectly access the GDT. Intel has not observed this erratum with any commercially available system. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes 
  tREFI Exceeds DDR2 / DDR3 Specifications  	  tREFI (Average DRAM Refresh Interval) is 7.825us which exceeds the 7.8us stated in the DDR2/DDR3 specification. Due to this erratum, the processor will take more time to refresh rows. (example: 64.1ms instead of 64.0ms to issue 8192 refreshes)  	 tREFI specification is exceeded. Intel has not observed any other issues with DRAM refresh due to this erratum. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29  
  Complex Conditions Associated With Instruction Page Remapping or Self/Cross-Modifying Code Execution May Lead to Unpredictable System Behavior  	  Under a complex set of internal conditions, instruction page remapping, or self/cross modifying code events may lead to unpredictable system behavior.  	 Due to this Erratum, unpredictable system behavior may be observed. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing With Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under the conditions described in the Software Developers Manual section “Fast String Operation,” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum, fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary, the following may occur, dependent on the new page memory type: • UC: The data size of each read and write may be different than the original data size. • WP: The data size of each read and write may be different than the original data size and there may be a memory ordering violation. • WT: There may be a memory ordering violation. 	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Paging Structure Entry May be Used Before Accessed And Dirty Flags Are Updated  	  If software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a TLB (or an entry in a paging structure cache) and then update the entry’s new value to set the accessed flag or dirty flag. This will occur only if both the old and new values of the entry result in valid translations.  	 Incorrect behavior may occur with algorithms that atomically check that the accessed flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation.	NA	NA
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Table of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  14  For the steppings affected, see the Summary Table of Changes.    
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	  The values of the LER MSRs may be unreliable.  	 None Identified. 	  For the steppings affected, see the Summary Table of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Table of Changes. 
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	  An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   15 
  FREEZE_WHILE_SMM Does Not Prevent Event From Pending PEBS During SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if 1. A performance counter overflowed before an SMI 2. A PEBS record has not yet been generated because another count of the event has not occurred 3. The monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM.  	  A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  16  For the steppings affected, see the Summary Table of Changes.    
  Performance Monitor Precise Instruction Retired Event May Present Wrong Indications  	  When the PDIR (Precise Distribution for Instructions Retired) mechanism is activated (INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1 programmed in PEBS mode), the processor may return wrong PEBS/PMI interrupts and/or incorrect counter values if the counter is reset with a SAV below 100 (Sample-After-Value is the counter reset value software programs in MSR IA32_PMC1[47:0] in order to control interrupt frequency).  	  Due to this erratum, when using low SAV values, the program may get incorrect PEBS or PMI interrupts and/or an invalid counter state.  	 The sampling driver should avoid using SAV<100. 	  For the steppings affected, see the Summary Table of Changes. 
  CR0.CD Is Ignored in VMX Operation  	  If CR0.CD=1, the MTRRs and PAT should be ignored and the UC memory type should be used for all memory accesses. Due to this erratum, a logical processor in VMX operation will operate as if CR0.CD=0 even if that bit is set to 1.  	  Algorithms that rely on cache disabling may not function properly in VMX operation.  	 Algorithms that rely on cache disabling should not be executed in VMX root operation. 	  For the steppings affected, see the Summary Table of Changes. 
  Instruction Fetch May Cause Machine Check if Page Size and Memory Type Was Changed Without Invalidation  	  This erratum may cause a machine-check error (IA32_MCi_STATUS.MCACOD=0150H) on the fetch of an instruction that crosses a 4-KByte address boundary. It applies only if (1) the 4-KByte linear region on which the instruction begins is originally translated using a 4-KByte page with the WB memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-MByte, 4-MByte, or 1GByte) with the UC memory type; and (3) the instruction fetch occurs after the pagingstructure modification but before software invalidates any TLB entries for the linear region.  	  Due to this erratum an unexpected machine check with error code 0150H may occur, possibly resulting in a shutdown. Intel has not observed this erratum with any commercially available software.  	 Software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. It can instead use the following algorithm: first clear the P flag in the relevant paging-structure entry (e.g., PDE); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the P flag and establish the new page size and memory type. 	  For the steppings affected, see the Summary Table of Changes.   17 
  Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for VEX.vvvv May Produce a #NM Exception  	  The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (InvalidOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to this erratum, if CR0.TS is “1”, the processor may instead produce a #NM (Device-NotAvailable) exception.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should always set the vvvv field of the VEX prefix to 1111b for instances of the VAESIMC and VAESKEYGENASSIST instructions. 	  For the steppings affected, see the Summary Table of Changes. 
  Processor May Fail to Acknowledge a TLP Request  	  When a PCIe root port’s receiver is in Receiver L0s power state and the port initiates a Recovery event, it will issue Training Sets to the link partner. The link partner will respond by initiating an L0s exit sequence. Prior to transmitting its own Training Sets, the link partner may transmit a TLP (Transaction Layer Packet) request. Due to this erratum, the root port may not acknowledge the TLP request.  	  After completing the Recovery event, the PCIe link partner will replay the TLP request. The link partner may set a Correctable Error status bit, which has no functional effect.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Interrupt From Local APIC Timer May Not Be Detectable While Being Delivered  	  If the local-APIC timer’s CCR (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the LVT timer register and then reading the bit in the IRR (interrupt-request register) corresponding to the vector in the LVT timer register. If both values are read as 0, no timer interrupt should be in the process of being delivered. Due to this erratum, a timer interrupt may be delivered even if the CCR is 0 and the LVT and IRR bits are read as 0. This can occur only if the DCR (Divide Configuration Register) is greater than or equal to 4. The erratum does not occur if software writes zero to the Initial Count Register before reading the LVT and IRR bits.  	  Software that relies on reads of the LVT and IRR bits to determine whether a timer interrupt is being delivered may not operate properly.  	 Software that uses the local-APIC timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading CCR and the LVT and IRR bits; alternatively, software can avoid the problem by writing zero to the Initial Count Register before reading the LVT and IRR bits. 	  18  For the steppings affected, see the Summary Table of Changes.    
  PCIe* Root-port Initiated Compliance State Transmitter Equalization Settings May be Incorrect  	  If the processor is directed to enter PCIe Polling.Compliance at 5.0 GT/s or 8.0 GT/s transfer rates, it should use the Link Control 2 Compliance Preset/De-emphasis field (bits [15:12]) to determine the correct de-emphasis level. Due to this erratum, when the processor is directed to enter Polling.Compliance from 2.5 GT/s transfer rate, it retains 2.5 GT/s de-emphasis values.  	  The processor may operate in Polling.Compliance mode with an incorrect transmitter de-emphasis level.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  PCIe* Controller May Incorrectly Log Errors on Transition to RxL0s  	  Due to this erratum, if a link partner transitions to RxL0s state within 20 ns of entering L0 state, the PCIe controller may incorrectly log an error in “Correctable Error Status.Receiver Error Status” field (Bus 0, Device 2, Function 0, 1, 2 and Device 6, Function 0, offset 1D0H, bit 0).  	  Correctable receiver errors may be incorrectly logged. Intel has not observed any functional impact due to this erratum with any commercially available add-in cards.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Unused PCIe* Lanes May Report Correctable Errors  	  Due to this erratum, during PCIe* link down configuration, unused lanes may report a Correctable Error Detected in Bus 0, Device 1, Function 0-2, and Device 6, Function 0, Offset 158H, Bit 0.  	  Correctable Errors may be reported by a PCIe controller for unused lanes.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Accessing Physical Memory Space 0-640K through the Graphics Aperture May Cause Unpredictable System Behavior  	  The physical memory space 0-640K when accessed through the graphics aperture may result in a failure for writes to complete or reads to return incorrect results.  	  A hang or functional failure may occur during graphics operation such as OGL or OCL conformance tests, 2D/3D games and graphics intensive application.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.   19 
  PCIe Root Port May Not Initiate Link Speed Change  	  The PCIe Base specification requires the upstream component to maintain the PCIe link at the target link speed or the highest speed supported by both components on the link, whichever is lower. PCIe root port will not initiate the link speed change without being triggered by the software when the root port maximum link speed is configured to be 5.0 GT/s. System BIOS will trigger the link speed change under normal boot scenarios. However, BIOS is not involved in some scenarios such as link disable/re-enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. This erratum does not affect the ability of the downstream component to initiate a link speed change. All known 5.0Gb/s-capable PCIe downstream components have been observed to initiate the link speed change without relying on the root port to do so.  	  Due to this erratum, the PCIe root port may not initiate a link speed change during some hardware scenarios causing the PCIe link to operate at a lower than expected speed. Intel has not observed this erratum with any commercially available platform.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	  Software may observe #MF being signaled before pending interrupts are serviced.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  DR6.B0-B3 May Not Report All Breakpoints Matched When a MOV/POP SS is Followed by a Store or an MMX Instruction  	  Normally, data breakpoints matches that occur on a MOV SS, r/m or POP SS will not cause a debug exception immediately after MOV/POP SS but will be delayed until the instruction boundary following the next instruction is reached. After the debug exception occurs, DR6.B0-B3 bits will contain information about data breakpoints matched during the MOV/POP SS as well as breakpoints detected by the following instruction. Due to this erratum, DR6.B0-B3 bits may not contain information about data breakpoints matched during the MOV/POP SS when the following instruction is either an MMX instruction that uses a memory addressing mode with an index or a store instruction.  	  When this erratum occurs, DR6 may not contain information about all breakpoints matched. This erratum will not be observed under the recommended usage of the MOV SS,r/m or POP SS instructions (i.e., following them only with an instruction that writes (E/R)SP).  	 None identified. 	  20  For the steppings affected, see the Summary Table of Changes.    
  VEX.L is Not Ignored with VCVT*2SI Instructions  	  The VEX.L bit should be ignored for the VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions, however due to this erratum the VEX.L bit is not ignored and will cause a #UD.  	  Unexpected #UDs will be seen when the VEX.L bit is set to 1 with VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions.  	 Software should ensure that the VEX.L bit is set to 0 for all scalar instructions. 	  For the steppings affected, see the Summary Table of Changes. 
  Processor May Shut Down During Boundary Scan Testing  	  If the HIGHZ TAP command is run before initializing the Boundary Scan chain, the VR_EN pin may be tristated. The VR_EN pin may also be tristated by the EXTEST TAP command. The VR_EN signal controls the external voltage regulator; tristating VR_EN may disable the voltage regulator.  	  Due to this erratum, the processor may shut down.  	 Initialize the Boundary Scan chain by running the PRELOAD TAP command before running HIGHZ TAP command or EXTEST TAP command. 	  For the steppings affected, see the Summary Table of Changes. 
  Certain Local Memory Read / Load Retired PerfMon Events May Undercount  	  Due to this erratum, the Local Memory Read / Load Retired PerfMon events listed below may undercount. MEM_LOAD_RETIRED.L3_HIT MEM_LOAD_RETIRED.L3_MISS MEM_LOAD_L3_HIT_RETIRED.XSNP_MISS MEM_LOAD_L3_HIT_RETIRED.XSNP_HIT MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM MEM_LOAD_L3_HIT_RETIRED.XSNP_NONE MEM_LOAD_L3_MISS_RETIRED.LOCAL_DRAM MEM_LOAD_L4_RETIRED.LOCAL_HIT MEM_TRANS_RETIRED.LOAD_LATENCY  	  The affected events may undercount, resulting in inaccurate memory profiles. Intel has observed undercounts as much as 40%..  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Specific Graphics Blitter Instructions May Result in Unpredictable Graphics Controller Behavior  	  Specific source-copy blitter instructions in Intel® HD Graphics 4600 Processor may result in unpredictable behavior when a blit source and destination overlap.  	  Due to this erratum, the processor may exhibit unpredictable graphics controller behavior. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   21 
  Processor May Enter Shutdown Unexpectedly on a Second Uncorrectable Error  	  If an IA32_MCi_STATUS MSR contains an uncorrectable error with MCACOD=0x406 and a second uncorrectable error occurs after warm reset but before the first error is cleared by zeroing the IA32_MCi_STATUS MSR, a shutdown will occur.  	  When this erratum occurs, the processor will unexpectedly shut down instead of executing the machine check handler.  	 None identified. Software should clear IA32_MCi_STATUS MSRs as early as possible to minimize the possibility of this erratum occurring. 	  For the steppings affected, see the Summary Table of Changes. 
  Modified Compliance Patterns for 2.5 GT/s and 5 GT/s Transfer Rates Do Not Follow PCIe* Specification  	  The PCIe controller does not produce the PCIe specification defined sequence for the Modified Compliance Pattern at 2.5 GT/s and 5 GT/s transfer rates. This erratum is not seen at 8 GT/s transfer rates.  	  Normal PCIe operation is unaffected by this erratum.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor Counters May Produce Incorrect Results  	  When operating in hyper-threaded mode, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled counter on the physical core’s other thread rather than the thread experiencing the event. The list of affected memory at-retirement events is as follows: MEM_UOP_RETIRED.LOADS MEM_UOP_RETIRED.STORES MEM_UOP_RETIRED.LOCK MEM_UOP_RETIRED.SPLIT MEM_UOP_RETIRED.STLB_MISS MEM_LOAD_UOPS_RETIRED.HIT_LFB MEM_LOAD_UOPS_RETIRED.L1_HIT MEM_LOAD_UOPS_RETIRED.L2_HIT MEM_LOAD_UOPS_RETIRED.LLC_HIT MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HIT MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HITM MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_MISS MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_NONE MEM_LOAD_UOPS_RETIRED.LLC_MISS MEM_LOAD_UOPS_LLC_MISS_RETIRED.LOCAL_DRAM MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_DRAM MEM_LOAD_UOPS_RETIRED.L2_MISS  	  Due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.  	 None identified.  22     	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor UOPS_EXECUTED Event May Undercount  	  The performance monitor event UOPS_EXECUTED (Event B1H, any Unmask) should count the number of UOPs executed each cycle. However due to this erratum, when eight UOPs execute in one cycle, these UOPs will not be counted.  	  The performance monitor event UOPS_EXECUTED may reflect a count lower than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  MSR_PERF_STATUS May Report an Incorrect Core Voltage  	  The core operating voltage can be determined by dividing MSR_PERF_STATUS MSR (198H) bits [47:32] by 2^13. However, due to this erratum, this calculation may report half the actual core voltage.  	  The core operating voltage may be reported incorrectly.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  PCIe* Atomic Transactions From Two or More PCIe Controllers May Cause Starvation  	  On a Processor PCIe controller configuration in which two or more controllers receive concurrent atomic transactions, a PCIe controller may experience starvation which eventually can lead to a completion timeout.  	  Atomic transactions from two or more PCIe controllers may lead to a completion timeout. Atomic transactions from only one controller will not be affected by this erratum. Intel has not observed this erratum with any commercially available device.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	  The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   23 
  An AVX Gather Instruction That Causes an EPT Violation May Not Update Previous Elements  	  When execution of an AVX gather instruction causes an EPT (extended page table) violation due to a specific element, all previous elements should be complete. Due to this erratum, such an execution may fail to complete previous elements. In addition, the instruction's mask operand is not updated. This erratum applies only if the EPT violation occurs while updating an accessed or dirty flag in a paging-structure entry. Instructions impacted by this erratum are: VGATHERDPS, VGATHERDPD, VGATHERQPS, VGATHERQPD, VPGATHERDD, VPGATHERDQ, VPGATHERQD, and VPGATHERQQ.  	  This erratum may prevent a gather instruction from making forward progress.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  PLATFORM_POWER_LIMIT MSR Not Visible  	  The PLATFORM_POWER_LIMIT MSR (615H) is used to control the PL3 (power limit 3) mechanism of the processor. Due to this erratum, this MSR is not visible to software.  	  Software is unable to read or write the PLATFORM_POWER_LIMIT MSR. If software attempts to access this MSR, a general protection fault will occur.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  LPDDR Memory May Report Incorrect Temperature  	  When any of the four possible LPDDR ranks are not populated, the unpopulated ranks will report a default temperature of 85C as a three bit value of 011b. If the system has unpopulated ranks the temperature of memory will be reported as 85C in PCU_CR_DDR_DIMM_HOTTEST_ABSOLUTE (MCHBAR Bus 0; Device 0; Function 0; offset 58B8H) in bits [5:7], until any of the populated ranks report a higher temperature than this.  	  When the memory temperature is less than or equal to 85C it may be reported as 85C. This erratum does not affect DDR3 and DDR3L memory types.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  PCIe* Host Bridge DID May Be Incorrect  	  The PCIe Host Bridge DID register (Bus 0; Device 0; Offset 2H) contents may be incorrect after a Package C7 exit.  	  Software that depends on the Host Bridge DID value may not behave as expected after a Package C7 exit.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  24  For the steppings affected, see the Summary Table of Changes.    
  TSC May be Incorrect After a Deep C-State Exit  	  On exiting from Package C6 or deeper, the processor may incorrectly restore the TSC (Time Stamp Counter).  	  Software using the TSC may produce incorrect result and/or may not behave as expected.  	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  PCIe* Controller May Initiate Speed Change While in DL_Init State Causing Certain PCIe Devices to Fail to Train  	  The PCIe controller supports hardware autonomous speed change capabilities. Due to this erratum, the PCIe controller may initiate speed change while in the DL_Init state which may prevent link training for certain PCIe devices.  	  Certain PCIe devices may fail to complete DL_Init causing the PCIe link to fail to train.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Spurious VT-d Interrupts May Occur When the PFO Bit is Set  	  When the PFO (Primary Fault Overflow) field (bit [0] in the VT-d FSTS [Fault Status] register) is set to 1, further faults should not generate an interrupt. Due to this erratum, further interrupts may still occur.  	  Unexpected Invalidation Queue Error interrupts may occur. Intel has not observed this erratum with any commercially available software.  	 Software should be written to handle spurious VT-d fault interrupts. 	  For the steppings affected, see the Summary Table of Changes. 
  Turbo Ratio Limits Cannot be Lowered  	  When ratio overclocking is enabled, customers can write to the MSR_TURBO_RATIO_LIMIT MSR (1ADH) to raise the core turbo ratio limits (per number of active cores) above the factory configured values. Due to this erratum, after raising turbo ratio limits, they cannot be lowered without a platform reset.  	  Any attempt to lower the turbo ratio limits will be ignored.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  AVX Gather Instruction That Causes a Fault or VM Exit May Incorrectly Modify Its Destination Register  	  An execution of a 128-bit AVX gather instruction zeroes the upper 128 bits of the instruction's destination register unless access to the first unmasked element causes a fault or VM exit. Due to this erratum, these bits may be cleared even when accessing the first unmasked element causes a fault or VM exit. Instructions impacted by this erratum are: VGATHERDPS, VGATHERDPD, VGATHERQPS, VGATHERQPD, VPGATHERDD, VPGATHERDQ, VPGATHERQD, and VPGATHERQQ.  	  Software that depends on the destination register of a 128-bit AVX gather instruction to remain unchanged after access of the first unmasked element results in fault or VM exit may not behave as expected.  	 It is possible for the BIOS to contain a workaround for this erratum.   25  	  For the steppings affected, see the Summary Table of Changes. 
  Inconsistent NaN Propagation May Occur When Executing (V)DPPS Instruction  	  Upon completion of the (V)DPPS instruction with multiple different NaN encodings in the input elements, software may observe different NaN encodings in the destination elements.  	  Inconsistent NaN encodings in the destination elements for the (V) DPPS instruction may be observed.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Display May Flicker When Package C-States Are Enabled  	  When package C-States are enabled, the display may not be refreshed at the correct rate.  	  When this erratum occurs, the user may observe flickering on the display.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Certain Combinations of AVX Instructions May Cause Unpredictable System Behavior  	  Execution of certain combinations of AVX instructions may lead to unpredictable system behavior.  	  When this erratum occurs, unpredictable system behaviors, including system hang or incorrect results can occur.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Processor May Incorrectly Estimate Peak Power Delivery Requirements  	  Under certain conditions, the processor may incorrectly calculate the frequency at which the cores and graphics engine can operate while still meeting voltage regulator and power supply peak power delivery capabilities. When this occurs, combined with high power workloads, system shutdown may be observed.  	  When this erratum occurs, system shutdown may be observed under high power workloads.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  IA32_PERF_CTL MSR is Incorrectly Reset  	  The IA32_PERF_CTL MSR (199H) is not initialized correctly after a processor reset.  	  If software reads the IA32_PERF_CTL MSR before writing it, software can observe an incorrect reset value. Although incorrect values are reported to software, the correct default values for this register are still used by the processor. No performance or power impact occurs due to this erratum.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  26  For the steppings affected, see the Summary Table of Changes.    
  Processor May Hang During a Function Level Reset of the Display  	  When package C-States are enabled, it is possible that the processor may hang when software performs a Function Level Reset of the display via bit 1 of the Advanced Features Control Register (Bus 0; Device 2; Function 0; Offset 0A8H).  	  When this erratum occurs, the processor may hang.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  AVX Gather Instruction That Should Result in #DF May Cause Unexpected System Behavior  	  Due to this erratum, an execution of a 128-bit AVX gather instruction may fail to generate a #DF (double fault) when expected. Instructions impacted by this erratum are: VGATHERDPS, VGATHERDPD, VGATHERQPS, VGATHERQPD, VPGATHERDD, VPGATHERDQ, VPGATHERQD, and VPGATHERQQ.  	  When this erratum occurs, an operation which should cause a #DF may result in unexpected system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Throttling and Refresh Rate Maybe be Incorrect After Exiting Package C-State  	  When the OLTM (Open Loop Thermal Management) feature is enabled, the DIMM thermal status reported in DDR_THERM_PERDIMM_STATUS (MCHBAR Offset 588CH) may be incorrect following an exit from Package C3 or deeper.  	  The incorrect DIMM thermal status may result in degraded performance from unneeded memory throttling and excessive DIMM refresh rates.  	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Processor May Livelock During On Demand Clock Modulation  	  The processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the IA32_CLOCK_MODULATION MSR (19AH) and the clock modulation duty cycle is set to 12.5 % (02H in bits 3:0 of the same MSR), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access UC memory.  	  Program execution may stall on both threads of the core subject to this erratum.  	 This erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the IA32_CLOCK_MODULATION MSR is 18.75% or higher. 	  For the steppings affected, see the Summary Table of Changes.   27 
  IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI is Incorrectly Cleared by SMI  	  FREEZE_PERFMON_ON_PMI (bit 12) in the IA32_DEBUGCTL MSR (1D9H) is erroneously cleared during delivery of an SMI (system-management interrupt).  	  As a result of this erratum, the performance monitoring counters will continue to count after a PMI occurs in SMM (system-management Mode).  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  The From-IP for Branch Tracing May be Incorrect  	  BTM (Branch Trace Message) and BTS (Branch Trace Store) report the “From-IP” indicating the source address of the branch instruction. Due to this erratum, BTM and BTS may repeat the “From-IP” value previously reported. The “To-IP” value is not affected.  	  Using BTM or BTS reports to reconstruct program execution may be unreliable.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  TM1 Throttling May Continue indefinitely  	  TM1 (Thermal Monitor 1) throttling may continue when the processor’s temperature decreases below the throttling point while the processor is in Package C3 or deeper.  	  The processor will continue thermal throttling but does not indicate it is hot.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Internal Parity Errors May Incorrectly Report Overflow in The IA32_MCi_STATUS MSR  	  Due to this erratum, uncorrectable internal parity error reports with an IA32_MCi_STATUS.MCACOD (bits [15:0]) value of 0005H and an IA32_MCi_STATUS.MSCOD (bits [31:16]) value of 0004H may incorrectly set the IA32_MCi_STATUS.OVER flag (bit 62) indicating an overflow even when only a single error has been observed.  	  IA32_MCi_STATUS.OVER may not accurately indicate multiple occurrences of uncorrectable internal parity errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor Events OTHER_ASSISTS.AVX_TO_SSE And OTHER_ASSISTS.SSE_TO_AVX May Over Count  	  The Performance Monitor events OTHER_ASSISTS.AVX_TO_SSE (Event C1H; Umask 08H) and OTHER_ASSISTS.SSE_TO_AVX (Event C1H; Umask 10H) incorrectly increment and over count when an HLE (Hardware Lock Elision) abort occurs.  	  The Performance Monitor Events OTHER_ASSISTS.AVX_TO_SSE And OTHER_ASSISTS.SSE_TO_AVX may over count.  	 None identified. 	  28  For the steppings affected, see the Summary Table of Changes.    
  Processor May Run at Incorrect P-State  	  The processor package may use stale software P-State (performance state) requests when one or more logical processors are idle.  	  The processor package may run at a higher or lower than expected P-State. This issue may persist as long as any logical processor is idle.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor Event DSB2MITE_SWITCHES.COUNT May Over Count  	  The Performance Monitor Event DSB2MITE_SWITCHES.COUNT (Event ABH; Umask 01H) should count the number of DSB (Decode Stream Buffer) to MITE (Macro Instruction Translation Engine) switches. Due to this erratum, the DSB2MITE_SWITCHES.COUNT event will count speculative switches and cause the count to be higher than expected.  	  The Performance Monitor Event DSB2MITE_SWITCHES.COUNT may report count higher than expected.  	 None identified.	NA
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit-23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	 BIOS must leave the xTPR update transactions disabled (default). 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Report a #TS Instead of a #GP Fault  	  During system reset, there is insufficient time for handshake between ICH and GMCH LVDS logic. As a result, timing from panel backlight enable going low to LVDS data going low (TX) and timing from LVDS data going low to panel VCC enable going low (T3) do not match the programmed values. Panel backlight enable (LBKLT_EN), panel Vcc enable (LVDD_EN) and LVDS data lines go low at the same time.  	 A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception). 	 None. 	  14  For the steppings affected, see the Summary Tables of Changes.   
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector is left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI; therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception is generated instead of the expected general-protection fault. 	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes.   15  
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, for example CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit-20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit-20 may not be masked. • paging is enabled • a linear address has bit-20 set • the address references a large page • A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system. 	 Operating systems should not allow A20M# to be enabled if the masking of address bit-20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  16  For the steppings affected, see the Summary Tables of Changes.   
  Value for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. 	 None. 	  For the steppings affected, see the Summary Tables of Changes.   17  
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  For the steppings affected, see the Summary Tables of Changes. 
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the value of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Value on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected value (i.e. residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software. 	 None. 	  18  For the steppings affected, see the Summary Tables of Changes.   
  With TF (Trap Flag) Asserted, FP Instruction That Triggers an Unmasked FP Exception May Take Single Step Trap before Retirement of Instruction  	  If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  	 A Single Step trap is taken when not expected. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   19  
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (for example NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  BTS(Branch Trace Store) and PEBS(Precise Event Based Sampling) May Update Memory outside the BTS/PEBS Buffer  	  If the BTS/PEBS buffer is defined such that: • The difference between BTS/PEBS buffer base and BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes • BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space • The record that would cross BTS/PEBS absolute maximum will also continue past the end of the virtual address space A BTS/PEBS record can be written that will wrap at the 4G boundary (IA32) or 264 boundary (EM64T mode), and write memory outside of the BTS/PEBS buffer. 64  	 Software that uses BTS/PEBS near the 4G boundary (IA32) or 2 boundary (EM64T mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the BTS/PEBS buffer. 	 Define BTS/PEBS buffer such that BTS/PEBS absolute maximum minus BTS/PEBS buffer base is integer multiple of the corresponding record sizes as recommended in the IA-32 Intel® Architecture Software Developer’s Manual, Volume 3. 	  20  For the steppings affected, see the Summary Tables of Changes.   
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB is incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel Architecture Software Developer's Manual Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel Architecture Software Developer's Manual Volume 3A: System Programming Guide, Section: Handling Self- and Cross-Modifying Code. 	  For the steppings affected, see the Summary Tables of Changes.   21  
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1”. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: • A SMI that is pending while a lower priority event is executing • A REP I/O read • A I/O read that redirects to MWAIT  	 SMM handlers may get false IO_SMI indication. 	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software. 	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  22  For the steppings affected, see the Summary Tables of Changes.   
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May be Incorrect  	  When an L2 Cache error occurs (Error code 0x010A or 0x110A reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event for Outstanding Bus Requests Ignores AnyThread Bit  	  The Performance Monitoring Event of Outstanding Bus Requests will ignore the AnyThread bit (IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) and will instead always count all transactions across all logical processors, even when AnyThread is clear.  	 The performance monitor count may be incorrect when counting only the current logical processor’s outstanding bus requests on a processor supporting HyperThreading Technology. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23  
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL_MSR (38DH) bit[2] for IA32_FIXED_CTR0, bit[6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring>0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMI Request is Not Generated on a Counter Overflow if its OVF Bit is Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh) then future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	 If software does not clear the OVF bit corresponding to a performance counter then future counter overflows may not cause PMI requests. 	 Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Use an Incorrect Translation if the TLBs Contain Two Different Translations For a Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4-KByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	 Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE. 	 Software can avoid this problem by ensuring that the TLBs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type. 	  24  For the steppings affected, see the Summary Tables of Changes.   
  PEBS Record not Updated When in Probe Mode  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflows of the counter can result in storage of a PEBS record in the PEBS buffer. Due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new PEBS record may not be added to the PEBS buffer.  	 Due to this erratum, the PEBS buffer may not be updated by overflows that occur during probe mode. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR/BTM/BTS Information Immediately After a Transition From Legacy/Compatibility Mode to 64-bit Mode May be Incorrect  	  If a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any FROM address recorded by LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) on that second event may incorrectly report the upper 32-bits as zero.  	 Due to this erratum, bits 63:32 of the ‘FROM’ value for LBR/BTM/BTS may be improperly zeroed after a transition to 64 bite mode when the RIP (Instruction Pointer Register) is greater than 4 Gigabyte. 	 None identified. This erratum may be detected by a ‘FROM’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘TO’ address recorded. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   25  
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  LINT0 Assertion and De-assertion During an Inactive State May Cause Unexpected Operation When APIC is Disabled  	  An interrupt delivered via LINT0 pins when the APIC is hardware disabled (IA32_APIC_BASE MSR (1BH) bit [11] is cleared) will usually keep the pin asserted until after the interrupt is acknowledged. However, if LINT0 is asserted and then deasserted before the interrupt is acknowledged and both of the following are true: • The APIC is hardware disabled (IA32_APIC_BASE MSR bit [11] is clear) and • The processor is in an inactive state that was requested by MWAIT, I/O redirection, VM-entry or RSM, then the processor may operate incorrectly  	 Due to this erratum, the processor may run unexpected code and/or generate an unexpected exception. Intel has not observed this erratum with any commercially available software. 	 If LINT0 is used, it is recommended to either leave the APIC enabled (IA32_APIC_BASE MSR bit [11] set to 1) or do not use MWAIT, I/O redirection, VMentry or RSM to enter an inactive state. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes.   27  
  HSYNC/VSYNC Buffer Does Not Meet VESA Rise & Undershoot Specification  	  Both HSYNC (horizontal Sync) and VSYNC (vertical sync) signals are violating VESA (Video Electronics Standards Association) specification due to non-monotonic slow rise time on both signals.  	 HSYNC and VSYNC signals may not meet VESA specification. 	 Insert a buffer in the HSYNC/VSYNC signal path before the video connector. Refer to Platform Design Guide and Customer Reference Board (CRB) schematic for reference. 	  For the steppings affected, see the Summary Tables of Changes. 
  Glitch on LVDS Display Interface Clocks and Data Lines May be Observed during Power-Up Sequences  	  During power up sequence (transition to S0 state from G3, S3, S4 or S5 states) when LVDS (Low Voltage Differential Signal) power supply (1.8V source) ramps up, a glitch on LVDS clocks (LVD_A_CLKP, LVD_A_CLKN) and data lines (LVD_A_DAPAP[2:0], LVD_A_DATAN[2:0]) may be observed.  	 Due to this erratum, a glitch may be seen during power up sequence. The glitch is not seen once the LVDS power supply is stable. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. Due to this erratum, IA32_MPERF may not be reset when IA32_APERF overflows. Instead, IA32_MPERF may continue to increment without being reset.  	 Due to this erratum, software cannot rely on synchronous reset of the IA32_MPERF  register. The typical usage of IA32_MPERF/IA32_APERF is to initialize them with a value of 0; in this case the overflow of the counter wouldn’t happen for over 10 years.  	 None identified. 	  28  For the steppings affected, see the Summary Tables of Changes.   
  Writes to Set IA32_MCG_STATUS.MCIP Will Fail  	  An MSR write that attempts to set the IA32_MCG_STATUS MSR (17AH) MCIP (machine check in progress) bit [2] will fail (e.g. #GP fault on WRMSR) instead of setting the bit. An MSR write that specifies 0 for the MCIP bit will function correctly.  	 Due to this erratum, software writes to set this bit will not succeed and may cause an  unexpected General Protection fault.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC2_STATUS [OVERFLOW] Bit is Not Set When Single-Bit Correctable ECC Error Occurs  	  The OVERFLOW bit should be set if the VAL bit (IA32_MC2_STATUS (409H) bit [63]) is set when a new error occurs. Due to this erratum, the OVERFLOW bit (IA32_MC2_STATUS (409H) bit [62]) is only set when a prior uncorrected error (as indicated by the UC bit (IA32_MC2_STATUS (409H) bit [61])) is present at the time the second error occurs.  	 Any L2 correctable error will not set the IA32_MC2_STATUS.OVERFLOW bit when  overwriting a prior L2 correctable error.  	 The frequency of occurrence of this problem is reduced greatly if an operating system  regularly polls and clears the machine check banks as this reduces the likelihood of an overflow condition.  	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit  FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in an operating system which may run 16-bit FP  code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary.  	  For the steppings affected, see the Summary Tables of Changes.   29  
  High Temperature Circuit Marginality Issue May Cause the System to Hang or Auto reboot.  	  A subset of processors may experience circuit marginality issues when operating at high temperature. Due to this erratum a system hang may occur or the processor may proceed to reboot.  	 Due to this erratum, the system may hang or auto reboot. 	 A BIOS workaround has been identified. Please refer to memory reference code version 1.12 or later. 	  For the steppings affected, see the Summary Tables of Changes. 
  Complex Conditions Associated With Instruction Page Remapping or Self/Cross-Modifying Code Execution May Lead to Unpredictable System Behavior  	  Under a complex set of internal conditions, instruction page remapping, or self/cross modifying code events may lead to unpredictable system behavior.  	 Due to this Erratum, unpredictable system behavior may be observed. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing With Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under the conditions described in the Software Developers Manual section “Fast String Operation,” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum, fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary, the following may occur, dependent on the new page memory type: •  UC: The data size of each read and write may be different than the original data size.  •  WP: The data size of each read and write may be different than the original data size and there may be a memory ordering violation.  • WT: There may be a memory ordering violation. 	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	 For the steppings affected, see the Summary Tables of Changes. 
  Paging Structure Entry May be Used Before Accessed And Dirty Flags Are Updated  30    	  If software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a TLB (or an entry in a paging structure cache) and then update the entry’s new value to set the accessed flag or dirty flag. This will occur only if both the old and new values of the entry result in valid translations.  	 Incorrect behavior may occur with algorithms that atomically check that the accessed flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation. 	 Affected algorithms must ensure that appropriate TLB invalidation is done before assuming that future accesses do not use translations based on the old value of the paging structure entry. 	NA
  EFLAGS Discrepancy on Page Faults after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault. This can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	 None identified. Although the EFLAGS value saved may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without a page fault. 	 If the page fault handler inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Operation for Large (2M/4M) Pages May be Incomplete under Certain Conditions  	  The INVLPG instruction may not completely invalidate Translation Look-aside Buffer (TLB) entries for large pages (2M/4M) when both of the following conditions exist: •  Address range of the page being invalidated spans several Memory Type Range Registers (MTRRs) with different memory types specified  •  INVLPG operation is preceded by a Page Assist Event (Page Fault (#PF) or an access that results in either A or D bits being set in a Page Table Entry (PTE))  	 Stale translations may remain valid in TLB after a PTE update resulting in unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 Software should ensure that the memory type specified in the MTRRs is the same for the entire address range of the large page. 	 18  For the steppings affected, see the Summary Tables of Changes. Intel® Core™2 Duo Processor  
  Store to WT Memory Data May be Seen in Wrong Order by Two Subsequent Loads  	  When data of Store to WT memory is used by two subsequent loads of one thread and another thread performs cacheable write to the same address the first load may get the data from external memory or L2 written by another core, while the second load will get the data straight from the WT Store.  	 Software that uses WB to WT memory aliasing may violate proper store ordering. 	 Do not use WB to WT aliasing. 	  For the steppings affected, see the Summary Tables of Changes. 
  Non-Temporal Data Store May be Observed in Wrong Program Order  	  When non-temporal data is accessed by multiple read operations in one thread while another thread performs a cacheable write operation to the same address, the data stored may be observed in wrong program order (i.e. later load operations may read older data).  	 Software that uses non-temporal data without proper serialization before accessing the non-temporal data may observe data in wrong program order. 	 Software that conforms to the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, section “Buffering of Write Combining Memory Locations” will operate correctly. 	  For the steppings affected, see the Summary Tables of Changes. 
  Page Access Bit May be Set Prior to Signaling a Code Segment Limit Fault  	  If code segment limit is set close to the end of a code page, then due to this erratum the memory page Access bit (A bit) may be set for the subsequent page prior to general protection fault on code segment limit.  	 When this erratum occurs, a non-accessed page which is present in memory and follows a page that contains the code segment limit may be tagged as accessed. 	 Erratum can be avoided by placing a guard page (non-present or nonexecutable page) as the last page of the segment or after the page that includes the code segment limit. 	  For the steppings affected, see the Summary Tables of Changes. 
  Updating Code Page Directory Attributes without TLB Invalidation May Result in Improper Handling of Code #PF  	  Code #PF (Page Fault exception) is normally handled in lower priority order relative to both code #DB (Debug Exception) and code Segment Limit  Intel® Core™2 Duo Processor  19   Violation #GP (General Protection Fault). Due to this erratum, code #PF may be handled incorrectly, if all of the following conditions are met: • •  •  A PDE (Page Directory Entry) is modified without invalidating the corresponding TLB (Translation Look-aside Buffer) entry Code execution transitions to a different code page such that both o The target linear address corresponds to the modified PDE o The PTE (Page Table Entry) for the target linear address has an A (Accessed) bit that is clear One of the following simultaneous exception conditions is present following the code transition o Code #DB and code #PF o Code Segment Limit Violation #GP and code #PF  	 Software may observe either incorrect processing of code #PF before code Segment Limit Violation #GP or processing of code #PF in lieu of code #DB. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	 When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	 The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software. 20  Intel® Core™2 Duo Processor   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A REP STOS/MOVS to a MONITOR/MWAIT Address Range May Prevent Triggering of the Monitoring Hardware  	  The MONITOR instruction is used to arm the address monitoring hardware for the subsequent MWAIT instruction. The hardware is triggered on subsequent memory store operations to the monitored address range. Due to this erratum, REP STOS/MOVS fast string operations to the monitored address range may prevent the actual triggering store to be propagated to the monitoring hardware.  	 A logical processor executing an MWAIT instruction may not immediately continue program execution if a REP STOS/MOVS targets the monitored address range. 	 Software can avoid this erratum by not using REP STOS/MOVS store operations within the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event MISALIGN_MEM_REF May Over Count  	  Performance monitoring event MISALIGN_MEM_REF (05H) is used to count the number of memory accesses that cross an 8-byte boundary and are blocked until retirement. Due to this erratum, the performance monitoring event MISALIGN_MEM_REF also counts other memory accesses.  	 The performance monitoring event MISALIGN_MEM_REF may over count. The extent of the over counting depends on the number of memory accesses retiring while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Duo Processor  21  
  Code Segment Limit Violation May Occur on 4 Gigabyte Limit Check  	  Code Segment limit violation may occur on 4 Gigabyte limit check when the code streamwraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.  	 This is a rare condition that may result in a system hang. Intel has not observed this erratum with any commercially available software, or system. 	 Avoid code that wraps around segment limit. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory-based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, e.g. CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Last Branch Records (LBR) Updates May be Incorrect after a Task Switch  	  A Task-State Segment (TSS) task switch may incorrectly set the LBR_FROM value to the LBR_TO value.  	 The LBR_FROM will have the incorrect address of the Branch Instruction. 	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Duo Processor  
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations.  	  Under certain conditions as described in the Software Developers Manual section “Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation. 	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Upper 32 bits of ‘From’ Address Reported through BTMs or BTSs May be Incorrect  	  When a far transfer switches the processor from 32-bit mode to IA-32e mode, the upper 32 bits of the ‘From’ (source) addresses reported through the BTMs (Branch Trace Messages) or BTSs (Branch Trace Stores) may be incorrect.  	 The upper 32 bits of the ‘From’ address debug information reported through BTMs or BTSs may be incorrect during this transition. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Address Reported by Machine-Check Architecture (MCA) on Single-bit L2 ECC Errors May be Incorrect  	  When correctable Single-bit ECC errors occur in the L2 cache, the address is logged in the MCA address register (MCi_ADDR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in MCi_ADDR, for Single-bit L2 ECC errors.  Intel® Core™2 Duo Processor  23   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.)  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Store Ordering May be Incorrect between WC and WP Memory Types  	  According to Intel® 64 and IA-32 Intel Architecture Software Developer's Manual, Volume 3A "Methods of Caching Available", WP (Write Protected) stores should drain the WC (Write Combining) buffers in the same way as UC (Uncacheable) memory type stores do. Due to this erratum, WP stores may not drain the WC buffers.  	 Memory ordering may be violated between WC and WP stores. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EFLAGS, CR0, CR4 and the EXF4 Signal May be Incorrect after Shutdown  	  When the processor is going into shutdown due to an RSM inconsistency failure, EFLAGS, CR0 and CR4 may be incorrect. In addition the EXF4 signal may still be asserted. This may be observed if the processor is taken out of shutdown by NMI#.  	 A processor that has been taken out of shutdown may have an incorrect EFLAGS, CR0 and CR4. In addition the EXF4 signal may still be asserted. 	 None identified. 	 24  For the steppings affected, see the Summary Tables of Changes. Intel® Core™2 Duo Processor  
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. 1) If an instruction that performs a memory load causes a code segment limit violation. 2) If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending. 3) If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Top-of-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	 In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side-effect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception. 	 Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Retired Instructions (C0H) May Not Be Accurate  	  The INST_RETIRED performance monitor may miscount retired instructions as follows: •  Repeat string and repeat I/O operations are not counted when a hardware interrupt is received during or after the last iteration of the repeat flow.  •  VMLAUNCH and VMRESUME instructions are not counted.  •  HLT and MWAIT instructions are not counted. The following instructions, if executed during HLT or MWAIT events, are also not counted: a) RSM from a C-state SMI during an MWAIT instruction.  Intel® Core™2 Duo Processor  25   b) RSM from an SMI during a HLT instruction. 	 There may be a smaller than expected value in the INST_RETIRED performance monitoring counter. The extent to which this value is smaller than expected is determined by the frequency of the above cases. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  For the steppings affected, see the Summary Tables of Changes. 
  CMPSB, LODSB, or SCASB in 64-bit Mode with Count Greater or Equal to 248 May Terminate Early  	  In 64-bit Mode CMPSB, LODSB, or SCASB executed with a repeat prefix and count greater than or equal to 248 may terminate early. Early termination may result in one of the following. •  The last iteration not being executed  •  Signaling of a canonical limit fault (#GP) on the last iteration  	 While in 64-bit mode, with count greater or equal to 248, repeat string operations CMPSB, LODSB or SCASB may terminate without completing the last iteration. Intel has not observed this erratum with any commercially available software. 	 Do not use repeated string operations with RCX greater than or equal to 248. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector 26  Intel® Core™2 Duo Processor   will be left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep® Technology transitions or Thermal Monitor 1 events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VERW/VERR/LSL/LAR Instructions May Unexpectedly Update the Last Exception Record (LER) MSR  	  The LER MSR may be unexpectedly updated, if the resultant value of the Zero Flag (ZF) is zero after executing the following instructions 1. VERR (ZF=0 indicates unsuccessful segment read verification) 2. VERW (ZF=0 indicates unsuccessful segment write verification) 3. LAR (ZF=0 indicates unsuccessful access rights load) 4. LSL (ZF=0 indicates unsuccessful segment limit load)  	 The value of the LER MSR may be inaccurate if VERW/VERR/LSL/LAR instructions are executed after the occurrence of an exception. 	 Software exception handlers that rely on the LER MSR value should read the LER MSR before executing VERW/VERR/LSL/LAR instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  INIT Does Not Clear Global Entries in the TLB  	  INIT may not flush a TLB entry when:  Intel® Core™2 Duo Processor  27   •  The processor is in protected mode with paging enabled and the page global enable flag is set (PGE bit of CR4 register) •  G bit for the page table entry is set  •  TLB entry is present in TLB when INIT occurs  	 Software may encounter unexpected page fault or incorrect address translation due to a TLB entry erroneously left in TLB after INIT. 	 Write to CR3, CR4 (setting bits PSE, PGE or PAE) or CR0 (setting bits PG or PE) registers before writing to memory early in BIOS code to clear all the global entries from TLB. 	  For the steppings affected, see the Summary Tables of Changes. 
  Split Locked Stores May not Trigger the Monitoring Hardware  	  Logical processors normally resume program execution following the MWAIT, when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation. Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store that spans across cache lines within the monitored address range.  	 The logical processor that executed the MWAIT instruction may not resume execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is split across cache lines. 	 Do not use locked stores that span cache lines in the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing Shared Unaligned Data that Crosses a Cache Line without Proper Semaphores or Barriers May Expose a Memory Ordering Issue  28  Intel® Core™2 Duo Processor   	  Software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory ordering issue if multiple loads access this shared data shortly thereafter. Exposure to this problem requires the use of a data write which spans a cache line boundary.  	 This erratum may cause loads to be observed out of order. Intel has not observed this erratum with any commercially available software or system. 	 Software should ensure at least one of the following is true when modifying shared data by multiple agents: •  The shared data is aligned  •  Proper semaphores or barriers are used in order to prevent concurrent data accesses.  	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4G limit (0ffffffffh) may not signal a #GP fault.  	 When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault. 	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  An Asynchronous MCE During a Far Transfer May Corrupt ESP  	  If an asynchronous machine check occurs during an interrupt, call through gate, FAR RET or IRET and in the presence of certain internal conditions, ESP may be corrupted.  	 If the MCE (Machine Check Exception) handler is called without a stack switch, then a triple fault will occur due to the corrupted stack pointer, resulting in a processor shutdown. If the MCE is called with a stack switch, e.g. when the CPL (Current Privilege Level) was changed or when going through an interrupt task gate, then the corrupted ESP will be saved on the new stack or in the TSS (Task State Segment), and will not be used. 	 Use an interrupt task gate for the machine check handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Reports Architectural Performance Monitoring Version 2 is Supported, When Only Version 1 Capabilities are Available  Intel® Core™2 Duo Processor  29   	  CPUID leaf 0Ah reports the architectural performance monitoring version that is available in EAX[7:0]. Due to this erratum CPUID reports the supported version as 2 instead of 1.  	 Software will observe an incorrect version number in CPUID.0Ah.EAX [7:0] in comparison to which features are actually supported. 	 Software should use the recommended enumeration mechanism described in the Architectural Performance Monitoring section of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3: System Programming Guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1.  MOV or POP instruction to SS (Stack Segment) selector;  2.  Next instruction is FP (Floating Point) that gets FP assist  3.  Another instruction after the FP instruction completes successfully  4.  A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction.  Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4. 	 Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for nonenabled breakpoints. 	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes. 
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 30  Intel® Core™2 Duo Processor   	 BIOS must leave the xTPR update transactions disabled (default). 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event IA32_FIXED_CTR2 May Not Function Properly when Max Ratio is a Non-Integer Core-to-Bus Ratio  	  Performance Counter IA32_FIXED_CTR2 (MSR 30BH) event counts CPU reference clocks when the core is not in a halt state. This event is not affected by core frequency changes (e.g., P states, TM2 transitions) but counts at the same frequency as the Time-Stamp Counter IA32_TIME_STAMP_COUNTER (MSR 10H). Due to this erratum, the IA32_FIXED_CTR2 will not function properly when the non-integer core-tobus ratio multiplier feature is used and when a non-zero value is written to IA32_ FIXED_CTR2. Non-integer core-to-bus ratio enables additional operating frequencies. This feature can be detected by IA32_PLATFORM_ID (MSR 17H) bit [23].  	 The Performance Monitoring Event IA32_FIXED_CTR2 may result in an inaccurate count when the non-integer core-to-bus multiplier feature is used. 	 If writing to IA32_FIXED_CTR2 and using a non-integer core-to-bus ratio multiplier, always write a zero. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause a Livelock During Snoops of the L1 Data Cache  	  A livelock may be observed in rare conditions when instruction fetch causes multiple level one data cache snoops.  	 Due to this erratum, a livelock may occur. Intel has not observed this erratum with any commercially available software. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Use of Memory Aliasing with Inconsistent Memory Type may Cause a System Hang or a Machine Check Exception  	  Software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (MCE). This would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. If the cacheable address finds its way into the instruction cache, and the non-cacheable address is fetched in the IFU, the processor may invalidate the non-cacheable address from the fetch unit. Any micro-architectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and lack of it will cause a system hang or an MCE.  Intel® Core™2 Duo Processor  31   	 This erratum has not been observed with commercially available software. 	 Although it is possible to have a single physical page mapped by two different linear addresses with different memory types, Intel has strongly discouraged this practice as it may lead to undefined results. Software that needs to implement memory aliasing should manage the memory type consistency. 	  For the steppings affected, see the Summary Tables of Changes. 
  A WB Store Following a REP STOS/MOVS or FXSAVE May Lead to Memory-Ordering Violations  	  Under certain conditions, as described in the Software Developers Manual section "Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors", the processor may perform REP MOVS or REP STOS as write combining stores (referred to as “fast strings”) for optimal performance. FXSAVE may also be internally implemented using write combining stores. Due to this erratum, stores of a WB (write back) memory type to a cache line previously written by a preceding fast string/FXSAVE instruction may be observed before string/FXSAVE stores.  	 A write-back store may be observed before a previous string or FXSAVE related store. Intel has not observed this erratum with any commercially available software. 	 Software desiring strict ordering of string/FXSAVE operations relative to subsequent write-back stores should add an MFENCE or SFENCE instruction between the string/FXSAVE operation and following store-order sensitive code such as that used for synchronization. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exit with Exit Reason “TPR Below Threshold” Can Cause the Blocking by MOV/POP SS and Blocking by STI Bits to be Cleared in the Guest Interruptibility-State Field  	  As specified in Section, “VM Exits Induced by the TPR Shadow”, in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, a VM exit occurs immediately after any VM entry performed with the “use TPR shadow", "activate secondary controls”, and “virtualize APIC accesses” VMexecution controls all set to 1 and with the value of the TPR shadow (bits 7:4 in byte 80H of the virtual-APIC page) less than the TPR-threshold VMexecution control field. Due to this erratum, such a VM exit will clear bit 0 (blocking by STI) and bit 1 (blocking by MOV/POP SS) of the interruptibilitystate field of the guest-state area of the VMCS (bit 0 - blocking by STI and bit 1 - blocking by MOV/POP SS should be left unmodified).  	 Since the STI, MOV SS, and POP SS instructions cannot modify the TPR shadow, bits 1:0 of the interruptibility-state field will usually be zero before any VM entry meeting the preconditions of this erratum; behavior is correct in this case. However, if VMM software raises the value of the TPR-threshold 32  Intel® Core™2 Duo Processor   VM-execution control field above that of the TPR shadow while either of those bits is 1, incorrect behavior may result. This may lead to VMM software prematurely injecting an interrupt into a guest. Intel has not observed this erratum with any commercially available software. 	 VMM software raising the value of the TPR-threshold VM-execution control field should compare it to the TPR shadow. If the threshold value is higher, software should not perform a VM entry; instead, it could perform the actions that it would normally take in response to a VM exit with exit reason “TPR below threshold”. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using Memory Type Aliasing with Cacheable and WC Memory Types May Lead to Memory Ordering Violations  	  Memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory types. Memory type aliasing with a cacheable memory type and WC (write combining) may cause the processor to perform incorrect operations leading to memory ordering violations for WC operations.  	 Software that uses aliasing between cacheable and WC memory types may observe memory ordering errors within WC memory operations. Intel has not observed this erratum with any commercially available software. 	 None identified. Intel does not support the use of cacheable and WC memory type aliasing, and WC operations are defined as weakly ordered. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exit Caused by a SIPI Results in Zero to be Saved to the Guest RIP Field in the VMCS  	  If a logical processor is in VMX non-root operation and in the wait-for-SIPI state, an occurrence of a start-up IPI (SIPI) causes a VM exit. Due to this erratum, such VM exits always save zero into the RIP field of the guest-state area of the virtual-machine control structure (VMCS) instead of the value of RIP before the SIPI was received.  	 In the absence of virtualization, a SIPI received by a logical processor in the wait-for-SIPI state results in the logical processor starting execution from the vector sent in the SIPI regardless of the value of RIP before the SIPI was received. A virtual-machine monitor (VMM) responding to a SIPI-induced VM exit can emulate this behavior because the SIPI vector is saved in the lower 8 bits of the exit qualification field in the VMCS. Such a VMM should be unaffected by this erratum. A VMM that does not emulate this behavior may need to recover the old value of RIP through alternative means. Intel has not observed this erratum with any commercially available software. 	 VMM software that may respond to SIPI-induced VM exits by resuming the interrupt guest context without emulating the non-virtualized SIPI response Intel® Core™2 Duo Processor  33   should (1) save from the VMCS (using VMREAD) the value of RIP before any VM entry to the wait-for SIPI state; and (2) restore to the VMCS (using VMWRITE) that value before the next VM entry that resumes the guest in any state other than wait-for-SIPI. 	  For the steppings affected, see the Summary Tables of Changes. 
  NMIs May Not Be Blocked by a VM-Entry Failure  	  The Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2 specifies that, following a VM-entry failure during or after loading guest state, “the state of blocking by NMI is what it was before VM entry.” If non-maskable interrupts (NMIs) are blocked and the “virtual NMIs” VM-execution control set to 1, this erratum may result in NMIs not being blocked after a VM-entry failure during or after loading guest state.  	 VM-entry failures that cause NMIs to become unblocked may cause the processor to deliver an NMI to software that is not prepared for it. 	 VMM software should configure the virtual-machine control structure (VMCS) so that VM-entry failures do not occur. 	  For the steppings affected, see the Summary Tables of Changes. 
  Partial Streaming Load Instruction Sequence May Cause the Processor to Hang  	  Under some rare conditions, when multiple streaming load instructions (MOVNTDQA) are mixed with non-streaming loads that split across cache lines, the processor may hang.  	 Under the scenario described above, the processor may hang. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. However, streaming behavior may be re-enabled by setting bit 5 to 1 of the MSR at address 0x21 for software development or testing purposes. If this bit is changed, then a read-modify-write should be performed to preserve other bits of this MSR. When the streaming behavior is enabled and using streaming load instructions, always consume a full cache line worth of data and/or avoid mixing them with non-streaming memory references. If streaming loads are used to read partial cache lines, and mixed with nonstreaming memory references, use fences to isolate the streaming load operations from non-streaming memory operations. 	  For the steppings affected, see the Summary Tables of Changes. 
  Self/Cross Modifying Code May Not be Detected or May Cause a Machine Check Exception  34  Intel® Core™2 Duo Processor   	  If instructions from at least three different ways in the same instruction cache set exist in the pipeline combined with some rare internal state, selfmodifying code (SMC) or cross-modifying code may not be detected and/or handled.  	 An instruction that should be overwritten by another instruction while in the processor pipeline may not be detected/modified, and could retire without detection. Alternatively the instruction may cause a Machine Check Exception. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Data TLB Eviction Condition in the Middle of a Cacheline Split Load Operation May Cause the Processor to Hang  	  If the TLB translation gets evicted while completing a cacheline split load operation, under rare scenarios the processor may hang.  	 The cacheline split load operation may not be able to complete normally, and the machine may hang and generate Machine Check Exception. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Update of Read/Write (R/W) or User/Supervisor (U/S) or Present (P) Bits without TLB Shootdown May Cause Unexpected Processor Behavior  	  Updating a page table entry by changing R/W, U/S or P bits, even when transitioning these bits from 0 to 1, without keeping the affected linear address range coherent with all TLB (Translation Lookaside Buffers) and paging-structures caches in the processor, in conjunction with a complex sequence of internal processor micro-architectural events and store operations, may lead to unexpected processor behavior.  	 This erratum may lead to livelock, shutdown or other unexpected processor behavior. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Duo Processor  35  
  RSM Instruction Execution under Certain Conditions May Cause Processor Hang or Unexpected Instruction Execution Results  	  RSM instruction execution, under certain conditions triggered by a complex sequence of internal processor micro-architectural events, may lead to processor hang, or unexpected instruction execution results.  	 In the above sequence, the processor may live lock or hang, or RSM instruction may restart the interrupted processor context through a nondeterministic EIP offset in the code segment, resulting in unexpected instruction execution, unexpected exceptions or system hang. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. However due to this erratum, only Contributory Exceptions and Page Faults will cause a triple fault shutdown, whereas a benign exception may not.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Short Nested Loops That Span Multiple 16-Byte Boundaries May Cause a Machine Check Exception or a System Hang  	  Under a rare set of timing conditions and address alignment of instructions in a short nested loop sequence, software that contains multiple conditional jump instructions and spans multiple 16-byte boundaries, may cause a machine check exception or a system hang.  	 Due to this erratum, a machine check exception or a system hang may occur. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  36  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Duo Processor  
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May be Incorrectly Updated  	  The LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH) may contain incorrect values after any of the following: •  Either STPCLK#, NMI (NonMaskable Interrupt) or external interrupts  •  CMP or TEST instructions with an uncacheable memory operand followed by a conditional jump  •  STI/POP SS/MOV SS instructions followed by CMP or TEST instructions and then by a conditional jump  	 When the conditions for this erratum occur, the value of the LER MSRs may be incorrectly updated. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Duo Processor  37  
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A VM Exit Due to a Fault While Delivering a Software Interrupt May Save Incorrect Data into the VMCS  	  If a fault occurs during delivery of a software interrupt (INTn) in virtual-8086 mode when virtual mode extensions are in effect and that fault causes a VM exit, incorrect data may be saved into the VMCS. Specifically, information about the software interrupt may not be reported in the IDT-vectoring information field. In addition, the interruptibility-state field may indicate blocking by STI or by MOV SS if such blocking were in effect before execution of the INTn instruction or before execution of the VM-entry instruction that injected the software interrupt.  	 In general, VMM software that follows the guidelines given in the section “Handling VM Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide should not be affected. If the erratum improperly causes indication of blocking by STI or by MOV SS, the ability of a VMM to inject an interrupt may be delayed by one instruction. 	 VMM software should follow the guidelines given in the section “Handling VM Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  A VM Exit Occuring in IA-32e Mode May Not Produce a VMX Abort When Expected  	  If a VM exit occurs while the processor is in IA-32e mode and the “host address-space size” VM-exit control is 0, a VMX abort should occur. Due to this erratum, the expected VMX aborts may not occur and instead the VM Exit will occur normally. The conditions required to observe this erratum are a VM entry that returns from SMM with the “IA-32e guest” VM-entry control set to 1 in the SMM VMCS and the “host address-space size” VM-exit control cleared to 0 in the executive VMCS.  38  Intel® Core™2 Duo Processor   	 A VM Exit will occur when a VMX Abort was expected. 	 An SMM VMM should always set the “IA-32e guest” VM-entry control in the SMM VMCS to be the value that was in the LMA bit (IA32_EFER.LMA.LMA[bit 10]) in the IA32_EFER MSR (C0000080H) at the time of the last SMM VM exit. If this guideline is followed, that value will be 1 only if the “host address-space size” VM-exit control is 1 in the executive VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  PSI# Signal Asserted During Reset  	  Power Status Indicator (PSI) is a feature that, when available, may be used to enable voltage regulator power savings while idle and in the Deeper Sleep State (C4 state). Under proper operation the processor will assert the PSI# signal to indicate that the voltage regulator can enter a higher efficiency mode of operation. The processor will incorrectly assert the PSI# signal while the RESET# signal is asserted. This PSI# assertion will extend beyond the deassertion of the RESET# signal for a short duration (maximum of one millisecond).  	 When this erratum occurs on a platform designed to support PSI, the voltage regulator will transition to mode of operation that may not be capable of supplying the necessary voltage and current required by the processor. 	 Do not use PSI# signal without blocking the assertion during the error period as specified from RESET# assertion to a maximum of 1ms from the deasserted edge. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Duo Processor  39  
  Thermal Interrupts are Dropped During and While Exiting Intel® Deep Power-Down State  	  Thermal interrupts are ignored while the processor is in Intel Deep PowerDown State as well as during a small window of time while exiting from Intel Deep Power-Down State. During this window, if the PROCHOT signal is driven or the internal value of the sensor reaches the programmed thermal trip point, then the associated thermal interrupt may be lost.  	 In the event of a thermal event while a processor is waking up from Intel Deep Power-Down State, the processor will initiate an appropriate throttle response. However, the associated thermal interrupt generated may be lost. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Fail When Attempting to Set IA32_DEBUGCTL.FREEZE_WHILE_SMM_EN  	  If bit 14 (FREEZE_WHILE_SMM_EN) is set in the IA32_DEBUGCTL field in the guest-state area of the VMCS, VM entry may fail as described in Section “VMEntry Failures During or After Loading Guest State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2. (The exit reason will be 80000021H and the exit qualification will be zero.) Note that the FREEZE_WHILE_SMM_EN bit in the guest IA32_DEBUGCTL field may be set due to a VMWRITE to that field or due to a VM exit that occurs while IA32_DEBUGCTL.FREEZE_WHILE_SMM_EN=1.  	 A VMM will not be able to properly virtualize a guest using the FREEZE_WHILE_SMM feature. 	 It is possible for the BIOS to contain a workaround for this erratum. Alternatively, the following software workaround may be used. If a VMM wants to use the FREEZE_WHILE_SMM feature, it can configure an entry in the VM-entry MSR-load area for the IA32_DEBUGCTL MSR (1D9H); the value in the entry should set the FREEZE_WHILE_SMM_EN bit. In addition, the VMM should use VMWRITE to clear the FREEZE_WHILE_SMM_EN bit in the guest IA32_DEBUGCTL field before every VM entry. (It is necessary to do this before every VM entry because each VM exit will save that bit as 1.) This workaround prevents the VM-entry failure and sets the FREEZE_WHILE_SMM_EN bit in the IA32_DEBUGCTL MSR. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Hold-off / Delay a PECI Transaction Longer than Specified by the PECI Protocol  	  PECI (Platform Environment Control Interface) transactions may be held off longer than the PECI protocol hold-off limit while the processor is exiting Cstates. This may occur if STPCLK# has been asserted by the system, the  40  Intel® Core™2 Duo Processor   beginning of a PECI message coincides with a C-state transition, and the processor is executing a long instruction flow. Note that the processor can still complete the PECI transaction if the host chooses to process the remainder of the message. 	 Due to this erratum, the processor may violate the PECI hold-off protocol. 	 PECI hosts can choose to either complete or not complete PECI transactions when the processor goes beyond the hold-off limit. The processor generates the PECI hold-off indication by keeping the PECI bus high when the PECI host sends the first bit of the address timing negotiation phase. If the PECI host does not choose to complete the transaction, it should consider the transaction a failure and retry 1ms after the processor deactivates the holdoff indication. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Use Wrong Address to Access Virtual-APIC Page  	  When XFEATURE_ENABLED_MASK register (XCR0) bit 1 (SSE) is 1, a VM entry executed with the “use TPR shadow” VM-execution control set to 1 may use the wrong address to access data on the virtual-APIC page.  	 An affected VM entry may exhibit the following behaviors: (1) it may use wrong areas of the virtual-APIC page to determine whether VM entry fails or whether it induces a VM exit due to the TPR threshold; or (2) it may clear wrong areas of the virtual-APIC page. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  XRSTORE Instruction May Cause Extra Memory Reads  	  An XRSTOR instruction will cause non-speculative accesses to XSAVE memory area locations containing the FCW/FSW and FOP/FTW Floating Point (FP) registers even though the 64-bit restore mask specified in the EDX:EAX register pair does not indicate to restore the x87 FPU state.  	 Page faults, data breakpoint triggers, etc. may occur due to the unexpected non-speculative accesses to these memory locations. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction May Return Incorrect Brand String  	  When a CPUID instruction is executed with EAX = 8000_0002H, 8000_0003H, or 8000_0004H, the returned EAX, EBX, ECX, and/or EDX values may be incorrect.  Intel® Core™2 Duo Processor  41   	 When this erratum occurs, the processor may report an incorrect brand string. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Global Instruction TLB Entries May Not be Invalidated on a VM Exit or VM Entry  	  If a VMM is using global page entries (CR4.PGE is enabled and any present page-directories or page-table entries are marked global), then on a VM entry, the instruction TLB (Translation Lookaside Buffer) entries caching global page translations of the VMM may not be invalidated. In addition, if a guest is using global page entries, then on a VM exit, the instruction TLB entries caching global page translations of the guest may not be invalidated.  	 Stale global instruction linear to physical page translations may be used by a VMM after a VM exit or a guest after a VM entry. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  When Intel® Deep Power-Down State is Being Used, IA32_FIXED_CTR2 May Return Incorrect Cycle Counts  	  When the processor is operating at an N/2 core to front side bus ratio, after exiting an Intel Deep Power-Down State, the internal increment value for IA32_FIXED_CTR2 (Fixed Function Performance Counter 2, 30BH) will not take into account the half ratio setting.  	 Due to this erratum, IA32_FIXED_CTR2 MSR will not return reliable counts after returning from an Intel Deep Power-Down State. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Enabling PECI via the PECI_CTL MSR Does Not Enable PECI and May Corrupt the CPUID Feature Flags  	  Writing PECI_CTL MSR (Platform Environment Control Interface Control Register) will not update the PECI_CTL MSR (5A0H), instead it will write to the VMM Feature Flag Mask MSR (CPUID_FEATURE_MASK1, 478H).  	 Due to this erratum, PECI (Platform Environment Control Interface) will not be enabled as expected by the software. In addition, due to this erratum, processor features reported in ECX following execution of leaf 1 of CPUID (EAX=1) may be masked. Software utilizing CPUID leaf 1 to verify processor capabilities may not work as intended. 42  Intel® Core™2 Duo Processor   	 It is possible for the BIOS to contain a workaround for this erratum. Do not initialize PECI before processor update is loaded. Also, load processor update as soon as possible after RESET as documented in the RS – Wolfdale Processor Family Bios Writers Guide, Section 14.8.3 Bootstrap Processor Initialization Requirements. 	  For the steppings affected, see the Summary Tables of Changes. 
  INIT Incorrectly Resets IA32_LSTAR MSR  	  In response to an INIT reset initiated either via the INIT# pin or an IPI (Inter Processor Interrupt), the processor should leave MSR values unchanged. Due to this erratum IA32_LSTAR MSR (C0000082H), which is used by the iA32e SYSCALL instruction, is being cleared by an INIT reset.  	 If software programs a value in IA32_LSTAR to be used by the SYSCALL instruction and the processor subsequently receives an INIT reset, the SYSCALL instructions will not behave as intended. Intel has not observed this erratum in any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the  Intel® Core™2 Duo Processor  43   exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. Subsequent BTS and BTM operations which report the LBR will also be incorrect. 	 LBR, BTS and BTM may report incorrect information in the event of an exception/interrupt. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The XRSTOR Instruction May Fail to Cause a General-Protection Exception  	  The XFEATURE_ENABLED_MASK register (XCR0) bits [63:9] are reserved and must be 0; consequently, the XRSTOR instruction should cause a generalprotection exception if any of the corresponding bits in the XSTATE_BV field in the header of the XSAVE/XRSTOR area is set to 1. Due to this erratum, a logical processor may fail to cause such an exception if one or more of these reserved bits are set to 1.  	 Software may not operate correctly if it relies on the XRSTOR instruction to cause a general-protection exception when any of the bits [63:9] in the XSTATE_BV field in the header of the XSAVE/XRSTOR area is set to 1. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The XSAVE Instruction May Erroneously Modify Reserved Bits in the XSTATE_BV Field  	  Bits 63:2 of the HEADER.XSTATE_BV are reserved and must be 0. Due to this erratum, the XSAVE instruction may erroneously modify one or more of these bits.  	 If one of bits 63:2 of the XSTATE_BV field in the header of the XSAVE/XRSTOR area had been 1 and was then cleared by the XSAVE instruction, a subsequent execution of XRSTOR may not generate the #GP (general-protection exception) that would have occurred in the absence of this erratum. Alternatively, if one of those bits had been 0 and was then set by the XSAVE instruction, a subsequent execution of XRSTOR may generate a #GP that would not have occurred in the absence of this erratum. 	 It is possible for the BIOS to contain a partial workaround for this erratum that prevents XSAVE from setting HEADER.XSTATE_BV reserved bits. To ensure compatibility with future processors, software should not set any XSTATE_BV reserved bits when configuring the header of the XSAVE/XRSTOR save area. 44  Intel® Core™2 Duo Processor   	  For the steppings affected, see the Summary Tables of Changes. 
  Store Ordering Violation When Using XSAVE  	  The store operations done as part of the XSAVE instruction may cause a store ordering violation with older store operations. The store operations done to save the processor context in the XSAVE instruction flow , when XSAVE is used to store only the SSE context, may appear to execute before the completion of older store operations.  	 Execution of the stores in XSAVE, when XSAVE is used to store SSE context only, may not follow program order and may execute before older stores. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Memory Ordering Violation With Stores/Loads Crossing a Cacheline Boundary  	  When two logical processors are accessing the same data that is crossing a cacheline boundary without serialization, with a specific set of processor internal conditions, it is possible to have an ordering violation between memory store and load operations.  	 Due to this erratum, proper load/store ordering may not be followed when multiple logical processors are accessing the same data that crosses a cacheline boundary without serialization. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel Architecture Software Developer's Manual Volume 3: System Programming Guide, including a General Protection Fault (GPF) or other unexpected Intel® Core™2 Duo Processor  45   behaviors. In the event that unpredictable execution causes a GPF the application executing the unsynchronized XMC operation would be terminated by the operating system. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel Architecture Software Developer's Manual Volume 3: System Programming Guide, Section: Handling Self- and Cross-Modifying Code. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1”. 	  For the steppings affected, see the Summary Tables of Changes. 
  Not-Present Page Faults May Set the RSVD Flag in the Error Code  	  An attempt to access a page that is not marked present causes a page fault. Such a page fault delivers an error code in which both the P flag (bit 0) and the RSVD flag (bit 3) are 0. Due to this erratum, not-present page faults may deliver an error code in which the P flag is 0 but the RSVD flag is 1.  	 Software may erroneously infer that a page fault was due to a reserved-bit violation when it was actually due to an attempt to access a not-present page. Intel has not observed this erratum with any commercially available software. 	 Page-fault handlers should ignore the RSVD flag in the error code if the P flag is 0. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to “NMI-Window Exiting” May Be Delayed by One Instruction  	  If VM entry is executed with the “NMI-window exiting” VM-execution control set to 1, a VM exit with exit reason “NMI window” should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made  46  Intel® Core™2 Duo Processor   with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction. 	 VMM software using “NMI-window exiting” for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Overwrite the Value for the IA32_DEBUGCTL MSR Specified in the VM-Entry MSR-Load Area  	  Following a successful VM entry with the “load debug controls” VM-entry control set to 1, the IA32_DEBUGCTL MSR (1D9H) will always contain the value held in the guest IA32_DEBUGCTL field in the virtual-machine control structure (VMCS). If there is a value for the MSR in the VM-entry MSR-load area, the processor will incorrectly overwrite that value with the value in the VMCS.  	 Due to this erratum, VM entry may result in the wrong value being loaded into the IA32_DEBUGCTL MSR. Intel has not observed this erratum with any commercially available software.  Intel® Core™2 Duo Processor  47   	 Software seeking to load the IA32_DEBUGCTL MSR as part of VM entry should place the desired value in the guest IA32_DEBUGCTL field in the VMCS and set the “load debug controls” VM-entry control to 1. 	  For the steppings affected, see the Summary Tables of Changes. 
  A 64-bit Register IP-relative Instruction May Return Unexpected Results  	  Under an unlikely and complex sequence of conditions in 64-bit mode, a register IP-relative instruction result may be incorrect.  	 A register IP-relative instruction result may be incorrect and could cause software to read from or write to an incorrect memory location. This may result in an unexpected page fault or unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	NA
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example, if an instruction that masks the interrupt flag, for example CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set (that is, by STI instruction). Interrupts will remain pending and are not lost.  	  	 In this example the processor may allow interrupts to be accepted but may delay their service.  	 This non-synchronization can be avoided by issuing an APIC register  read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum.  	 For the steppings affected, see the Summary Tables of Changes.
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang.  	 BIOS must leave the xTPR update transactions disabled (default). 	 For the steppings affected, see the Summary Tables of Changes.
  Processor May Report a #TS Instead of a #GP Fault A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.   17   	 None 	 For the steppings affected, see the Summary Tables of Changes.
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.  	 Any vector programmed into an LVT entry must have an ISR associated  with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT.  	 For the steppings affected, see the Summary Tables of Changes.
  MOV To/From Debug Registers Causes Debug Exception When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	  	 With debug-register protection enabled (that is, the GD bit set), when  attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in  V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler.  	 For the steppings affected, see the Summary Tables of Changes.  18   
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations An external A20M# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit 20 may not be masked.  	   paging is enabled  a linear address has bit 20 set  the address references a large page  A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system.  	 Operating systems should not allow A20M# to be enabled if the  masking of address bit 20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory.  	 For the steppings affected, see the Summary Tables of Changes.
  Values for LBR/BTS/BTM will be Incorrect after an Exit from SMM After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None 	 For the steppings affected, see the Summary Tables of Changes.   19  
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit  violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.  	 For the steppings affected, see the Summary Tables of Changes.
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed.  	 None 	 For the steppings affected, see the Summary Tables of Changes.
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold.  	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value.  	 For the steppings affected, see the Summary Tables of Changes.  20   
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it  may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software.  	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	 For the steppings affected, see the Summary Tables of Changes.
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (that is, residual stack data as a result of processing the fault).  	  	 Data in the created stack frame may be altered following a fault on the  ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software.  	 None 	  For the steppings affected, see the Summary Tables of Changes. 
  With TF (Trap Flag) Asserted, FP Instruction That Triggers an Unmasked FP Exception May Take Single Step Trap before Retirement of Instruction If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  	  	 A Single Step trap will be taken when not expected. 	 None 	  For the steppings affected, see the Summary Tables of Changes.   21  
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken After MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. ®  	 As recommended in the Intel 64 and IA-32 Architectures Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP and [r/e]BP will avoid the failure since the MOV [r/e]SP and [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (for example NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a non-canonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  	 Operating systems may observe a #GP fault being serviced before  higher priority interrupts and exceptions. Intel has not observed this erratum on any commercially available software.  	 None 	 For the steppings affected, see the Summary Tables of Changes.  22   
  BTS (Branch Trace Store) and PEBS(Precise Event Based Sampling) May Update Memory outside the BTS/PEBS Buffer 	  If the BTS/PEBS buffer is defined such that:   The difference between BTS/PEBS buffer base and BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes  BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space  The record that would cross BTS/PEBS absolute maximum will also continue past the end of the virtual address space A BTS/PEBS record can be written that will wrap at the 4G boundary (IA32) or 2^64 boundary (EM64T mode), and write memory outside of the BTS/PEBS buffer.  	NA	 Define BTS/PEBS buffer such that BTS/PEBS absolute maximum minus BTS/PEBS buffer base is integer multiple of the corresponding record sizes as recommended in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3.  	 For the steppings affected, see the Summary Tables of Changes.
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	  	 When this erratum occurs, #DB will be incorrectly handled as follows:  #DB is signaled before the pending higher priority #MF (Interrupt 16)  #DB is generated twice on the same instruction  	 None 	 For the steppings affected, see the Summary Tables of Changes.   23  
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor (that is, executing the modified code).  	  	 In this case, the phrase "unexpected or unpredictable execution ® behavior" encompasses the generation of most of the exceptions listed in the Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors.  	 To avoid this erratum, programmers should use the XMC ® synchronization algorithm as detailed in the Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Section: Handling Self- and Cross-Modifying Code.  	 For the steppings affected, see the Summary Tables of Changes.
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly The IO_SMI bit in SMRAM’s location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by:  	    A SMI that is, pending while a lower priority event is executing   A REP I/O read  A I/O read that redirects to MWAIT  	 SMM handlers may get false IO_SMI indication. 	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address.  	 For the steppings affected, see the Summary Tables of Changes.  24   
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	  	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not  be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software.  	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	 For the steppings affected, see the Summary Tables of Changes.
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May be Incorrect When an L2 Cache error occurs (Error code 0x010A or 0x110A reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  	  	 Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors.  	 None 	 For the steppings affected, see the Summary Tables of Changes.
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep® Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  	  	 Software may observe #MF being serviced before higher priority interrupts.  	 None 	 For the steppings affected, see the Summary Tables of Changes.   25  
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  	  	 If a benign exception occurs while attempting to call the double-fault  handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software.  	 None 	 For the steppings affected, see the Summary Tables of Changes.
  IA32_MC1_STATUS MSR Bit [60] Does Not Reflect Machine Check Error Reporting Enable Correctly IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit [60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update.  	 None 	 For the steppings affected, see the Summary Tables of Changes.  26   
  If Two Logical Processors Use the Same CR3 Value But Configure APIC Virtualization Differently, Either May Operate as if APIC Virtualization Were Disabled If a logical processor is in VMX non-root operation with the "virtual APIC accesses" VM-execution control set to 1, it may incorrectly operate as if the "virtual APIC accesses" VM-execution control was cleared to 0 if another logical processor has the same value in CR3 and one of the following is true:  	   The other logical processor is not in VMX non-root operation  The other logical processor has the “virtualize APIC accesses” VM-execution control cleared to 0  The other logical processor’s value of the “APIC-access address” VM-execution control field is different than that of the first logical processor  	 A logical processor may fail to support the APIC-virtualization features  properly if a virtual-machine monitor (VMM) uses the same page tables as a virtual machine (VM) using the APIC-virtualization features, or if two VMs (or two virtual CPUs within a VM) use the same page tables but operate with different settings of the APIC-virtualization features.  	 A VMM should not use for itself the same page tables as a VM using the APIC-virtualization features, and it should configure two virtual CPUs to use the same page tables only if they use the same settings of the APIC-virtualization features.  	 For the steppings affected, see the Summary Tables of Changes.
  Split Locked Stores or Locked Stores Through Certain Segments May not Trigger the Monitoring Hardware Logical processors normally resume program execution following the MWAIT, when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation. Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store within the monitored address range that either spans across cache lines or uses a segment register whose segment base is non-cacheline aligned.  	  	 The logical processor that executed the MWAIT instruction may not  resume execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is either split across cache lines or through a segment whose segment base bits 5 to 0 are non-zero.  	 Avoid accessing the monitored address range using either locked stores that split cache lines or locked stores that use a segment with a non-cacheline aligned segment base. It is possible for the BIOS to contain a workaround for this erratum  	 For the steppings affected, see the Summary Tables of Changes.   27  
  When BIST is Enabled, Warm Reset Incorrectly Clears IA32_FEATURE_CONTROL MSR and the Last Exception Record MSRs IA32_FEATURE_CONTROL MSR (3AH), MSR_LER_FROM_LIP MSR (1DDH), and MSR_LER_TO_LIP MSR (1DEH) are cleared during warm reset when BIST (Built-In Self Test) is enabled. These MSRs should only be cleared on a power-up reset and not on a warm reset. A warm reset is different from a power-up reset in that PWRGOOD remains active throughout the assertion of RESET#.  	  	 Due to this erratum, any warm reset will clear  IA32_FEATURE_CONTROL MSR, MSR_LER_FROM_LIP MSR, and MSR_LER_TO_LIP MSR content when BIST is enabled.  	 BIOS or other firmware software must save IA32_FEATURE_CONTROL MSR, MSR_LER_FROM_LIP MSR, and MSR_LER_TO_LIP MSR information before warm reset and restore and reprogram the MSRs after the warm reset.  	 For the steppings affected, see the Summary Tables of Changes.
  A VM Exit Due to a Fault While Delivering a Software Interrupt May Save Incorrect Data into the VMCS  	  If a fault occurs during delivery of a software interrupt (INTn) in virtual-8086 mode when virtual mode extensions are in effect and that fault causes a VM exit, incorrect data may be saved into the VMCS. Specifically, information about the software interrupt may not be reported in the IDT-vectoring information field. In addition, the interruptibility-state field may indicate blocking by STI or by MOV SS if such blocking were in effect before execution of the INTn instruction or before execution of the VMentry instruction that injected the software interrupt.  	 In general, VMM software that follows the guidelines given in the section “Handling VM  Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide should not be affected. If the erratum improperly causes indication of blocking by STI or by MOV SS, the ability of a VMM to inject an interrupt may be delayed by one instruction.  	 VMM software should follow the guidelines given in the section “Handling VM Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide  	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction Returns Incorrect Brand String  	  When a CPUID instruction is executed with EAX = 80000002H, 80000003H and 80000004H on an Intel® Atom™ processor, the return value contains the brand string Intel(R) Core(TM)2 CPU when it should have Intel(R) Atom(TM) CPU.  	 When this erratum occurs, the processor will report the incorrect brand string. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  28  For the steppings affected, see the Summary Tables of Changes.   
  A Logical Processor May Incorrectly Clear Thermal Status Log Indicator During Intel Deep Power Down Technology State Transition  	  When a logical processor enters the Intel Deep Power Down Technology State (for example as requested by MWAIT or I/O redirection), it may incorrectly clear the sticky Thermal Status Log flag (bit 1) in IA32_THERM_STATUS MSR (19CH). This erratum will not occur when Hyper-Threading (HT) is disabled.  	 When Hyper-Threading is enabled, a logical processor may incorrectly indicate that the thermal sensor has not tripped since last power-up.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Instruction Cache Does Not Respond to Snoops When All Logical Processors on a Core Are in an Inactive State  	  When all logical processors on a core enter an inactive state (for example MWAIT or HLT), the processor may incorrectly stop flushing lines in its instruction cache in response to snoops. This may cause the processor to not detect that memory has been modified and to execute the old instructions after waking up instead of the new contents of memory.  	 The processor may execute incorrect instructions after waking up from an inactive state.  	 It is possible for the BIOS to contain a workaround for this erratum 	  For the steppings affected, see the Summary Tables of Changes. 
  LINT0 Assertion and Deassertion during an Inactive State May Cause Unexpected Operation When APIC is Disabled  	  An interrupt delivered via LINT0 pins when the APIC is hardware disabled (IA32_APIC_BASE MSR (1BH) bit [11] is cleared) will usually keep the pin asserted until after the interrupt is acknowledged. However, if LINT0 is asserted and then deasserted before the interrupt is acknowledged and both of the following are true then the processor may operate incorrectly.  The APIC is hardware disabled (IA32_APIC_BASE MSR bit [11] is clear) and  The processor is in inactive state that was requested by MWAIT, I/O redirection, VM-entry or RSM,  	 Due to this erratum, the processor may run unexpected code and/or generate an  unexpected exception. Intel has not observed this erratum with any commercially available software.  	 If LINT0 is used, it is recommended to either leave the APIC enabled  (IA32_APIC_BASE MSR bit [11] set to 1) or do not use MWAIT, I/O redirection, VMentry or RSM to enter an inactive state.  	  For the steppings affected, see the Summary Tables of Changes.   29  
  Speculative Load from Address 1D9H May Occur During a Failed VMCALL in VMX Root Operation  	  Execution of VMCALL in VMX root operation (to activate the dual-monitor treatment of SMIs and SMM) fails if the current VMCS pointer is FFFFFFFF_FFFFFFFFH. Due to this erratum, such a VMCALL may speculatively send a load access request for 2 bytes from physical address 1D9H.  	 The processor may send out an improper load access request to address 1D9H; there may be no memory at this address, and any memory-mapped I/O located at address 1D9H may be accessed inappropriately. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround to this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Not Wake Up from an Inactive State When an Enhanced Intel SpeedStep® Technology Transition is Pending  	  Due to this erratum, the processor may hang in rare scenarios when it is in an inactive state and there is an Enhanced Intel SpeedStep Technology transition pending.  	 The processor may hang and be unable to resume execution. A processor reset will be needed to restart processor execution. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround to this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Thermal Interrupts are Dropped During and While Exiting Intel® Deep Power-Down State  	  Thermal interrupts are ignored while the processor is in Intel Deep Power Down Technology state as well as during a small window of time while exiting from Intel Deep Power Down Technology state. During this window, if the PROCHOT signal is driven or the internal value of the sensor reaches the programmed thermal trip point, then the associated thermal interrupt may be lost.  	 In the event of a thermal event while a processor is waking up from Intel Deep PowerDown State, the processor will initiate an appropriate throttle response. However, the associated thermal interrupt generated may be lost.  	 None identified. 	  30  For the steppings affected, see the Summary Tables of Changes.   
  Incorrect Memory Types May be Used While Executing Instructions That Accesses VMCS Structures or Load PDPTRs  	  If MTRRs are enabled and if CR0.CD=0, each logical processor on that core should use a WB (Write-back) memory type while executing instructions that access VMCS structures or loading PDPTRs. If CR0.CD=1 or MTRRs are disabled, the processor must use UC (Uncacheable) memory type for the same accesses. Due to this erratum, a logical processor may use WB memory type when it is supposed to use UC or viceversa.  	 Due to this erratum, the processor may update cache when all memory accesses  should be UC or could cause a change in performance when memory accesses should be WB.  	 If software requires PDPTR loads and VMX accesses to use UC memory type, then it  should set CR0.CD=1 on all logical processors on a core. Additionally, software (including the SMM handler) must insure CR0.CD=1 and must not write to the IA32_MTRR_DEF_TYPE MSR during the period UC memory type is required. If software desires that PDPTR loads and VMX accesses use WB memory types, then on all logical processors on that core it should write the IA32_MTRR_DEF_TYPE MSR with a value that has the MTRR Enable set and clear CR0.CD.  	  For the steppings affected, see the Summary Tables of Changes. 
  TSC May be a Lower Value After Being in the Deeper Sleep State  	  Due to this erratum, the TSC (Time-Stamp Counter) may be observed to be a lower value after being in the Deeper Sleep State, irrespective of Deeper Sleep State duration.  	 Software may read a lower TSC value after exiting the Deeper Sleep State than it read before entering the Deeper Sleep State.  	 It is possible for the BIOS to contain a workaround to this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   31  
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact  unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Counter with AnyThread Bit set May Not Count on a Non-Active Thread  	  A performance counter with the AnyThread bit (IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21], IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2) set should count that event on all logical processors on that core. Due to this erratum, a performance counter on a logical processor which has requested to be placed in the Intel® Deep Power-Down State may not count events that occur on another logical processor.  	 The performance monitor count may be incorrect when the logical processor is asleep  but still attempting to count another logical processor’s events. This will only occur on processors supporting Hyper-Threading Technology (HT Technology).  	 None identified. 	  32  For the steppings affected, see the Summary Tables of Changes.   
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring >0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical  processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction Returns Incorrect Value for Leaf 0xA  	  When a CPUID instruction is executed with EAX = 0AH, the value returned in EDX is 0x2501, which reports support for only one fixed-function performance counter and also has an undefined bit [bit 13] set . The value of EDX should be 0x0503, reflecting that three fixed-function performance counters are supported.  	 When this erratum occurs, the processor will report an incorrect value in EDX. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMI Request is not Generated on a Counter Overflow if its OVF Bit is Already set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh) then future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	 If software does not clear the OVF bit corresponding to a performance counter then future counter overflows may not cause PMI requests.  	 Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler. For the steppings affected, see the Summary Tables of Changes.   33  	NA
  CPUID Indicates Wrong L2 Associativity in Leaf 80000006H  	  When a CPUID instruction is executed with EAX= 80000006H on a processor with a 512K L2 cache, it incorrectly returns 08H in ECX[15:12] which indicates a 16-way set associative L2. The return value in ECX[15:12] should have been 06H to indicate a 8-way set associative L2.  	 CPUID will report the L2 set associativity as 16-way when it should report 8-way. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Fetch May Occur to Incorrect Address After a Large Page is Split into 4-KByte Pages  	  If software clears the PS (page size) bit in a present PDE (page directory entry), that will cause linear addresses mapped through this PDE to use 4-KByte pages instead of using a large page after old TLB entries are invalidated. Due to this erratum, if a code fetch uses this PDE before the TLB entry for the large page is invalidated then it may fetch from a different physical address than specified by either the old large page translation or the new 4-KByte page translation. This erratum may also cause speculative code fetches from incorrect addresses.  	 The processor may fetch code from an incorrect address after a large page is converted into 4-Kbyte pages.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Contain Incorrect Data and Hang Upon a Snoop when Combined with Specific Other Internal Conditions  	  In a specific corner case, a snoop to a processor may cause incorrect data that will be followed by a hang.  	 Due to this erratum, the processor may contain incorrect data and hang in this specific circumstance.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  34  For the steppings affected, see the Summary Tables of Changes.   
  Processor May Use an Incorrect Translation if the TLBs Contain Two Different Translations for a Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4-KByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	 Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE.  	 Software can avoid this problem by ensuring that the TLBs never contain both  ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type.  	  For the steppings affected, see the Summary Tables of Changes. 
  LBR Stack May Not be Frozen on a PMI Request When FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI flag (IA32_DEBUGCTL MSR (1D9H) bit [11]) is set on an Atom processor, a PMI (performance monitor interrupt) request should cause the LBR and TR flags (IA32_DEBUGCTL MSR (1D9H) bit [1:0]) to be cleared and the LBR (last branch record) stack to stop being updated by branches/interrupts/exceptions. Due to this erratum, the processor may clear the LBR and TR flags but not stop the LBR stack from being updated when FREEZE_LBRS_ON_PMI is set and a PMI request occurs.  	 Following a PMI request, the LBRs may continue to be updated by  branches/interrupts/exceptions even when FREEZE_LBRS_ON_PMI is set. The LBRs may contain values recorded after the PMI request.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. Due to this erratum, IA32_MPERF may not be reset when IA32_APERF overflows. Instead, IA32_MPERF may continue to increment without being reset.  	 Due to this erratum, software cannot rely on synchronous reset of the IA32_MPERF  register. The typical usage of IA32_MPERF/IA32_APERF is to initialize them with a value of 0; in this case the overflow of the counter wouldn’t happen for over 10 years.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   35  
  Complex Conditions Associated With Instruction Page Remapping or Self/Cross-Modifying Code Execution May Lead to Unpredictable System Behavior  	  Under a complex set of internal conditions, instruction page remapping, or self/cross modifying code events may lead to unpredictable system behavior  	 Due to this Erratum, unpredictable system behavior may be observed. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing With Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under the conditions described in the Software Developers Manual section “Fast String Operation,” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum, fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary, the following may occur, dependent on the new page memory type:   UC: The data size of each read and write may be different than the original data size.  WP: The data size of each read and write may be different than the original data size and there may be a memory ordering violation.  WT: There may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled.  	  For the steppings affected, see the Summary Tables of Changes. 
  Paging Structure Entry May be Used Before Accessed And Dirty Flags Are Updated  	  If software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a TLB (or an entry in a paging structure cache) and then update the entry’s new value to set the accessed flag or dirty flag. This will occur only if both the old and new values of the entry result in valid translations.  	 Incorrect behavior may occur with algorithms that atomically check that the accessed  flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation.  	 Affected algorithms must ensure that appropriate TLB invalidation is done before  assuming that future accesses do not use translations based on the old value of the paging structure entry.	NA
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software or system.  	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1. MOV or POP instruction to SS (Stack Segment) selector;  17   2. Next instruction is FP (Floating Point) that gets FP assist 3. Another instruction after the FP instruction completes successfully 4. A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4. 	  Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints.  	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes. 
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex micro architectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a non-canonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	  The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section   18  titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	  The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6 May Contain Incorrect Information When the First Instruction After a MOV SS,r/m or POP SS is a Store  	  Normally, each instruction clears the changes in DR6 (Debug Status Register) caused by the previous instruction. However, the instruction following a MOV SS,r/m (MOV to the stack segment selector) or POP SS (POP stack segment selector) instruction will not clear the changes in DR6 because data breakpoints are not taken immediately after a MOV SS,r/m or POP SS instruction. Due to this erratum, any DR6 changes caused by a MOV SS,r/m or POP SS instruction may be cleared if the following instruction is a store.  	  When this erratum occurs, incorrect information may exist in DR6. This erratum will not be observed under normal usage of the MOV SS,r/m or POP SS instructions (i.e., following them with an instruction that writes [e/r]SP). When debugging or when developing debuggers, this behavior should be noted.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  19  For the steppings affected, see the Summary Tables of Changes.  
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  	  Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting MMX Instruction May Incorrectly Update x87 FPU Tag Word  	  Under a specific set of conditions, MMX stores (MOVD, MOVQ, MOVNTQ, MASKMOVQ) which cause memory access faults (#GP, #SS, #PF, or #AC), may incorrectly update the x87 FPU tag word register. This erratum will occur when the following additional conditions are also met. • The MMX store instruction must be the first MMX instruction to operate on x87 FPU state (i.e. the x87 FP tag word is not already set to 0x0000). • For MOVD, MOVQ, MOVNTQ stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to MASKMOVQ).  	  If the erratum conditions are met, the x87 FPU tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.  	 None identified 	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
 During SMM  	 	NA	NA	NA
 counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if 1. A performance counter overflowed before an SMI	NA	NA	NA	NA
 not occurred 3. The monitored event occurs during SMM	NA	NA	NA	NA
 occurs outside of SMM.  	NA	 	NA	NA
 performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set.  	NA	NA	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   20 
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g. Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	  Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	  An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Event May Intervene Before a System Management Interrupt That Results from IN or INS  	  If an I/O instruction (IN, INS, OUT, or OUTS) results in an SMI (system-management interrupt), the processor will set the IO_SMI bit at offset 7FA4H in SMRAM. This interrupt should be delivered immediately after execution of the I/O instruction so that the software handling the SMI can cause the I/O instruction to be re-executed. Due to this erratum, it is possible for another event (e.g., a non maskable interrupt) to be delivered before the SMI that follows the execution of an IN or INS instruction.  	  If software handling an affected SMI uses I/O instruction restart, the handler for the intervening event will not be executed.  	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	  In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame.  	 Software should not generate misaligned stack frames for use with IRET. 	  21  For the steppings affected, see the Summary Tables of Changes.  
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	  The values of the LER MSRs may be unreliable.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	  None identified.  	  For the steppings affected, see the Summary Tables of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.   22  	  With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
  	 	NA	NA	NA
 buffer. Due to this erratum, if the overflow occurs during probe mode, it may be	NA	NA	NA	NA
  	NA	 	NA	NA
 during probe mode.  	NA	NA	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counter INST_RETIRED.STORES May Count Higher than Expected  	  Performance Monitoring counter INST_RETIRED.STORES (Event: C0H) is used to track retired instructions which contain a store operation. Due to this erratum, the processor may also count other types of instructions including WRMSR and MFENCE.  	  Performance Monitoring counter INST_RETIRED.STORES may report counts higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	  The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations.  	  Under certain conditions as described in the Software Developers Manual section “Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  23   	  Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	  Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type.  	 Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	  When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to “NMI-Window Exiting” May Be Delayed by One Instruction  	  If VM entry is executed with the “NMI-window exiting” VM-execution control set to 1, a VM exit with exit reason “NMI window” should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one   24  instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction. 	  VMM software using “NMI-window exiting” for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM Will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VPHMINPOSUW Instruction in VEX Format Does Not Signal #UD (Invalid Opcode Exception) When vex.vvvv !=1111  	  Processor does not signal #UD fault when executing the reserved instruction VPHMINPOSUW with vex.vvvv!=1111. The VPHMINPOSUW instruction is described in greater detail in the Intel® Advanced Vector Extensions Programming Reference.  	  Executing VPHMINPOSUW with vex.vvvv != 1111 results in same behavior as vex.vvvv= 1111.  	 SW should not use VPHMINPOSUW with vex.vvvv != 1111 in order to ensure future compatibility. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	  Software may observe #MF being signaled before pending interrupts are serviced.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMREAD/VMWRITE Instruction May Not Fail When Accessing an Unsupported Field in VMCS  	  The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B states that execution of VMREAD or VMWRITE should fail if the value of the instruction’s register source operand corresponds to an unsupported field in the VMCS (Virtual Machine Control Structure). The correct operation is that the logical processor will set the ZF (Zero Flag), write 0CH into the VM-instruction error field and for VMREAD leave the instruction’s destination operand unmodified. Due to this erratum, the instruction  25   may instead clear the ZF, leave the VM-instruction error field unmodified and for VMREAD modify the contents of its destination operand. 	  Accessing an unsupported field in VMCS will fail to properly report an error. In addition, VMREAD from an unsupported VMCS field may unexpectedly change its destination operand. Intel has not observed this erratum with any commercially available software.  	 Software should avoid accessing unsupported fields in a VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VZEROALL/VZEROUPPER  	  Execution of the VZEROALL or VZEROUPPER instructions in 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.  	 Compilers should encode VEX.W = 0 for the VZEROALL and VZEROUPPER instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of Opcode 9BH with the VEX Opcode Extension May Produce a #NM Exception  	  Attempt to use opcode 9BH with a VEX opcode extension should produce a #UD (Invalid-Opcode) exception. Due to this erratum, if CR0.MP and CR0.TS are both 1, the processor may produce a #NM (Device-Not-Available) exception if one of the following conditions exists: • 66H, F2H, F3H or REX as a preceding prefix; • An illegal map specified in the VEX.mmmmm field;  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should not use opcode 9BH with the VEX opcode extension. 	  For the steppings affected, see the Summary Tables of Changes. 
  Enabling Opportunistic Self-Refresh and Pkg C2 State Can Severely Degrade PCIe* Bandwidth  	  Due to this erratum, enabling opportunistic self-refresh can lead to the memory controller over-aggressively transitioning DRAM to self-refresh mode when the processor is in Pkg C2 state.  	  The PCIe interface peak bandwidth can be degraded by as much as 90%.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  An Unexpected Page Fault or EPT Violation May Occur After Another Logical Processor Creates a Valid Translation for a Page  	  An unexpected page fault (#PF) or EPT violation may occur for a page under the following conditions: • The paging structures initially specify no valid translation for the page. • Software on one logical processor modifies the paging structures so that there is a valid translation for the page (e.g., by setting to 1 the present bit in one of the paging-structure entries used to translate the page). • Software on another logical processor observes this modification (e.g., by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit).   26  • Shortly thereafter, software on that other logical processor performs a store to a linear address on the page. In this case, the store may cause a page fault or EPT violation that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). Intel has not observed this erratum with any commercially available software. 	  An unexpected page fault may be reported. There are no other side effects due to this erratum.  	 System software can be constructed to tolerate these unexpected page faults. See Section “Propagation of Paging-Structure Changes to Multiple Processors” of Volume 3B of IA-32 Intel® Architecture Software Developer’s Manual, for recommendations for software treatment of asynchronous paging-structure updates. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting Executions of XRSTOR May Update State Inconsistently  	  The state updated by a faulting XRSTOR instruction may vary from one execution to another.  	  Software that relies on x87/SSE/AVX state following a faulting execution of XRSTOR may behave inconsistently.  	 Software handling a fault on an execution of XRSTOR can compensate for execution variability by correcting the cause of the fault and executing XRSTOR again. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of FXSAVE or FXRSTOR With the VEX Prefix May Produce a #NM Exception  	  Attempt to use FXSAVE or FXRSTOR with a VEX prefix should produce a #UD (InvalidOpcode) exception. If either the TS or EM flag bits in CR0 are set, a #NM (device-notavailable) exception will be raised instead of #UD exception.  	  Due to this erratum a #NM exception may be signaled instead of a #UD exception on an FXSAVE or an FXRSTOR with a VEX prefix.  	 Software should not use FXSAVE or FXRSTOR with the VEX prefix. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VPEXTRD/VPINSRD  	  Execution of the VPEXTRD or VPINSRD instructions outside of 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions outside 64-bit mode.  	 Software should encode VEX.W = 0 for executions of the VPEXTRD and VPINSRD instructions outside 64-bit mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions  	  When a 2-byte opcode of a conditional branch (opcodes 0F8xH, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid VEX prefix, it may sometimes signal a #GP fault (illegal instruction length > 15-bytes) instead of a #UD (illegal opcode) fault.  	  Due to this erratum, #GP fault instead of a #UD may be signaled on an illegal instruction.  	 None identified.  27   	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTM or BTS Records May have Incorrect Branch From Information After an EIST/T-state/S-state/C1E Transition or Adaptive Thermal Throttling  	  The “From” address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after a transition of: • EIST (Enhanced Intel® SpeedStep Technology) • T-state (Thermal Monitor states) • S1-state (ACPI package sleep state) • C1E (Enhanced C1 Low Power state) • Adaptive Thermal Throttling  	  When the LBRs, BTM or BTS are enabled, some records may have incorrect branch “From” addresses for the first branch after a transition of EIST, T-states, S-states, C1E, or Adaptive Thermal Throttling.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to the IA32_FIXED_CTR1 MSR May Result in Incorrect Value in Certain Conditions  	  Under specific internal conditions, if software tries to write the IA32_FIXED_CTR1 MSR (30AH) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (i.e. its value was 0xFFFF FFFF FFFF), then due to this erratum the new value in the MSR may be corrupted.  	  Due to this erratum, IA32_FIXED_CTR1 MSR may be written with a corrupted value.  	 Software may avoid this erratum by writing zeros to the IA32_FIXED_CTR1 MSR, before the desired write operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  L1 Data Cache Errors May be Logged With Level Set to 1 Instead of 0  	  When an L1 Data Cache error is logged in IA32_MCi_STATUS[15:0], which is the MCA Error Code Field, with a cache error type of the format 0000 0001 RRRR TTLL, the LL field may be incorrectly encoded as 01b instead of 00b.  	  An error in the L1 Data Cache may report the same LL value as the L2 Cache. Software should not assume that an LL value of 01b is the L2 Cache.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI RdPkgConfig() May Return Invalid Data For an Unsupported Channel  	  The processor's PECI facility can report the current temperature of each of the DIMMs on a specified channel (PECI RdPkgConfig command, index 14H, DIMM_Temperature_Read). Valid channel numbers range from 0 to 3. Channel numbers outside of the valid range should be detected and flagged. Due to this erratum, meaningless values are returned without an error flag when 4 is specified as the channel number.  	  Using channel 4 with the PECI RdPkgConfig DIMM_Temperature_Read command does not return an error flag.  	 None identified.   28  	  For the affected steppings, see the Summary Tables of Changes. 
  VM Entries That Return From SMM Using VMLAUNCH May Not Update The Launch State of the VMCS  	  Successful VM entries using the VMLAUNCH instruction should set the launch state of the VMCS to “launched”. Due to this erratum, such a VM entry may not update the launch state of the current VMCS if the VM entry is returning from SMM.  	  Subsequent VM entries using the VMRESUME instruction with this VMCS will fail. RFLAGS.ZF is set to 1 and the value 5 (indicating VMRESUME with non-launched VMCS) is stored in the VM-instruction error field. This erratum applies only if dual monitor treatment of SMI and SMM is active.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Interrupt From Local APIC Timer May Not Be Detectable While Being Delivered  	  If the local-APIC timer’s CCR (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the LVT timer register and then reading the bit in the IRR (interrupt-request register) corresponding to the vector in the LVT timer register. If both values are read as 0, no timer interrupt should be in the process of being delivered. Due to this erratum, a timer interrupt may be delivered even if the CCR is 0 and the LVT and IRR bits are read as 0. This can occur only if the DCR (Divide Configuration Register) is greater than or equal to 4. The erratum does not occur if software writes zero to the Initial Count Register before reading the LVT and IRR bits.  	  Software that relies on reads of the LVT and IRR bits to determine whether a timer interrupt is being delivered may not operate properly.  	 Software that uses the local-APIC timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading CCR and the LVT and IRR bits; alternatively, software can avoid the problem by writing zero to the Initial Count Register before reading the LVT and IRR bits. 	  For the steppings affected, see the Summary Tables of Changes. 
  End Agent PCIe* Packet Errors May Result in a System Hang  	  PCIe agents are required by the PCIe Base Specification to identify and report packet errors. Due to this erratum, certain invalid completion types from the end agent are not correctly handled by the processor.  	  If a PCIe end agent issues certain invalid completion types, the system may hang.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Poison Packets Will be Reported to PCIe* Port 1a When Forwarded to Port 1b  	  With respect to data poisoning, the processor IIO module supports forwarding poisoned information between the coherent interface and PCIe and vice-versa. Also the processor IIO module supports forwarding poisoned data between peer PCIe ports. When the PCIe Ports 1a and 1b are configured as x4, the outbound Poison Error is reported on Port 1a when a poison packet is forwarded to Port 1b.  	  When Ports 1a and 1b are configured as x4 ports, Poison Errors reported on the root port are unreliable.  	 None identified. 	  29  For the steppings affected, see the Summary Tables of Changes.  
  IA32_MCi_ADDR Overwritten in The Case of Multiple Recoverable Instruction Fetch Errors  	  The instruction fetch machine check error (MCACOD 0x150) is a SRAR (Software Recoverable Action Required) error. The address of the location with the error is provided in the corresponding IA32_MCi_ADDR MSR. When multiple instruction fetch errors are logged as part of a single machine check event, as indicated by setting of the Overflow (bit 62) in the IA32_MCi_STATUS MSR, then recovery is not possible. Due to this erratum, when multiple instruction fetch errors are logged in the same bank, the IA32_MCi_MISC MSR contains all of the correct information including the proper setting for Overflow (bit 62); however, the IA32_MCi_ADDR MSR is overwritten with a value that corresponds to neither the first or second error.  	  When debugging failures associated with the instruction fetch machine check error and the Overflow bit is set, the value in IA32_MCi_ADDR will not be valid.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Link May Not Train to Full Width  	  During PCIe link training, the receiver looks at symbols in the TS1 and TS2 Ordered Sets as indicators of lane polarity inversion. If polarity inversion is detected, the receiver must invert those lane(s). Due to this erratum, the receiver may incorrectly set polarity inversion.  	  PCIe links may not train to full width.  	 None identified. Perform a Secondary Bus Reset on the link up to three times to achieve full width. 	  For the affected steppings, see the Summary Tables of Changes. 
  Spurious SMIs May Occur Due to MEMHOT# Assertion  	  The IMC (Integrated Memory Controller) can be programmed to generate an SMI (System Management Interrupt) on an internal MEMHOT# event assertion through the MHOT_SMI_EN field (MH_MAINCNTL Bus: 1; Device: 15; Function: 0; Offset: 104H; bit[17]) or on assertion of the external MEMHOT[1:0]#pin though the MHOT_EXT_SMI_EN field (MH_MAINCNTL Bus: 1; Device: 15; Function: 0; Offset: 104H; bit[18]). Due to this erratum, a spurious SMI may be generated every 500uS if both internal and external MEMHOT events are enabled simultaneously.  	  Due to this erratum, excessive SMI generation may occur.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  The PCIe* Current Compensation Value Default is Incorrect  	  The default current compensation values for PCIe buffers may result in non-optimal performance.  	  The PCIe buffers will not perform as well as possible and performance could be compromised.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The PCIe* Link at 8.0 GT/s is Transitioning Too Soon to Normal Operation While Training  	  The PCIe bus uses high speed serial links that must go through a training process to allow both transmitter and receiver to make adjustments in behavior to optimize the   30  signaling between the transmitter and receiver. When a PCIe compliant device must train or retrain the link, training sequences are used. The device must allow enough time for the training to complete before transitioning to normal operation. In the case of PCIe equalization at 8.0 GT/s the processor is not allowing enough time to optimize signaling before attempting normal operation. 	  Due to this erratum, unexpected system behavior may be observed.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A First Level Data Cache Parity Error May Result in Unexpected Behavior  	  When a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior.  	  Due to this erratum unpredictable system behavior may occur. Intel has not observed this erratum with any commercially available system.  	 None identified. 	 
  For the steppings affected, see the Summary Tables of Changes.  PECI Write Requests That Require a Retry Will Always Time Out  	  PECI 3.0 introduces a ‘Host Identification’ field as a way for the PECI host device to identify itself to the PECI client. This is intended for use in future PECI systems that may support more than one PECI originator. Since PECI 3.0 systems do not support the use of multiple originators, PECI 3.0 host devices should zero out the unused Host ID field. PECI 3.0 also introduces a ‘retry’ bit as a way for the PECI host to indicate to the client that the current request is a ‘retry’ of a previous read or write operation. Unless the PECI 3.0 host device zeroes out the byte containing the ‘Host ID & Retry bit’ information, PECI write requests that require a retry will never complete successfully.  	  PECI write requests that require a retry may never complete successfully. Instead, they will return a timeout completion code of 81H for a period ranging from 1ms to 30ms if the ‘RETRY’ bit is asserted.  	 PECI 3.0 host devices should zero out the byte that contains the Host ID and Retry bit information for all PECI requests at all times including retries. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Vswing of the PCIe* Transmitter Exceeds The Specification  	  The PCIe Specification defines a limit for the Vswing (Voltage Swing) of the differential lines that make up a lane to be 1200 mV peak-to-peak when operating at 2.5 GT/s and 5 GT/s. Intel has found that the processor’s PCIe transmitter may exceed this specification. Peak-to-peak swings on a limited number of samples have been observed up to 1450 mV.  	  For those taking direct measurements of the PCIe transmit traffic coming from the processor may detect that the Vswing exceeds the PCIe Specification. Intel has not observed any functional failures due to this erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  When a Link is Degraded on a Port due to PCIe* Signaling Issues Correctable Receiver Errors May be Reported on The Neighboring Port  	  PCI Express interface incorporates a recovery mechanism when certain link degradation occurs by retraining the link without impacting the pending transactions. When a link is degraded on a specific port due to PCIe signaling issues, it is possible  31   that correctable receiver errors are reported on the neighboring (logically adjacent) port. The correctable receiver errors are indicated by the PCIe AER Correctable error bit (XPGLBERRSTS CPUBUS(0); Device 0-3; Function 0-3; Offset 230H; Bit 2). 	  Software that logs errors on the PCIe interface must be aware that errors detected on a specific port could be due to either an error on that specific port or on a neighboring port.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A CMCI is Only Generated When the Memory Controller’s Correctable Error Count Threshold is Exceeded  	  A CMCI (corrected machine-check error interrupt) should be generated when the number of corrected errors for a bank reaches the corrected error threshold programmed into the IA32_MCi_CTL2 bits [14:0]. For memory scrubbing errors, IA32_MCi_STATUS.MCACOD (bits [15:0]) with value of 000x_0000_1100_xxxx (where x stands for zero or one), a CMCI will not be generated until the number of errors has exceeded the threshold in IA32_MCi_CTL2 by 1.  	  The CMCI will not be generated when expected but rather will be generated on the next corrected error for the bank.  	 It is possible for BIOS to contain a workaround for this issue. It should be noted that with this workaround if the threshold is programmed to a value of 0, a read of the value will return 1 and the threshold will be 1. All other valid threshold values for the bank will be read back correctly and function as expected. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Rx DC Common Mode Impedance is Not Meeting the Specification  	  When the PCIe Rx termination is not powered, the DC Common Mode impedance has the following requirement: ≥10 kΩ over 0-200 mV range with respect to ground and ≥20 kΩ for voltages ≥200 mV with respect to ground. The processor’s PCIe Rx do not meet this requirement at 85 degrees C or greater. In a limited number of samples Intel has measured an impedance as low as 9.85 kΩ at 50mV.  	  Intel has not observed any functional impact due to this violation with any commercially available system.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Modification to the Multiple Message Enable Field Does Not Affect The AER Interrupt Message Number field  	  The (Advanced Error Interrupt) Message Number field (RPERRSTS Devices 0-3; Functions 0-3; Offset 178H; bits[31:27]) should be updated when the number of messages allocated to the root port is changed by writing the Multiple Message Enable field (MSIMSGCTL Device 3; Function 0; Offset 62H; bits[6:4]). However, writing the Multiple Message Enable in the root port does not update the Advanced Error Interrupt Message Number field.  	  Due to this erratum, software can allocate only one MSI (Message Signaled Interrupt) to the root port.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   32 
  Unexpected PCIe* Set_Slot_Power_Limit Message on Writes to LNKCON  	  The processor sends the PCIe Set_Slot_Power_Limit message on writes to the Slot Capabilities (SLTCAP Devices 0-3; Functions 0-3; Offset A4H) register. Due to this erratum, the processor also sends PCIe the Set_Slot_Power_Limit message on writes to the LNKCON (CPUBUS(0); Devices 0-3; Functions 0-3; Offset A0H) register.  	  For those monitoring the PCIe* traffic going across the link, the unexpected PCIe Set_Slot_Power_Limit Message will be detected whenever a write to the LNKCON register occurs. Intel has not observed any functional failures due to this erratum on any commercially available system.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Link Bandwidth Notification Capability is Incorrect  	  A value of 1 in the Link_Bandwidth_Notification_Capability field (LKNCAP bit 21) for a PCIe device indicates support for the Link Bandwidth Notification status and interrupt mechanisms. Due to this erratum, this field for ports 2c, 2d, 3c and 3d (LKNCAP Bus 0; Device 2,3; Function 2,3; Offset 09Ch; bit 21) always reads as 0 when it should read as 1.  	  Software that reads this field for the listed ports will incorrectly conclude that the Link Bandwidth Notification status and interrupt mechanisms are not available.  	 Software should ignore the value of the Link_Bandwidth_Notification_Capability field for ports 2c, 2d, 3c, and 3d. 	  For the affected steppings, see the Summary Tables of Changes. 
  Locked Accesses Spanning Cachelines That Include PCI Space May Lead to a System Hang  	  A locked memory access which splits across a cacheline boundary that suffers a master abort on a PCI bus may lead to a system hang.  	  Aborted split lock accesses may cause PCI devices to become inoperable until a platform reset. Intel has not observed this erratum with commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Cold Boot May Fail Due to Internal Timer Error  	  The processors may not complete a cold boot (i.e. a boot from a power-off state) due to an internal timer error machine check, IA32_MCi_STATUS.MCACOD of 0000_0100_0000_0000. This will result in the processor asserting IERR (Internal Error).  	  The processor may signal IERR during a cold boot when the system is initializing.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Rx Common Mode Return Loss is Not Meeting The Specification  	  The PCIe Specification requires that the Rx Common Mode Return Loss in the range of 0.05 to 2.5 GHz must be limited to -6 dB. The processor’s PCIe Rx do not meet this requirement. The PCIe Rx Common Mode Return at 500MHz has been found to be between -3.5 and -4 dB on a limited number of samples.  	  Intel has not observed any functional failures due to this erratum with any commercially available PCIe devices.  33   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Most Significant Bit of the CEC Cannot be Cleared Once Set  	  The most significant bit of the CEC (Corrected Error Count IA32_MCi_STATUS (i=1219), bit 52) cannot be cleared once it has been set.  	  In the case that software attempts to clear the CEC and the count exceeds 3FFFH, software will read incorrect CEC values on subsequent accesses and additional CMCIs (Corrected Machine Check Error Interrupts) will not be generated.  	 None identified. Software can avoid this erratum by setting corrected error threshold to a value less than 3FFFH, enable CMCI and clearing the error count before it exceeds 3FFFH. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Adaptive Equalization May Not Train to the Optimal Settings  	  In the case of the PCIe equalization procedure for 8 GT/s, the Downstream Port’s (e.g. the processor’s) TXEQ (transmitter equalization settings) can be fine tuned for each Lane during a process called Adaptive Equalization Phase 3. Due to this erratum, the processor may not direct the end-agent to the optimal TXEQ settings.  	  The PCIe link may not be as robust as possible potentially leading to a higher bit error rate than expected.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Core May Not Complete Transactions to The Caching Agent When CStates Are Enabled Leading to an Internal Timer Error  	  When multiple cores have outstanding transactions targeted to a single caching agent and one of the cores enters a Core C-state before completing the transaction with the targeted caching agent an internal timer machine check error may occur (IA32_MCi_STATUS.MCACOD of 0000_0100_0000_0000).  	  Due to this erratum, the processor may experience an internal timer error.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  TSC is Not Affected by Warm Reset  	  The TSC (Time Stamp Counter MSR 10H) should be cleared on reset. Due to this erratum the TSC is not affected by warm reset.  	  The TSC is not cleared by a warm reset. The TSC is cleared by power-on reset as expected. Intel has not observed any functional failures due to this erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Warm Resets May be Converted to Power-on Resets When Recovering From an IERR  	  When a warm reset is attempted and an IERR (Internal Error) happens as indicated by the IA32_MCi_STATUS.MCACOD of 0000_0100_0000_0000, a power-on reset occurs instead.  	  The values in the machine check bank will be lost as a result of the power-on reset. This prevents a OS, BIOS or the BMC (Baseboard Management Controller) from logging the content of the error registers or taking any post-reset actions that are dependent on the machine check information.   34  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Port 3a Capability_Pointer Field is Incorrect When Configured in PCIe* Mode  	  The Capability_Pointer field (CAPPTR Bus 0; Device 3; Function 0; Offset 34H; bits [7:0]) should have its value based on the configured mode of the port, PCIe or NTB (Non-Transparent Bridge). Due to this erratum, this field reports the NTB value (60H) when in PCIe mode instead of the PCIe value (40H).  	  Software depending on the value of this field may not behave as expected.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  Processor May not Restore the VR12 DDR3 Voltage Regulator Phases upon Pkg C3 State Exit  	  During the Pkg (Package) C3 state entry, the processor directs the VR12 DDR3 voltage regulators to shed phases to reduce power consumption. Due to this erratum, the processor may not restore all VR12 DDR3 voltage regulator phases upon Pkg C3 state exit. The VR12 DDR3 voltage regulators require all phases to keep the DDR3 voltage plane in tolerance for proper memory subsystem functioning during normal system operation.  	  Due to this erratum, unpredictable system behavior may occur.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Equalization Phase Successful Bits Are Not Compliant to The PCIe* Specification  	  PCIe Specification states that if the Phase 1 of Transmitter Equalization completes successfully as indicated by the LNKSTS2.Equalization Phase 1 Successful (Devices 03; Functions 0-3; bit[2]) bit being set to one and if the Phase 2 and 3 link training phases are bypassed, the LNKSTS2.Equalization Phase 3 Successful (Devices 0-3; Functions 0-3; bit[4]) and LNKSTS2.Equalization Phase 2 Successful (bit[3]) bits should be set to one. Due to this erratum, the processor will only set the Equalization Phase 2 or 3 Successful bits if the phases are completed successfully.  	  Due to this erratum, Equalization Phase 2 and 3 Successful bits may not be set. Intel has not observed any functional failure with commercially available PCIe devices.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Four Outstanding PCIe* Configuration Retries May Cause Deadlock  	  PCIe configuration retries are allowed for older generation PCI/PCI-X bridges that take a long time to respond to configuration cycles after a reset. Due to this erratum, a fifth configuration cycle following the fourth PCIe configuration retry may not make progress, resulting in a deadlock.  	  A deadlock could occur. Intel has not observed this erratum with any commercially available system.  	 When configuring devices on PCI/PCI-X buses, BIOS should wait for configuration cycles to complete before issuing subsequent configuration cycles. 	  35  For the affected steppings, see the Summary Tables of Changes.  
  A PECI RdPciConfigLocal Command Referencing a Non-Existent Device May Return an Unexpected Value  	  Configuration reads to non-existent PCI configuration registers should return 0FFFF_FFFFH. Due to this erratum, when the PECI RdPciConfigLocal command references a non-existent PCI configuration register, the value 0000_0000H may be returned instead of the expected 0FFFF_FFFFH.  	  A PECI RdPciConfigLocal command referencing a non-existent device may observe a return value of 0000_0000H. Software expecting a return value of 0FFFF_FFFFH to identify non-existent devices may not work as expected.  	 Software that performs enumeration via the PECI "RdPciConfigLocal" command should interpret 0FFFF_FFFFH and 0000_0000H values for the Vendor Identification and Device Identification Register as indicating a non-existent device. 	  For the affected steppings, see the Summary Tables of Changes. 
  Some PCIe* CCR Values Are Incorrect  	  The CCR (Class Code Register) value for the following devices should be 088000H instead is 000000H: • Bus 0; Device 6; Function 1-7; Offset 09H; bits [23:0] • Bus 0; Device 7; Function 0-4; Offset 09H; bits [23:0]  	  Due to this erratum, the CCR base and sub-class status of the listed PCIe devices is incorrectly reported and may cause software to conclude that these devices are host bridges and are not general system peripherals.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  When in DMI Mode, Port 0's Device_Port_Type Field is Incorrect  	  When in DMI mode, the Device_Port_Type field (PXPCAP Bus 0; Device 0; Function 0; Offset 92H; bits [7:4]) should read as 9H (DMI mode) but incorrectly reads as 4H (PCIe* mode).  	  Software may incorrectly conclude that this port is operating in PCIe mode when it is actually being used in the DMI mode.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  PCIe* TPH Attributes May Result in Unpredictable System Behavior  	  TPH (Transactions Processing Hints) are optional aids to optimize internal processing of PCIe transactions. Due to this erratum, certain transactions with TPH attributes may be misdirected, resulting in unpredictable system behavior.  	  Use of the TPH feature may affect system stability.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  Correctable Memory Errors May Result in Unpredictable System Behavior  	  Under certain conditions, the processor may not detect or correct a correctable memory error.  	  When this erratum occurs, it may result in unpredictable system behavior.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum.   36  	  For the affected steppings, see the Summary Tables of Changes. 
  Enabling Opportunistic Self-Refresh and Pkg C2 State Can Severely Degrade PCIe Bandwidth  	  Due to this erratum, enabling opportunistic self-refresh can lead to the memory controller over-aggressively transitioning DRAM to self-refresh mode when the processor is in Pkg C2 state.  	  The PCIe* interface peak bandwidth can be degraded by as much as 90%.  	 A BIOS workaround has been identified. Please refer to the latest version of the BIOS Spec Update and release notes. 	  For the affected steppings, see the Summary Tables of Changes. 
  Mirrored Memory Writes May Lead to System Failures  	  In mirrored memory mode, each channel manages its memory write bandwidth resources. Due to this erratum, if a channel in mirrored memory mode is heavily utilized, it is possible for issued writes to exceed available bandwidth resulting in write failures.  	  A system hang or unpredictable system behavior may occur.  Intel® Romley Platform CPU/QPI/Memory Reference Code version 1.0.006 or later and release notes. 	NA	  For the affected steppings, see the Summary Tables of Changes. 
  IA32_MCi_STATUS ADDRV Bit May be Incorrectly Cleared  	  The IA32_MCi_STATUS MSR's ADDRV bit (bit 58) is set upon logging an error in order to indicate that the contents of the IA32_MCi_ADDR MSR is valid. Due to this erratum, a cancelled speculative load of poisoned data spanning a cacheline boundary can clear the ADDRV flag associated with a previously logged error report.  	  The clearing of the ADDRV flag in IA32_MCi_STATUS when this erratum occurs will result in the loss of the address logged in a correctable error report. It should be noted that a cancelled speculative load of poisoned data that crosses a cacheline boundary is an unusual occurrence.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Malformed TLP Power Management Messages May Be Dropped  	  The PCIe* Base Specification requires Power Management Messages to use the default Traffic Class designator, TC0, and receivers to check for violations of this rule. Due to this erratum, a TLP using a non-default Traffic Class designator will be dropped, rather than handled as a Malformed TLP.  	  An Advanced Error Reporting ERR_FATAL notification will not be logged for Malformed TLP Power Management Messages.  	 None identified 	  For the affected steppings, see the Summary Tables of Changes. 
  Core Frequencies at or Below the DRAM DDR Frequency May Result in Unpredictable System Behavior  	  The Intel® SpeedStep® Technology can dynamically adjust the core operating frequency to as low as 1200 MHz. Due to this erratum, under complex conditions and when the cores are operating at or below the DRAM DDR frequency, unpredictable system behavior may result.  37   	  Systems using Intel SpeedStep Technology with DDR3-1333 or DDR3-1600 memory devices are subject to unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
  	 	NA	NA	NA
 to be executed following the counter overflow. Due to this erratum, if the counter	NA	NA	NA	NA
 delayed by one instruction.  	NA	 	NA	NA
 delayed by one instruction following execution of MOV SS or STI. The state information	NA	NA	NA	NA
  	NA	NA	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause Machine Check if Page Size and Memory Type Was Changed Without Invalidation  	  This erratum may cause a machine-check error (IA32_MCi_STATUS.MCACOD=0150H) on the fetch of an instruction that crosses a 4-KByte address boundary. It applies only if (1) the 4-KByte linear region on which the instruction begins is originally translated using a 4-KByte page with the WB memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-MByte, 4-MByte, or 1GByte) with the UC memory type; and (3) the instruction fetch occurs after the pagingstructure modification but before software invalidates any TLB entries for the linear region.  	  Due to this erratum an unexpected machine check with error code 0150H may occur, possibly resulting in a shutdown. Intel has not observed this erratum with any commercially available software.  	 Software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. It can instead use the following algorithm: first clear the P flag in the relevant paging-structure entry (e.g., PDE); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the P flag and establish the new page size and memory type. 	  For the steppings affected, see the Summary Tables of Changes. 
  Quad Rank DIMMs May Not be Properly Refreshed During IBT_OFF Mode  	  The Integrated Memory Controller incorporates a power savings mode known as IBT_OFF (Input Buffer Termination disabled). Due to this erratum, Quad Rank DIMMs may not be properly refreshed during IBT_OFF mode.  	  Use of IBT_OFF mode with Quad Rank DIMMs may result in unpredictable system behavior.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  The VT-d Queued Invalidation Status Write May Fail  	  Intel® Virtualization Technology for Directed I/O (Intel® VT-d) queued invalidation operations issue a status write to modify a semaphore. Due to this erratum, the status write may fail.   38  	  When using queued invalidation operations, a failed status write can result in unpredictable system behavior.  	 If operating without queued invalidations, interrupt re-mapping, and X2APIC features is feasible, then VT-d invalidations should be performed using the VT-d register facility (c.f., VTD0_CTXCMD [offset 028h], VTD1_CTXCMD [offset 1028h], VTD0_INVADDRREG [offset 0200h] and VTD0_IOTLBINV [offset 0208h], VTD1_INVADDRREG [offset 1200h] and VTD1_IOTLBINV [offset 1208h] in the VT-d register region with a base address specified through the VTBAR register at 0:5:0, offset 0180h). If those operational limitations are not feasible, disable VT-d through BIOS facilities. This will prevent the use of Intel VT-d, including X2APIC and TXT facilities that are dependent on Intel VT-d. 	  For the affected steppings, see the Summary Tables of Changes. 
  Executing The GETSEC Instruction While Throttling May Result in a Processor Hang  	  If the processor throttles due to either high temperature thermal conditions or due to an explicit operating system throttling request (TT1) while executing GETSEC[SENTER] or GETSEC[SEXIT] instructions, then under certain circumstances, the processor may hang. Intel has not been observed this erratum with any commercially available software.  	  Possible hang during execution of GETSEC instruction.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Platform Idle Power Higher May be Higher Than Expected  	  The processor may not place the associated DRAM subsystem in the lowest allowed power state during Package C3 and Package C6 states. This may cause the platform idle power to be higher than expected.  	  Platform average power and idle power may be higher than expected.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI Transactions during an S-State Transition May Result in a Platform Cold Reset  	  Due to this erratum, a PECI transaction during an S-state transition may result in an unexpected platform cold reset rather than an S-state transition.  	  Use of PECI transactions during an S-state transition can result in a platform reset that terminates transitioning to the desired S-state.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Complex Platform Conditions during a Transition to S4 or S5 State May Result in an Internal Timeout Error  	  Due to this erratum, the BIOS sequencing associated with S4 (sometimes known as “Hibernate”) and S5 (also known as “Soft Off”), when undertaken with certain complex platform conditions, can result in an internal timeout error as indicated by IA32_MCi_STATUS.MCACOD of 0000_0100_0000_0000 and IERR assertion. This internal timeout error stops the platform S-state sequencing before platform power down occurs. Certain platforms may have logic that, upon detection of the failure to reach power down, initiates a cold reset sequence.  	  S4 state or S5 state may not be reliably entered; the platform may not reach the very low power condition.  	 It is possible for the BIOS to contain a workaround for this erratum.  39   	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring May Overcount Some Events During Debugging  	  If the debug-control register (DR7) is configured so that some but not all of the breakpoints in the debug-address registers (DR0-DR3) are enabled and one or more of the following performance-monitoring counters are locally enabled (via IA32_CR_PERMON_EVNTSEL_CNTR{3:0}): BR_INST_RETIRED BR_MISP_RETIRED FP_ASSIST FP_ASSIST INST_RETIRED MACHINE_CLEARS MEM_LOAD_UOPS_LLC_HIT_RETIRED MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS MEM_LOAD_UOPS_RETIRED MEM_TRANS_RETIRED MEM_UOPS_RETIRED OTHER_ASSISTS ROB_MISC_EVENTS.LBR_INSERTS UOPS_RETIRED Any of the globally enabled (via IA32_CR_EMON_PERF_GLOBAL_CTRL) counters may overcount certain events when a disabled breakpoint condition is met.  	  Performance-monitor counters may indicate a number greater than the number of events that occurred.  	 Software can disable all breakpoints by clearing DR7. Alternatively, software can ensure that, for a breakpoint disabled in DR7, the corresponding debug-address register contains an address that prevents the breakpoint condition from being met (e.g., a non-canonical address). 	  For the steppings affected, see the Summary Tables of Changes. 
  HDRLOG Registers do not Report the Header for PCIe* Port 1 Packets with Detected Errors  	  The HDRLOG registers contain the header information of the first PCIe packet detected that contains errors. Because of this erratum, the Port 1 (IOU2) HDRLOG registers (CPUBUS(0), Device 1, Function 0; Offsets 164H, 168H, 16CH, 170H) do not reflect the header of a packet with a detected error.  	  The HDRLOG registers cannot be used to debug the receipt of packets with detected errors on Port 1.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI Temperature Data Values Returned During Reset May be NonZero  	  The processor PECI power-up time line presented in the Intel® Core™ i7 Processor Family for the LGA-2011 Socket Datasheet - Volume 1 & Volume 2 defines the value returned by the PECI GetTemp() command as 0x0000 – the maximum value – during the ‘Data Not Ready’ (DNR) phase (starting approximately 100 μS after PWRGOOD assertion and lasting until approximately 500 µS after RESET de-assertion). Due to this erratum, the GetTemp() command returns a small negative number during the DNR phase.   40  	  The temperature reported during the PECI DNR phase may be below the maximum and therefore may not have the intended effect of causing platform fans to operate at full speed until the actual processor temperature becomes available.  	 Processor thermal management solutions utilizing PECI should operate platform fans at full speed during the PECI DNR phase. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI Temperature Lower Limit May be as High as 7°C  	  PECI reports temperatures as an offset from the PROCHOT threshold (a negative value when the temperature is below the PROCHOT threshold, zero when at or above that threshold). If the temperature is below 0°C, PECI responds with an "Invalid Temperature" encoding (8002H). Due to this erratum, PECI may indicate an invalid temperature when the actual temperature is as high as 7°C.  	  An invalid temperature report from PECI indicates the actual temperature is 7°C or lower. Platform facilities depending PECI to provide accurate temperature readings between 0°C and 7°C may not function correctly.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  TSOD Related SMBus Transactions May Not Complete When Package C-States are Enabled  	  The processor may not complete SMBus (System Management Bus) transactions targeting the TSOD (Temperature Sensor On DIMM) when Package C-States are enabled. Due to this erratum, if the processor transitions into a Package C-State while an SMBus transaction with the TSOD is in process, the processor will suspend receipt of the transaction. The transaction completes while the processor is in a Package C-State. Upon exiting Package C-State, the processor will attempt to resume the SMBus transaction, detect a protocol violation, and log an error.  	  When Package C-States are enabled, the SMBus communication error rate between the processor and the TSOD may be higher than expected.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The DRAM Power Meter May Not be Accurate  	  The DRAM Power Meter uses VR (Voltage Regulator) current readings in combination with weighted activity counters to provide a running estimate of DRAM subsystem power. Due to this erratum, the DRAM Power Meter may not be sufficiently accurate for system power management purposes.  	  The DRAM Power Meter cannot be relied upon to provide accurate DRAM subsystem power measurements. Reduced or variable system performance may be a side effect.  	 It is possible for BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  The Processor Incorrectly Transitions from Polling.Active to Polling.Compliance After Receiving Two TS1 Ordered Sets with the Compliance Bit Set  	  The processor PCIe* interface incorrectly transitions from the Polling.Active Link state to the Polling.Compliance Link state after receiving two TS1 Ordered Sets with the Compliance Bit set instead of the eight TS1 Ordered Sets required by the specification.  	  It is possible that the PCIe link may enter Polling.Compliance Link state unexpectedly. Exposure to this erratum requires bit errors on the Compliance Receive bit (Byte 5, Bit 4) on sequential TS1 ordered sets.  41   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Functionally Benign PCIe* Electrical Specification Violation Compendium  	  Violations of PCIe electrical specifications listed in the table below have been observed. Specification  Violation Description  De-emphasis ratio limit: -3.5±0.5 dB  Ave: -3.8 dB, Min: -4.09 dB  At 5 GT/s operation, the receiver must tolerate AC common mode voltage of 300 mV (Peak-toPeak) and must tolerate 78.1 ps jitter  Simultaneous worst case AC common mode voltage and worst case jitter during 5 GT/s operation may result in intermittent failures leading to subsequent recovery events  TTX-UPW-TJ (uncorrelated total pulse width jitter) maximum of 24ps  Samples have measured as high as 25ps  The Transmitter PLL bandwidth and peaking for PCIe at 5 GT/s is either 8-16 MHz with 3 dB of peaking or 5-16 MHz with 1 dB of peaking  Samples have measured 7.8-16 MHz with 1.3 dB of peaking  During the LTSSM Receiver Detect State, common-mode resistance to ground is 40-60 ohms.  Samples have measured up to 100 ohms.  8 GT/s Receiver Stressed Eye  Samples marginally pass or fail the 10-12 BER target under stressed eye conditions  8 GT/s PLL Bandwidth: 2 to 4 MHz with 2 dB peaking.  Samples have a measured bandwidth of up to 4.1 MHz  	  Intel has not observed failures from the violations listed in this erratum on any commercially available platforms and/or using commercially available PCIe devices.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Shallow Self-Refresh Mode is Used During S3  	  The processor should be instructing DRAM to utilize deep self-refresh at entry into the S3 state. Due to this erratum, the processor is instructing the DRAM to use shallow self-refresh upon entry into the S3 state.  	  The power dissipation of the DRAMs will be greater than expected during S3 state.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Machine Check Exception Due to Instruction Fetch May Be Delivered Before an Instruction Breakpoint  	  Debug exceptions due to instruction breakpoints take priority over exceptions resulting from fetching an instruction. Due to this erratum, a machine check exception resulting from the fetch of an instruction may take priority over an instruction breakpoint if the instruction crosses a 32-byte boundary and the second part of the instruction is in a 32-byte poisoned instruction fetch block.  	  Instruction breakpoints may not operate as expected in the presence of a poisoned instruction fetch block.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes.   42 
  A PECI RdIAMSR Command Near IERR Assertion May Cause the PECI Interface to Become Unresponsive  	  When a PECI RdIAMSR command is issued to the processor near the time that the processor is experiencing an internal timeout error, as indicated by IA32_MCi_STATUS.MCACOD of 0000_0100_0000_0000 and IERR assertion, the PECI interface may issue an 81H (timeout) response. After a timeout response, the processor will ignore future PECI commands until it is reset.  	  Due to this erratum, PECI commands typically used to debug a processor that is not behaving normally – RdPkgConfig and RdPciConfig – may not be available after an internal time out error.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Long Latency Transactions Can Cause I/O Devices on the Same Link to Time Out  	  Certain long latency transactions – e.g., master aborts on inbound traffic, locked transactions, peer-to-peer transactions, or vendor defined messages – conveyed over the PCIe* and DMI2 interfaces can block the progress of subsequent transactions for extended periods. In certain cases, these delays may lead to I/O device timeout that can result in device error reports and/or device off-lining.  	  Due to this erratum, devices that generate PCIe or DMI2 traffic characterized by long latencies can interfere with other traffic types on the same link. This may result in reduced I/O performance and device timeout errors. USB traffic can be particularly sensitive to these delays.  	 Avoid the contributing conditions. This can be accomplished by separating traffic types to be conveyed on different links and/or reducing or eliminating long latency transactions. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Coherent Interface Error Code "DA" is Always Flagged  	  The Coherent Interface Error Status Registers (IRPP0ERRST and IRPP1ERRST at CPUBUS(0), Device 5, Function 2, Offsets 230H and 2B0H respectively) indicate that an error has been detected by the Coherent Interface. Bit 13 of the IRPP0ERRST and IRPP1ERRST registers indicate that a Protocol Queue/Table Overflow or Underflow (DA) error has occurred. Due to this erratum, the processor always logs the DA error flag.  	  The DA error flag is indeterminate.  	 Mask off the DA error flag (bit 13) of the IRPP0ERRCTL and IRPP1ERRCTL registers at CPUBUS(0), Device 5, Function 2, Offsets 234H and 2B4H respectively. 	  For the steppings affected, see the Summary Tables of Changes. 
  If Multiple Poison Events Are Detected Within Two Core Clocks, The Overflow Flag May Not be Set  	  If multiple poison events are detected within two core clocks, the error is logged with an IA32_MCi_STATUS.MCACOD of 0000_0001_0011_0100 but the IA32_MCi_STATUS.OVER (bit [60]) may not be set.  	  Due to this erratum, only one poison event may be reported by a logical processor when more than one poison event was encountered.  	 None identified. 	  43  For the steppings affected, see the Summary Tables of Changes.  
  PCI Express* Capability Structure Not Fully Implemented  	  According to the PCIe Base Specification, “The PCI Express Capability structure is required for all PCI Express device functions”. Due to this erratum, some PCI Express Capabilities Fields were not implemented (“Device Capability”, “Device Status” and “Device Control”) for CPUBUS[0], Device 5, Function 2, reads to these fields will return zero.  	  Software that depends on the PCI Express Capability Structure fields Device Capability, Device Status and/or Device Control will not operate properly.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The PCIe* Receiver Lanes Surge Protection Circuit May Intermittently Cause a False Receive Detection on Some PCIe Devices  	  The processor implements a surge protection circuit on the PCIe receiver lanes. Due to this erratum, during platform power-on some PCIe devices may trigger the surge protection circuit causing a false receive detect. If this unexpected detection occurs before the processor’s PCIe lane termination impedances are enabled and the resulting PCIe device link training enters the link training Polling.Active state, the PCIe device may incorrectly transition into the Polling.Compliance state.  	  After platform power-on, some PCIe devices may not exit from the compliance state causing the link to fail to train or the link may train to a degraded width.  	 It is possible for BIOS to contain a workaround for this erratum. Please refer to memory reference code version 0.8.301 or later with release notes, the latest version of the Intel® Server Platform Services Release (SPS_02.01.05.012.0 or later) with release notes, and the latest version of the Intel® Management Engine Firmware 7.1 Release 1 (7.1.20.1128 or later) with release notes. 	  For the steppings affected, see the Summary Tables of Changes. 
  Software Reads From LMMIOH_LIMIT Register May be Incorrect  	  The MMIOH is a memory-mapped I/O region relocatable above 4 GB. Due to this erratum, software reads of the LMMIOH_LIMIT register (Local MMIO High Base, Device: 5, Function: 0, Offset 118H) may yield incorrect results, although software writes to this register function as expected.  	  Software depending on LMMIOH_LIMIT register reads may not behave as expected. Intel has not identified any commercially available software that is affected by the erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel SpeedStep® Technology May Cause a System Hang  	  Intel SpeedStep® Technology dynamically changes core operating frequencies. Due to this erratum, under complex conditions, core frequency changes may result in a system hang.  	  Intel SpeedStep Technology may cause a system hang.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  NTB May Incorrectly Set MSI or MSI-X Interrupt Pending Bits  	  The NTB (Non-transparent Bridge) may incorrectly set MSI (Message Signaled Interrupt) pending bits in MSIPENDING (BAR PB01BASE,SB01BASE; Offset 74H) while operating in MSI-X mode or set MSI-X pending bits in PMSIXPBA (BAR PB01BASE, SB01BASE; Offset 03000H) while operating in MSI mode.   44  	  Due to this erratum, NTB incorrectly sets MSI or MSI-X pending bits. The correct pending bits are also set and it is safe to ignore the incorrectly set bits.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Spurious Power Limit Interrupt May Occur at Package C-State Exit  	  The processor monitors power consumption and uses that information to limit core operating frequency. Due to this erratum, power consumption may be improperly calculated by the processor during Package C-states. As a result, the processor may incorrectly signal a power limit interrupt.  	  In response to a power limit interrupt, the OS may choose to operate the processor at its minimum frequency for several milliseconds after the Package C-state exit.  	 None identified. The OS can mask these interrupts by setting the Power Limit Interrupt Enable field (bit 24) in the IA32_THERM_INTERRUPT MSR (19BH) to 0. 	  For the affected steppings, see the Summary Tables of Changes. 
  Using I/O Peer-to-Peer Write Traffic Across an NTB May Lead to a Hang  	  If two systems are connected via an NTB (Non-Transparent Bridge), either the internal NTB or an external NTB, and both systems attempt to send I/O peer-to-peer write traffic across the NTB either to memory or an I/O device on the remote system, it is possible for both systems to deadlock.  	  Due to this erratum, using I/O peer-to-peer write traffic across an NTB may lead to a hang.  	 A BIOS workaround has been identified. Please refer to the latest version of the BIOS spec update and release notes. However, the work-around could lead to periods of low performance due to starvation of PCIe traffic as it allows the arbiter to grant access to another device if the current granted device is blocked by resource limits of its intended target, rather than wait until the current winner has sent at least one transaction. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR May Contain Incorrect Information When Using FREEZE_LBRS_ON_PMI  	  When FREEZE_LBRS_ON_PMI is enabled (bit 11 of IA32_DEBUGCTL MSR (1D9H) is set), and a taken branch retires at the same time that a PMI (Performance Monitor Interrupt) occurs, then under certain internal conditions the record at the top of the LBR stack may contain an incorrect "From" address.  	 	NA	NA
 of the LBR stack may be incorrect.  	NA	NA	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PROCHOT May Be Incorrectly Asserted at Reset  	  The PROCHOT signal is used to indicate elevated processor temperatures during normal operation and is used for FRB (Fault Resilient Boot) actions during the reset sequence. Due to this erratum, the elevated temperature indication usage of PROCHOT can persist into reset and subsequently can cause improper FRB actions.  	  Elevated die temperatures at reset time may impair platform operation.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  45  For the affected steppings, see the Summary Tables of Changes.  
  Programming PDIR And an Additional Precise PerfMon Event May	NA	NA	NA	NA
  	  PDIR (Precise Distribution for Instructions Retired) mechanism is activated by programming INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1. When	NA	NA	NA
  	NA	 	NA	NA
 	NA	NA	NA	NA
 mechanism. 	NA	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in an operating system which may run 16-bit FP code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR or XSAVE/XRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the FXSAVE or XSAVE image or a partial memory state restore of the FXRSTOR or XRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR or XSAVE/XRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.   46  	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for VEX.vvvv May Produce a #NM Exception  	  The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (InvalidOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to this erratum, if CR0.TS is "1", the processor may instead produce a #NM (Device-NotAvailable) exception.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should always set the vvvv field of the VEX prefix to 1111b for instances of the VAESIMC and VAESKEYGENASSIST instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI Commands Differing Only in Length Field May be Interpreted as Command Retries  	  Due to this erratum, the processor interprets any PECI read or write command that accesses the processor, a downstream PCI device, or package configuration space and differs from the preceding request only in the length field as a retry request. That is, a retry will be inferred by the processor even if the read length and write length fields don’t match between two consecutive requests, regardless of the state of the host retry bit on the succeeding request.  	  Back-to-back PECI commands that are identical with the exception of the length field may yield incorrect results if processor retry completion codes are ignored by the PECI host.  	 PECI hosts should retry timed-out commands until they complete successfully by reissuing a PECI command sequence identical to the originally timed-out command. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits from Real-Address Mode Due to Machine-Check Exceptions May Incorrectly Save RFLAGS.RF as 1  	  If a machine check is encountered while fetching an instruction, and if the resulting machine-check exception causes a VM exit, the VM exit should save an RFLAGS value in the guest-state area of the VMCS with the RF value that existed at the time of the machine check. Due to this erratum, such VM exits that occur in real-address mode may save RFLAGS.RF as 1 even if it had been 0.  	  The processor may fail to report an instruction breakpoint following a return to realaddress mode via VM entry.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Rank Sparing May Cause an Extended System Stall  	  The Integrated Memory Controller sequencing during a rank sparing copy operation blocks all writes to the memory region associated with the rank being taken out of service. Due to this erratum, this block can result in a system stall that persists until the sparing copy operation completes.  	  The system can stall at unpredictable times which may be observed as one time instance of system unavailability.  	 A BIOS workaround has been identified. Please refer to Intel® Romley Platform CPU/ QPI/Memory Reference Code version 1.0.006 or later and release notes.  47   	  For the affected steppings, see the Summary Tables of Changes. 
  The Integrated Memory Controller Does Not Enforce CKE High for tXSDLL DCLKs After Self-Refresh  	  The JEDEC STANDARD DDR3 SDRAM Specification (No. 79-3E) requires that the CKE signal be held high for tXSDLL DCLKs after exiting self-refresh before issuing commands that require a locked DLL (Delay-Locked Loop). Due to this erratum, the Integrated Memory Controller may not meet this requirement with 512Mb, 1Gb, and 2Gb devices in single rank per channel configurations.  	  Violating tXSDLL may result in DIMM clocking issues and may lead to unpredictable system behavior.  	 A BIOS workaround has been identified. Please refer to the Intel® Romley Platform CPU/QPI/Memory Reference Code(RC), version 0.8.0 or later. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Default Value of the More I/O Base Address Field Does Not Comply with the PCI-to-PCI Bridge Architecture Specification  	  The PCI-to-PCI Bridge Architecture Specification defines the default value of the More I/O Base Address Field (IOBAS CPUBUS(0); Device 0-3; Function 0-3; Offset 1Ch; bits [3:2]) to 0. Due to this erratum, the processor’s default value is 3.  	  It is possible that system software will generate an error due to this erratum.  	 A BIOS workaround has been identified. Please refer to the latest version of the Intel® Xeon® Processor E5-1600/2400/2600/4600 Product Families BIOS Specification Update. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Sustained Series of PCIe Posted Upstream Writes Can Lead to Deadlock  	  Due to this erratum, a sustained series of PCIe posted upstream writes to the same cache line, with no other access of that same cache line, may cause a deadlock.  	  Under a complex set of conditions, a sustained series of PCIe posted upstream writes targeting the same cache line can lead to deadlock. Intel has not been observed this erratum with any commercially available system.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Extraneous Characters Are Included in the Processor Brand String  	  The Processor Brand String is provided by the CPUID instruction for leaf values EAX=80000002H, 80000003H, and 80000004H. Each execution of the three CPUID leaf value returns 16 ASCII bytes of the Processor Brand String in the EAX, EBX, ECX, and EDX registers. Due to this erratum, an extra zero character (“0”, 30H ASCII code) and space character (“ “, 20H ASCII code) are inserted after the processor number in the brand string output. In the following example brand string, the extraneous characters are underlined: “Intel® Xeon® CPU E5-2680 0 @ 2.70 GHz”.  	  An extraneous “0” and “space” character are included in the Processor Brand String.  	 The extraneous characters may be ignored or removed by software. 	  For the steppings affected, see the Summary Tables of Changes. 
  IMC Controlled Dynamic DRAM Refresh Rate Can Lead to Unpredictable System Behavior  	  DRAMs require a 2x refresh rate when operating above 85°C. Due to this erratum, the IMC (Integrated Memory Controller) logic intended to double the refresh rate when   48  DRAM temperature exceeds 85°C can cause DRAM access failures, leading to unpredictable system behavior. 	  The IMC is not able to dynamically adjust the DRAM refresh rate based on DRAM temperature. If DRAMs may be operated above 85°C then BIOS must configure the IMC for a doubled refresh rate.  	 A BIOS workaround has been identified. Please refer to the Intel® Romley Platform CPU/QPI/Memory Reference Code (RC), Version 0.9.000 or later and release notes. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Error Address Status May Get Logged  	  When a correctable Machine Check event with a valid address precedes an uncorrectable Machine Check event without a valid address, the IA32_MCi_STATUS OVER flag (bit 62) should be set and ADDRV flag (bit 58) should be cleared. Due to this erratum, both flags may be set.  	  The Machine Check report logged may incorrectly indicate valid address information when the OVER flag is set.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Machine Check Threshold-Based Error Status Indication May be Incorrect  	  A corrected cache hierarchy data or tag error is reported in IA32_MCi_STATUS.MCACOD (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one). An error status indication (bits [54:53]) value of 10B indicates that the corrected error count has exceeded the yellow threshold. Due to this erratum, subsequent corrections after the yellow indication has been set may change the error status indication to green (bits [54:53] equal to 00B).  	  The threshold-based error status indication is unreliable.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MCi_STATUS Registers May Contain Undefined Data After Reset  	  Due to this erratum, if the RESET_N signal is asserted while the processor is in a Package C State the IA32_MCi_STATUS registers may contain undefined data after the processor completes the reset. In particular, the IA32_MCi_STATUS.VAL (bit[63]) may be set incorrectly indicating a valid Machine Check has been logged.  	  Invalid errors may be reported in the IA32_MCi_STATUS registers.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Refresh Cycles for High Capacity DIMMs Are Not Staggered  	  Certain high capacity DIMMs, typically Quad Rank RDIMMs and LR-DIMMs, may exceed instantaneous and short-term power limits if refresh cycles are not correctly staggered. Due to this erratum, the Integrated Memory Controller is unable to stagger refresh cycles.  	  Some DIMMs may exceed power limits during refresh operations leading to unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  49  For the steppings affected, see the Summary Tables of Changes.  
  A Stream of Snoops Can Lead to a System Hang or Machine Check  	  Due to this erratum, a stream of snoop requests to a single cache slice may cause the processor in that slice to livelock, resulting in a system hang or Internal Timer Error machine check indicated by IA32_MCI_STATUS.MCACOD (bits 15:0, 0000 0100 0000 0000).  	  A system hang or machine check may occur. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Value in IA32_MC3_ADDR MSR May Not be Accurate When MCACOD 0119H is Reported in IA32_MC3_Status  	  Under certain conditions, when the The Machine Check Error Code (MCACOD) in the IA32_MC3_STATUS (MSR 040DH) register is 0119H, the value in IA32_MC3_ADDR MSR (40EH) may refer to the incoming MLC (Mid-Level Cache) cache line instead of the evicted cache line.  	  The address in IA32_MC3_ADDR MSR (40EH) may not be accurate for MLC cache read errors with MSCOD of 119H.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MCi_STATUS.EN May Not be Set During Certain Machine Check Exceptions  	  Due to this erratum, IA32_MCi_STATUS.EN may not be set as expected after the MLC (Mid-Level Cache) has logged a fatal error with a MCACOD value of 000X_0001_XXXX_XX10 (where X stands for zero or one) and signaled an MCE (Machine Check Error) as a result of encountering poisoned data.  	  The value of IA32_MCi_STATUS.EN may be inconsistent with signaling an MCE while logging a fatal error, however a machine check exception is still signaled.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  LLC Cache Correctable Errors Are Not Counted And Logged  	  LLC Cache correctable errors are logged in the Corrected_Error_Count field bits [53:38] of the IA32_MC[19:12]_STATUS MSR. Due to this erratum, LLC Cache corrections are not counted and logged.  	  Software using the corrected error count may not function correctly. A CMCI (corrected machine check error interrupt) may not be generated when the error threshold programmed in IA32_CR_MC[19:12]_CTL2.ERROR_THRESHOLD (bits [14:0]) would otherwise be expected to be met.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor Incorrectly Transitions From The PCIe* Recovery.RcvrLock LTSSM State to the Configuration.Linkwidth.Start LTSSM State  	  When a PCIe link is operating at 2.5 GT/s and the processor’s LTSSM (Link Training and Status State Machine) is in Recovery.RcvrLock state, the processor expects to receive TS1 ordered sets within 24 ms. If it does not receive the TS1s in the allotted time, the LTSSM should transition to the Detect state. Due to this erratum, if the processor does not receive TS1s within 24ms, it will transition to Configuration.LinkWidth.Start. In that   50  state, if it receives no TS1s, it will transition to Detect. If it receives TS1s, it will configure the link appropriately and return to L0. 	  The state transition sequence from the Recovery.RcvrLock LTSSM state to the Configuration.Linkwidth.Start LTSSM state is in violation of the PCIe Specification. Intel has not observed any functional failures due to this erratum with any commercially available PCIe devices.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Precise Instruction Retired Event May Present Wrong Indications  	  When the PDIR (Precise Distribution for Instructions Retired) mechanism is activated	NA	NA	NA
 values if the counter is reset with a SAV below 100 (Sample-After-Value is the counter reset value software programs in MSR IA32_PMC1[47:0] in order to control interrupt frequency).  	NA	 	NA	NA
 or PMI interrupts and/or an invalid counter state.  	NA	NA	 The sampling driver should avoid using SAV<100. 	  For the steppings affected, see the Summary Tables of Changes. 
  XSAVEOPT May Fail to Save Some State after Transitions Into or Out of STM  	  The XSAVEOPT instruction may optimize performance by not saving state that has not been modified since the last execution of XRSTOR. This optimization should occur only if the executions of XSAVEOPT and XRSTOR are either both or neither in SMM (systemmanagement mode). Due to this erratum, this optimization may be performed by the first execution of XSAVEOPT after a transition into or out of the STM (SMM-transfer monitor) if the most recent execution of XRSTOR occurred before that transition. For transitions into the STM, the erratum applies only to transitions using the VMCALL instruction. This erratum can occur only if the two executions are at the same privilege level, use the same linear address, and are either both or neither in VMX non-root operation. The erratum does not apply if software in SMM never uses XRSTOR or XSAVEOPT.  	  This erratum may lead to unpredictable system behavior.  	 STM software should execute the XRSTOR instruction with the value 0 in EDX:EAX after each transition into the STM (after setting CR4.OSXSAVE) and before each transition out of the STM. Bytes 512 to 575 of the save area used by XRSTOR should be allocated in memory, but bytes 0 to 511 need not be. Bytes 512 to 535 should all be 0. 	  For the steppings affected, see the Summary Tables of Changes. 
  Error Indication in PCIe* Lane Error Status Incorrectly Set When Operating at 8 GT/s  	  The Lane Error Status field in bits[15:0] of LNERRSTS (Device 1; Function 0,1; Offset 258H; and Device 2,3; Function 0,1,2,3; Offset 258H) is used to monitor errors on the PCIe lanes. Due to this erratum, the LNERRSTS bits associated with the lanes operating at 8 GT/s port are spuriously set.  	  LNERRSTS cannot be used to reliably monitor errors on the PCIe lanes operating at 8 GT/s.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  51  For the affected steppings, see the Summary Tables of Changes.  
  The Minimum Snoop Latency Requirement That Can be Specified is 64 Microseconds  	  The PCIE_ILTR_OVRD CSR (Device 10; Function 1; Offset 78H) and SW_LTR_OVRD MSR (0A02H) include fields defined to allow specification of a required maximum snoop latency threshold. That maximum latency is intended to be used by the processor to adjust various operational parameters so that the latency requirement can be met. Due to this erratum, the minimum latency value that can be specified via the Snoop Latency Multiplier field (bits[28:26]) and the Snoop Latency Value field (bits[25:16]) is 64 microseconds.  	  A minimum snoop latency requirement of 64 microseconds is so long that these registers are not useful.  	 None identified. BIOS and the OS have other means to specify Package C-state exit latency maximums, which is the typical use model for setting PCIe* snoop latency limits. 	  For the affected steppings, see the Summary Tables of Changes. 
  A Machine Check May Result in an Unexpected Value in ECX  	  A machine check during execution of a REP MOVSB instruction may result in an unexpected value in ECX.  	  A machine check during execution of a REP MOVSB may result in an unexpected behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  System Hang May Occur when Memory Sparing is Enabled  	  Due to this erratum, enabling memory sparing can result in an internal timer error as indicated by the IA32_MCi_STATUS.MCACOD of 0000_0100_0000_0000.  	  Enabling memory sparing may result in a system may hang.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  End Agent PCIe* Packet Errors May Result in a System Hang  	  PCIe agents are required by the PCIe Base Specification to identify and report packet errors. Due to this erratum, certain invalid completion types from the end agent are not correctly handled by the processor.  	  If a PCIe end agent issues certain invalid completion types, the system may hang.  	 None identified 	  For the affected steppings, see the Summary Tables of Changes. 
  Retraining Cannot be Initiated by Downstream Devices in NTB/NTB or NTB/RP Configurations  	  The PCIe* Base Specification requires that a downstream device can initiate link retraining. Due to this erratum, link retraining cannot be initiated by the downstream device in a NTB/NTB (Non-Transparent Bridge) or a NTB/RP (Root Port) configuration.  	  The Retrain_Link field (LNKCON Device 3; Function 0; Offset 1A0H; bit [5]) does not function as expected in the identified configurations; software referencing the downstream device is not able to retrain the link.  	 The link speed and training must be managed by the upstream host in NTB/NTB or NTB/RP configurations. 	  For the affected steppings, see the Summary Tables of Changes.   52 
  PCIe* Port in NTB Mode Flags Upstream Slot Power Limit Message as UR  	  When the processor is in NTB (Non-Transparent Bridge) mode, it should ignore upstream Slot Power Limit messages from the root port it is connected to. Due to this erratum, the processor generates UR (Unsupported Request) on these Slot Power Limit messages when in NTB mode.  	  Due to this erratum, some messages will be improperly flagged with UR.  	 Upstream Slot Power Limit Message should be disabled in the identified configurations. 	  For the affected steppings, see the Summary Tables of Changes. 
  When in DMI Mode, Port 0’s Device_Port_Type Field is Incorrect  	  When in DMI mode, the Device_Port_Type field (PXPCAP Bus 0; Device 0; Function 0; Offset 92H; bits [7:4]) should read as 9H (DMI mode) but incorrectly reads as 4H (PCIe mode).  	  Software may incorrectly conclude that this port is operating in PCIe mode when it is actually being used in the DMI mode.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  PCIe* TPH Attributes May Result in Unpredictable System Behavior  	  TPH (Transactions Processing Hints) are optional aids to optimize internal processing of PCIe transactions. Due to this erratum, certain transactions with TPH attributes may be misdirected, resulting in unpredictable system behavior.  	  Use of the TPH feature may affect system stability.  	 A BIOS workaround has been identified. Please refer to Intel® Romley Platform CPU/ QPI/Memory Reference Code version 1.0.006 or later and release notes. 	  For the affected steppings, see the Summary Tables of Changes. 
  PCIe* Lane Reversal is Not Supported on All x8 Configurations During REUT Mode  	  PCIe lane reversal is not supported for Port 2 and Port 6 x8 configurations during REUT (Robust Electrical Unified Testing) mode.  	  Platforms that require REUT mode lane reversal for x8 Port 2 or Port 6 will not function per the PCIe Base Specification.  	 None identified. Avoid designing platforms implementing lane reversal for x8 Port 2 and x8 Port 6 if REUT operation is needed. 	  For the affected steppings, see the Summary Tables of Changes. 
  PCIe* Port 3 Link Training May be Unreliable in NTB Mode  	  If PCIe port 3 is in NTB (Non-Transparent Bridge) mode and both the Root port and Endpoint Hardware Autonomous Speed Disable fields (LNKCON2 Bus 0; Device 3; Function 0; Offset 0C0H; bit 5) are set to 0, link training may fail. The Recovery.RcvrLock state may intermittently timeout and transition to the Detect state.  	  The NTB port link training may be unreliable.  	 A BIOS workaround has been identified. Please refer to Intel® Romley Platform CPU/ QPI/Memory Reference Code version 1.0.006 or later and release notes 	  53  For the affected steppings, see the Summary Tables of Changes.  
  A Machine-Check Exception Due to Instruction Fetch May Be Delivered Before an Instruction Breakpoint  	  Debug exceptions due to instruction breakpoints take priority over exceptions resulting from fetching an instruction. Due to this erratum, a machine-check exception resulting from the fetch of an instruction may take priority over an instruction breakpoint if the instruction crosses a 32-byte boundary and the second part of the instruction is in a 32-byte poisoned instruction fetch block.  	  Instruction breakpoints may not operate as expected in the presence of a poisoned instruction fetch block.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Intel® SpeedStep® Technology May Cause a System Hang  	  Intel SpeedStep Technology dynamically changes core operating frequencies. Due to this erratum, under complex conditions, core frequency changes may result in a system hang.  	  Intel SpeedStep Technology may cause a system hang.  	 It is possible for the BIOS to contain a workaround for this erratum 	  For the affected steppings, see the Summary Tables of Changes. 
  The Accumulated Energy Status Read Service May Report a Power Spike Early in Boot  	  The PECI RdPkgConfig() command with an index value of 03H is the Accumulated Energy Status Read service. During platform boot, the Accumulated Energy Status Read service returns an accumulated energy value of 0. Later in the boot flow, due to this erratum, the Accumulated Energy Status Read service returns a value that is large. Energy values calculated with the first non-zero sample have been observed to be as high as 10kJ over a limited number of parts.  	  Software may interpret values returned by the Accumulated Energy Status Read service during boot time as indicating a large power spike. This could lead to unexpected or undesired platform power management actions.  	 Once the first non-zero value is detected, the difference between subsequent sequential values is a reliable measure of energy consumed between the sample points. 	  For the affected steppings, see the Summary Tables of Changes. 
  Certain Uncorrectable Errors May Cause Loss of PECI Functionality  	  A PECI completion code of 91H indicates the PCU (Power Control Unit) detected an uncorrectable error that prevented processing of the PECI request. Due to this erratum, certain PCU or VRM error conditions may lead to a persistent 91H completion code for subsequent PECI request. Uncorrectable PCU errors are reported with an IA32_MC4_STATUS.MCACOD (MSR 411H, bits[15:0]) value of 0000_0100_0000_0010, IA32_MC4_STATUS.VALID (bit 63) set to 1, and IA32_MC4_STATUS.UC (bit 61) set to 1.  	  PECI processing may be blocked until either a cold reset or software running on one of the cores clears the IA32_MC4_STATUS register.  	 None identified. Software running on one of the cores can clear the IA32_MC4_STATUS register to restore PECI functionality. 	  For the affected steppings, see the Summary Tables of Changes. 
  Machine Check During VM Exit May Result in VMX Abort  	  A machine check signaled during VM exit should cause a VMX abort only if the machine check would prevent successful completion of the VM exit; ordinarily, the machine   54  check should be delivered after the VM exit completes. Due to this erratum, certain machine checks (e.g., an uncorrectable cache error detected by another logical processor) may force a VM exit to result in a VMX abort even when that machine check does not interfere with the VM exit completing correctly. 	  Certain machine checks that could be reported in the host context for orderly logging and analysis may instead induce a VMX abort and shut down the logical processor.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  Routing Intel® High Definition Audio Traffic Through VC1 May Result in System Hang  	  When bit 9 in the IIOMISCCTRL CSR (Bus 0; Device 5; Function 0; Offset 1C0H) is set, VCp inbound traffic (Intel® HD Audio) is routed through VC1 to optimize isochronous traffic performance. Due to this erratum, VC1 may not have sufficient bandwidth for all traffic routed through it; overflows may occur.  	 This erratum can result in lost completions that may cause a system hang. 	 A BIOS workaround has been identified. Please refer to the latest version of the BIOS Spec Update, Intel® Romley Platform CPU/QPI/Memory Reference Code version 1.0.006 or later and release notes. 	  For the affected steppings, see the Summary Tables of Changes. 
  Package_Energy_Counter Register May Incorrectly Report Power Consumed by The Execution of Intel® AVX instructions  	  The processor includes a Package_Energy_Counter register to provide real-time energy consumption information. This facility can be accessed by the PECI RdPkgConfig() command with an index value of 03H (the Accumulated Energy Status Read service), by reading the PKG_ENERGY_STATUS MSR (611H) or by reading PACKAGE_ENERGY_STATUS CSR (Bus 1; Device 10; Function 0; Offset 90H). Due to this erratum, the power consumption reported during the execution of Intel AVX instructions is inaccurate.  	  Software that uses the Package_Energy_Counter register value during the execution of Intel AVX instructions may not behave as expected, possibly compromising thermal load balancing, processor throttling, or other platform management operations. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  Coherent Interface Write Cache May Report False Correctable ECC Errors During Cold Reset  	  The Integrated I/O’s coherent interface write cache includes ECC logic to detect errors. Due to this erratum, the write cache can report false ECC errors. This error is signaled by asserting bit 1 (Write Cache Corrected ECC) in the IRPP0ERRST CSR (Bus 0; Device 5; Function 2; Offset 230H) or the IRPP1ERRST CSR (Bus 0; Device 5; Function 2; Offset 2B0H).  	  If the coherent interface write cache ECC is enabled, the processor may incorrectly indicate correctable ECC errors in the write cache. 	 A BIOS workaround has been identified. Please refer to Intel® Romley Platform CPU/ QPI/Memory Reference Code version 1.0.006 or later and release notes 	  55  For the affected steppings, see the Summary Tables of Changes.  
  PCIe* RO May Result in a System Hang or Unpredictable System Behavior  	  PCIe RO (Relaxed Ordering) is not supported on this processor. Due to this erratum, enabling RO or, equivalently, not disabling RO throughout the Integrated I/O logic may lead to unpredictable system behavior or a system hang.  	 Enabling RO for any port or channel may lead to system instability. 	 A BIOS workaround has been identified. Please refer to Intel® Romley Platform CPU/ QPI/Memory Reference Code version 1.0.013 or later and release notes. 	  For the affected steppings, see the Summary Tables of Changes. 
  VT-d Invalidation Time-Out Error May Not be Signaled  	  Intel® VT-d (Virtualization Technology for Directed I/O) utilizes ITags to identify ATS (Address Translation Services) invalidation requests for invalidating Device-TLBs on endpoint devices. When an ATS invalidation response time-out is detected, the corresponding ITag is freed and an Invalidation Time-out Error is signaled through the VT-d Fault Status register. Due to this erratum, an ATS invalidation response timeout is detected and reported only for the first outstanding ITag entry.  	  As a result of the erratum, the ATS invalidation response timeout condition may not be reliably reported when multiple invalidation requests are outstanding. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Enhanced Intel SpeedStep® Technology Hardware Coordination Cannot be Disabled  	  The processor should permit hardware coordination of Enhanced SpeedStep Technology requests to be disabled (then use the most recent P-state request from any core or logical processor to set the processor-wide P-state target). Due to this erratum, the Enhanced Intel SpeedStep Technology Hardware Coordination Disable value in bit 0 of the MISC_PWR_MGMT MSR (1AAH) is ignored; hardware coordination is always enabled.  	 It is not possible to prevent hardware P-state coordination. 	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  PCIe* Link Upconfigure Capability is Incorrectly Advertised as Supported  	  The processor does not allow PCIe devices to dynamically change link width but, due to this erratum, the PCIe* Link Upconfigure Capability bit is incorrectly advertised as supported.  	  When a downstream device attempts to dynamically change the link’s width, the link may not correctly retrain, resulting in an incorrect link width, reversed lane numbers, or Surprise Link Down (SLD). 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  The IA32_MCi_MISC.HaDbBank Field Should be Ignored  	  Home Agent parity errors, logged in IA32_MCi_STATUS.MCACOD (bits[15:0]) with a value of 0000_0000_1000_xxxx, may return an incorrect value in IA32_MCi_MISC.HaDbBank (bits[31:30]).  	  When analyzing Machine Check Register Bank contents, the IA32_MCi_MISC.HaDbBank field should be ignored.   56  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  When a PCIe* x4 Port Detects a Logical Lane 0 Failure, the Link Will Advertise Incorrect Lane Numbers  	  The PCIe interface incorporates a recovery mechanism for link degradation by retraining the link without affecting pending transactions. When a x4 port detects a lane failure on logical lane 0, the link degrades from x4 to x2 and lane reversal occurs. Due to this erratum, after degrading to x2 and reversing the lanes, the link will incorrectly advertise lane numbers as “PAD 0 1 0” instead of the correct “PAD PAD 1 0”.  	  Devices that have the ability to negotiate a link with logical lane 0 on a mid physical lane may fail to successfully train the link. 	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Certain PCIe* TLPs May be Dropped  	  A PCIe TLP (Transaction Layer Packet) header can specify the request alignment (via byte enables), include TPH (Transaction Processing Hints), and request address translation via the AT field. Due to this erratum, a TLP with non-zero byte enables (i.e., not DWORD-aligned) that includes a non-zero TPH and with an AT field of “01” may be dropped.  	  Under the conditions noted, a PCIe TLP may be dropped, causing unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 Platforms must ensure that TPH and address translation requests are not used in the same TLP. The most direct means is to disable TPH in a PCIe device that may request an address translation. This can be accomplished by ensuring that TPH Requester Control Register (at offset 08H in the device’s TPH Requester Capability structure) bits [9:8] are zero. 	  For the affected steppings, see the Summary Tables of Changes. 
  A Machine Check Exception Concurrent With an I/O SMI May Be Erroneously Reported as Restartable  	  A machine check exception that is delivered between the execution of an I/O instruction (IN, INS, OUT, or OUTS) and an SMI (system-management interrupt) triggered by that instruction may prevent proper handling of the SMI; because of this, the machine check exception should not be reported as restartable. Due to this erratum, such a machine check exception may be reported as restartable.  	 	  A restartable machine check exception on an I/O instruction concurrent with a resulting SMI may result in unpredictable system behavior. It is possible for the BIOS to contain a workaround for this erratum.  	  For the affected steppings, see the Summary Tables of Changes. 
  VEX.L is Not Ignored with VCVT*2SI Instructions  	  The VEX.L bit should be ignored for the VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions, however due to this erratum the VEX.L bit is not ignored and will cause a #UD.  	 	  Unexpected #UDs will be seen when the VEX.L bit is set to 1 with VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions. Software should ensure that the VEX.L bit is set to 0 for all scalar instructions.  	  For the affected steppings, see the Summary Tables of Changes.  57  
  The System Agent Temperature is Not Available  	  Due to this erratum, the processor does not record the temperature of the System Agent in the Temperature field in bits [7:0] of the SA_TEMPERATURE CSR (Device 10; Function 2; Offset: 044h).  	  Firmware cannot read the temperature of the System Agent via accessing the SA_TEMPERATURE CSR. None Identified. The System Agent temperature is available via PECI RdPkgConfig Command service, parameter value 00FFh.  	 	  For the affected steppings, see the Summary Tables of Changes. 
  The PCIe* Link at 8.0 GT/s is Transitioning Too Soon to Normal Operation While Training  	  The PCIe bus uses high speed serial links that must go through a training process to allow both transmitter and receiver to make adjustments in behavior to optimize the signaling between the transmitter and receiver. When a PCIe compliant device must train or retrain the link, training sequences are used. The device must allow enough time for the training to complete before transitioning to normal operation. In the case of PCIe equalization at 8.0 GT/s the processor is not allowing enough time to optimize signaling before attempting normal operation.  	 	  Due to this erratum, unexpected system behavior may be observed. A BIOS code change has been identified and may be implemented as a workaround for this erratum.  	  For the affected steppings, see the Summary Tables of Changes. 
  An ACM Error May Cause a System Power Down  	  An Intel® TXT (Trusted Executed Technology) enabled system that detects an ACM (Authenticated Code Module) error should perform a warm reset then start-up in nontrusted mode. Due to this erratum, an ACM error may cause the system to power down.  	  The system may unexpectedly power down.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  Incorrect Retry Packets May Be Sent by a PCIe* x16 Port Operating at 8 GT/s  	  A PCIe x16 port operating at 8 GT/s transmitting 256 byte Completion TLPs may not replay TLPs correctly.  	  Due to this erratum, unpredictable system behavior may result when a 256 byte Completion TLP is replayed on a PCIe x16 port operating at 8 GT/s.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the affected steppings, see the Summary Tables of Changes. 
  The Coherent Interface Error Codes "C2", "C3", “DA” and "DB" are Incorrectly Flagged  	  The Coherent Interface Error Status Registers (IRPP0ERRST and IRPP1ERRST at CPUBUS(0), Device 5, Function 2, Offsets 230H and 2B0H respectively) indicate that an error has been detected by the Coherent Interface.Bit 3 indicates that a Write Cache Un-correctable ECC (C2) error has occurred.Bit 4 indicates that a CSR access crossing 32-bit boundary (C3) error has occurred.Bit 13 indicates that a Protocol Queue/Table Overflow or Underflow (DA) error has occurred.Bit 14 indicates that a Protocol Parity   58  Error (DB) error has occurred.Due to this erratum, the processor may incorrectly log the "C2", "C3", “DA” and "DB" error flags. 	  The "C2", "C3", “DA” and "DB" error flags are indeterminate.  	 Mask off the "C2", "C3", “DA” and "DB" error flags (bit 3, bit 4, bit 13 and bit 14) of the IRPP0ERRCTL and IRPP1ERRCTL registers at CPUBUS(0), Device 5, Function 2, Offsets 234H and 2B4H respectively 	  For the affected steppings, see the Summary Tables of Changes. 
  MCI_ADDR May be Incorrect For Cache Parity Errors  	  In cases when a WBINVD instruction evicts a line containing an address or data parity error (MCACOD of 0x124, and MSCOD of 0x10), the address of this error should be logged in the MCi_ADDR register. Due to this erratum, the logged address may be incorrect, even though MCi_Status.ADDRV (bit 63) is set.  	  The address reported in MCi_ADDR may not be correct for cases of a parity error found during WBINVD execution.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Intel® QuickData DMA Channel Write Abort Errors May Cause a Channel Hang  	  When the “Fence” bit in the base descriptor Control field is set, the DMA engine assures all data for that operation (and previous operations) has been written before considering a transfer complete and beginning to process the next chained base descriptor. In addition, upon completion of a transfer, the DMA engine can notify software of the completion via either an interrupt, a memory write to a programmed location, or both. Due to this erratum, the DMA engine, while processing chained DMA descriptors with fencing or interrupt completion enabled, may hang and not enter the HALT state as expected if a write error that results in an abort occurs.  	  A DMA transfer that suffers a write abort error when fencing or interrupt completion is enabled may hang.  	 Do not enable fencing bit [4] or interrupt completion bit [0] in the Descriptor Control Field. 	  For the affected steppings, see the Summary Tables of Changes. 
  The Processor May Not Properly Execute Code Modified Using A Floating-Point Store  	  Under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.  	  Self- or cross-modifying code may not execute as expected. Intel has not observed this erratum with any commercially available software.  	 None identified. Do not use floating-point stores to modify code. 	  For the affected steppings, see the Summary Tables of Changes. 
  Execution of GETSEC[SEXIT] May Cause a Debug Exception to be Lost  	  A debug exception occuring at the same time that GETSEC[SEXIT] is executed or when an SEXIT doorbell event is serviced may be lost.  	  Due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of GETSEC[SEXIT]. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  59  For the affected steppings, see the Summary Tables of Changes.  
  VM Exits Due to GETSEC May Save an Incorrect Value for “Blocking by STI” in the Context of Probe-Mode Redirection  	  The GETSEC instruction causes a VM exit when executed in VMX non-root operation. Such a VM exit should set bit 0 in the interruptibility-state field in the virtual-machine control structure (VMCS) if the STI instruction was blocking interrupts at the time GETSEC commenced execution. Due to this erratum, a VM exit executed in VMX non-root operation may erroneously clear bit 0 if redirection to probe mode occurs on the GETSEC instruction.  	  After returning from probe mode, a virtual interrupt may be incorrectly delivered prior to GETSEC instruction. Intel has not observed this erratum with any commercially software.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Warm Reset May Cause PCIe* Hot-Plug to Fail  	  The Integrated I/O unit uses the VPP (Virtual Pin Port) to communicate with devices that interface to the switches and LEDs associated with PCIe Hot-Plug sequencing. Due to this erratum, VPP operation stalls when a warm reset occurs and then experiences delayed reset. Depending on timing alignment with the warm reset event, a VPP transaction in progress around the time of a warm reset may suffer an extended stall or an immediate termination.  	  Hot-Plug sequencing may suffer failures during or shortly after warm resets which may be temporary or persist until the next cold reset.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  Certain Local Memory Read / Load Retired PerfMon Events May Undercount  	  Due to this erratum, the Local Memory Read / Load Retired PerfMon events listed below may undercount.  MEM_LOAD_UOPS_RETIRED.LLC_HIT MEM_LOAD_UOPS_RETIRED.LLC_MISS* MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_MISS MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HIT MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HITM MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_NONE MEM_LOAD_UOPS_LLC_MISS_RETIRED.LOCAL_DRAM* MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_DRAM* MEM_TRANS_RETIRED.LOAD_LATENCY* 	  The affected events may undercount, resulting in inaccurate memory profiles. The undercount of these events can be partially resolved (but not eliminated) by setting	NA	NA
 events marked with an asterisk, set the Direct-to-core disable field (Bus 1; Device 14; Function 0; Offset 84; bit 1) to 1 for Local memory reads and (Bus 1; Device 8; Function 0; Offset 80; bit 1) to 1 and (Bus 1; Device 9; Function 0; Offset 80; bit 1) to 1 for Remote memory reads. The improved accuracy comes at the cost of a reduction in performance; this workaround generally should not be used during normal operation.  	NA	NA	 None identified.   60  	  For the affected steppings, see the Summary Tables of Changes. 
  Performance Monitor Counters May Produce Incorrect Results  	  When operating in hyper-threaded mode, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled counter on the physical core’s other thread rather than the thread experiencing the event.  The list of affected memory at-retirement events is as follows: MEM_UOP_RETIRED.LOADS MEM_UOP_RETIRED.STORES MEM_UOP_RETIRED.LOCK MEM_UOP_RETIRED.SPLIT MEM_UOP_RETIRED.STLB_MISS MEM_LOAD_UOPS_RETIRED.HIT_LFB MEM_LOAD_UOPS_RETIRED.L1_HIT MEM_LOAD_UOPS_RETIRED.L2_HIT MEM_LOAD_UOPS_RETIRED.LLC_HIT MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HIT MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HITM MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_MISS MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_NONE MEM_LOAD_UOPS_RETIRED.LLC_MISS MEM_LOAD_UOPS_LLC_MISS_RETIRED.LOCAL_DRAM MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_DRAM MEM_LOAD_UOPS_RETIRED.L2_MISS 	  Due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.  	 None identified. 	  For the affected steppings, see the Summary Tables of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	  The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Spurious Intel® VT-d Interrupts May Occur When the PFO Bit is Set  	  When the PFO (Primary Fault Overflow) field (bit [0] in the VT-d FSTS [Fault Status] register) is set to 1, further faults should not generate an interrupt. Due to this erratum, further interrupts may still occur.  	  Unexpected Invalidation Queue Error interrupts may occur. Intel has not observed this erratum with any commercially available software.  	 Software should be written to handle spurious Intel® VT-d fault interrupts.  61   	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Livelock During On Demand Clock Modulation  	  The processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the IA32_CLOCK_MODULATION MSR (19AH) and the clock modulation duty cycle is set to 12.5% (02H in bits 3:0 of the same MSR), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access UC memory.  	  Program execution may stall on both threads of the core subject to this erratum.  	 This erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the IA32_CLOCK_MODULATION MSR is 18.75% or higher. 	  For the steppings affected, see the Summary Tables of Changes.
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions as described in the Software Developers Manual section "Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors" the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	  Upon crossing the page boundary the following may occur, dependent on the new page memory type:  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes.   17 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a non-canonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	  Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. • If an instruction that performs a memory load causes a code segment limit violation. • If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending. • If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Topof-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	  In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the sideeffect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception.  	 Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when  18   accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	  With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   19 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	  When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  	  Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer's Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	  In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame.  	 Software should not generate misaligned stack frames for use with IRET. 	  20  For the steppings affected, see the Summary Tables of Changes.  
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g. Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	  Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4G limit (0ffffffffh) may not signal a #GP fault.  	  When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault.  	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1's. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes.   21 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first FAR JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	  The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first FAR JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the FAR JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Read Miss to Level 3 Cache Fill Occupancy Counter may be Incorrect  	  Whenever an Level 3 cache fill conflicts with another request's address, the miss to fill occupancy counter, UNC_GQ_ALLOC.RT_LLC_MISS (Event 02H), will provide erroneous results.  	  The Performance Monitoring UNC_GQ_ALLOC.RT_LLC_MISS event may count a value higher than expected. The extent to which the value is higher than expected is determined by the frequency of the L3 address conflict.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A VM Exit on MWAIT May Incorrectly Report the Monitoring Hardware as Armed  	  A processor write to the address range armed by the MONITOR instruction may not immediately trigger the monitoring hardware. Consequently, a VM exit on a later MWAIT may incorrectly report the monitoring hardware as armed, when it should be reported as unarmed due to the write occurring prior to the MWAIT.  	  If a write to the range armed by the MONITOR instruction occurs between the MONITOR and the MWAIT, the MWAIT instruction may start executing before the monitoring hardware is triggered. If the MWAIT instruction causes a VM exit, this could cause its exit qualification to incorrectly report 0x1. In the recommended usage model for MONITOR/MWAIT, there is no write to the range armed by the MONITOR instruction between the MONITOR and the MWAIT.  	 Software should never write to the address range armed by the MONITOR instruction between the MONITOR and the subsequent MWAIT. 	  22  For the steppings affected, see the Summary Tables of Changes.  
  Delivery Status of the LINT0 Register of the Local Vector Table May be Lost  	  The Delivery Status bit of the LINT0 Register of the Local Vector Table will not be restored after a transition out of C6 under the following conditions • LINT0 is programmed as level-triggered • The delivery mode is set to either Fixed or ExtINT • There is a pending interrupt which is masked with the interrupt enable flag (IF)  	  Due to this erratum, the Delivery Status bit of the LINT0 Register will unexpectedly not be set. Intel has not observed this erratum with any commercially available software or system.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event SEGMENT_REG_LOADS Counts Inaccurately  	  The performance monitor event SEGMENT_REG_LOADS (Event 06H) counts instructions that load new values into segment registers. The value of the count may be inaccurate.  	  The performance monitor event SEGMENT_REG_LOADS may reflect a count higher or lower than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	  An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Improper Parity Error Signaled in the IQ Following Reset When a Code Breakpoint is Set on a #GP Instruction  	  While coming out of cold reset or exiting from C6, if the processor encounters an instruction longer than 15 bytes (which causes a #GP) and a code breakpoint is enabled on that instruction, an IQ (Instruction Queue) parity error may be incorrectly logged resulting in an MCE (Machine Check Exception).  	  When this erratum occurs, an MCE may be incorrectly signaled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software or system.  	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MPERF Counter Stops Counting During On-Demand TM1  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, the ratio of IA32_MPERF (MSR E7H) to IA32_APERF (MSR E8H) should reflect actual performance while TM1 or on-demand throttling is activated. Due to this erratum, IA32_MPERF MSR stops counting while TM1 or on-demand throttling is activated, and the ratio of the two will indicate higher processor performance than actual.  	  The incorrect ratio of IA32_APERF/IA32_MPERF can mislead software P-state (performance state) management algorithms under the conditions described above. It is possible for the Operating System to observe higher processor utilization than actual, which could lead the OS into raising the P-state. During TM1 activation, the OS P-state request is irrelevant and while on-demand throttling is enabled, it is expected that the OS will not be changing the P-state. This erratum should result in no practical implication to software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Memory Controller tTHROT_OPREF Timings May be Violated During Self Refresh Entry  	  During self refresh entry, the memory controller may issue more refreshes than permitted by tTHROT_OPREF (bits 29:19 in MC_CHANNEL_{0,1}_REFRESH_TIMING CSR).  	  The intention of tTHROT_OPREF is to limit current. Since current supply conditions near self refresh entry are not critical, there is no measurable impact due to this erratum.  	 None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.  
  Processor May Over Count Correctable Cache MESI State Errors  	  Under a specific set of conditions, correctable Level 2 cache hierarchy MESI state errors may be counted more than once per occurrence of a correctable error.  	  Correctable Level 2 cache hierarchy MESI state errors may be reported in the MCi_STATUS register at a rate higher than their actual occurrence.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Synchronous Reset of IA32_APERF/IA32_MPERF Counters on Overflow Does Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. This synchronous reset does not work. Instead, both MSRs increment and overflow independently.  	  Software can not rely on synchronous reset of the IA32_APERF/IA32_MPERF registers.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Disabling Thermal Monitor While Processor is Hot, Then Re-enabling, May Result in Stuck Core Operating Ratio  	  If a processor is at its TCC (Thermal Control Circuit) activation temperature and then Thermal Monitor is disabled by a write to IA32_MISC_ENABLES MSR (1A0H) bit [3], a subsequent re-enable of Thermal Monitor will result in an artificial ceiling on the maximum core P-state. The ceiling is based on the core frequency at the time of Thermal Monitor disable. This condition will only correct itself once the processor reaches its TCC activation temperature again.  	  Since Intel requires that Thermal Monitor be enabled in order to be operating within specification, this erratum should never be seen during normal operation.  	 Software should not disable Thermal Monitor during processor operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI Does Not Support PCI Configuration Reads/Writes to Misaligned Addresses  	  The PECI (Platform Environment Control Interface) specification allows for partial reads from or writes to misaligned addresses within the PCI configuration space. However, the PECI client does not properly interpret addresses that are Dword (4 byte) misaligned and may read or write incorrect data.  	  Due to this erratum, writes to or reads from Dword misaligned addresses could result in unintended side effects and unpredictable behavior.  	 PECI host controllers may issue byte, word and Dword reads and writes as long as they are aligned to Dword addresses. 	  For the steppings affected, see the Summary Tables of Changes.   25 
  OVER Bit for IA32_MCi_STATUS Register May Get Set on Specific lnternal Error  	  If a specific type of internal unclassified error is detected, as identified by IA32_MCi_STATUS.MCACOD=0x0405, the IA32_MCi_ STATUS.OVER (overflow) bit [62] may be erroneously set.  	  The OVER bit of the MCi_STATUS register may be incorrectly set for a specific internal unclassified error.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	  An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.  	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting MMX Instruction May Incorrectly Update x87 FPU Tag Word  	  Under a specific set of conditions, MMX stores (MOVD, MOVQ, MOVNTQ, MASKMOVQ) which cause memory access faults (#GP, #SS, #PF, or #AC), may incorrectly update the x87 FPU tag word register. This erratum will occur when the following additional conditions are also met. • The MMX store instruction must be the first MMX instruction to operate on x87 FPU state (i.e. the x87 FP tag word is not already set to 0x0000). • For MOVD, MOVQ, MOVNTQ stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to MASKMOVQ).  	  If the erratum conditions are met, the x87 FPU tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.  	 None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.  
  xAPIC Timer May Decrement Too Quickly Following an Automatic Reload While in Periodic Mode  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	  Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type.  	 Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1. MOV or POP instruction to SS (Stack Segment) selector; 2. Next instruction is FP (Floating Point) that gets FP assist 3. Another instruction after the FP instruction completes successfully 4. A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4.  	  Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints.  	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes.   27 
  Core C6 May Clear Previously Logged TLB Errors  	  Following an exit from core C6, previously logged TLB (Translation Lookaside Buffer) errors in IA32_MCi_STATUS may be cleared.  	  Due to this erratum, TLB errors logged in the associated machine check bank prior to core C6 entry may be cleared. Provided machine check exceptions are enabled, the machine check exception handler can log any uncorrectable TLB errors prior to core C6 entry. The TLB marks all detected errors as uncorrectable.  	 As long as machine check exceptions are enabled, the machine check exception handler can log the TLB error prior to core C6 entry. This will ensure the error is logged before it is cleared. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event MISALIGN_MEM_REF May Over Count  	  The MISALIGN_MEM_REF Performance Monitoring (Event 05H) may over count memory misalignment events, possibly by orders of magnitude.  	  Software relying on MISALIGN_MEM_REF to count cache line splits for optimization purposes may read excessive number of memory misalignment events.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
  Running with Write Major Mode Disabled May Lead to a System Hang  	  With write major mode disabled, reads will be favored over writes and under certain circumstances this can lead to a system hang.  	  Due to this erratum a system hang may occur.  	 It is possible for the BIOS to contain a workaround for this erratum 	  28  For the steppings affected, see the Summary Tables of Changes.  
  Infinite Stream of Interrupts May Occur if an ExtINT Delivery Mode Interrupt is Received while All Cores in C6  	  If all logical processors in a core are in C6, an ExtINT delivery mode interrupt is pending in the xAPIC and interrupts are blocked with EFLAGS.IF=0, the interrupt will be processed after C6 wakeup and after interrupts are re-enabled (EFLAGS.IF=1). However, the pending interrupt event will not be cleared.  	  Due to this erratum, an infinite stream of interrupts will occur on the core servicing the external interrupt. Intel has not observed this erratum with any commercially available software/system.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Two xAPIC Timer Event Interrupts May Unexpectedly Occur  	  If an xAPIC timer event is enabled and while counting down the current count reaches 1 at the same time that the processor thread begins a transition to a low power Cstate, the xAPIC may generate two interrupts instead of the expected one when the processor returns to C0.  	  Due to this erratum, two interrupts may unexpectedly be generated by an xAPIC timer event.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EOI Transaction May Not be Sent if Software Enters Core C6 During an Interrupt Service Routine  	  If core C6 is entered after the start of an interrupt service routine but before a write to the APIC EOI (End of Interrupt) register, and the core is woken up by an event other than a fixed interrupt source the core may drop the EOI transaction the next time APIC EOI register is written and further interrupts from the same or lower priority level will be blocked.  	  EOI transactions and interrupts may be blocked when core C6 is used during interrupt service routines. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29 
  FREEZE_WHILE_SMM Does Not Prevent Event From Pending PEBS During SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if 1. A performance counter overflowed before an SMI 2. A PEBS record has not yet been generated because another count of the event has not occurred 3. The monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM.  	  A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6 May Contain Incorrect Information When the First Instruction After a MOV SS,r/m or POP SS is a Store  	  Normally, each instruction clears the changes in DR6 (Debug Status Register) caused by the previous instruction. However, the instruction following a MOV SS,r/m (MOV to the stack segment selector) or POP SS (POP stack segment selector) instruction will not clear the changes in DR6 because data breakpoints are not taken immediately after a MOV SS,r/m or POP SS instruction. Due to this erratum, any DR6 changes caused by a MOV SS,r/m or POP SS instruction may be cleared if the following instruction is a store.  	  When this erratum occurs, incorrect information may exist in DR6. This erratum will not be observed under normal usage of the MOV SS,r/m or POP SS instructions (i.e., following them with an instruction that writes [e/r]SP). When debugging or when developing debuggers, this behavior should be noted.  	 None identified. 	  30  For the steppings affected, see the Summary Tables of Changes.  
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_PERF_GLOBAL_CTRL MSR May be Incorrectly Initialized  	  The IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [34:32] may be incorrectly set to 7H after reset; the correct value should be 0H.  	  The IA32_PERF_GLOBAL_CTRL MSR bits [34:32] may be incorrect after reset (EN_FIXED_CTR{0, 1, 2} may be enabled).  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Interrupts Generated From Uncore Fixed Counters (394H) May be Ignored  	  Performance monitor interrupts (PMI’s) from Uncore fixed counters are ignored when Uncore general performance monitor counters 3B0H-3BFH are not programmed.  	  This erratum blocks a usage model in which each of the cores can sample its own performance monitor events synchronously based on single interrupt from the Uncore.  	 Program any one of the Uncore general performance monitor counters with a valid performance monitor event and enable the event by setting the local enable bit in the corresponding performance monitor event select MSR. For the usage model where no counting is desired, program that Uncore general performance counter's global enable bit to be zero. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counter INST_RETIRED.STORES May Count Higher than Expected  	  Performance Monitoring counter INST_RETIRED.STORES (Event: C0H) is used to track retired instructions which contain a store operation. Due to this erratum, the processor may also count other types of instructions including WRMSR and MFENCE.  	  Performance Monitoring counter INST_RETIRED.STORES may report counts higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   31 
  Sleeping Cores May Not be Woken Up on Logical Cluster Mode Broadcast IPI Using Destination Field Instead of Shorthand  	  If software sends a logical cluster broadcast IPI using a destination shorthand of 00B (No Shorthand) and writes the cluster portion of the Destination Field of the Interrupt Command Register to all ones while not using all 1s in the mask portion of the Destination Field, target cores in a sleep state that are identified by the mask portion of the Destination Field may not be woken up. This erratum does not occur if the destination shorthand is set to 10B (All Including Self) or 11B (All Excluding Self).  	  When this erratum occurs, cores which are in a sleep state may not wake up to handle the broadcast IPI. Intel has not observed this erratum with any commercially available software.  	 Use destination shorthand of 10B or 11B to send broadcast IPIs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting Executions of FXRSTOR May Update State Inconsistently  	  The state updated by a faulting FXRSTOR instruction may vary from one execution to another.  	  Software that relies on x87 state or SSE state following a faulting execution of FXRSTOR may behave inconsistently.  	 Software handling a fault on an execution of FXRSTOR can compensate for execution variability by correcting the cause of the fault and executing FXRSTOR again. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event EPT.EPDPE_MISS May be Counted While EPT is Disable  	  Performance monitor event EPT.EPDPE_MISS (Event: 4FH, Umask: 08H) is used to count Page Directory Pointer table misses while EPT (extended page tables) is enabled. Due to this erratum, the processor will count Page Directory Pointer table misses regardless of whether EPT is enabled or not.  	  Due to this erratum, performance monitor event EPT.EPDPE_MISS may report counts higher than expected.  	 Software should ensure this event is only enabled while in EPT mode. 	  32  For the steppings affected, see the Summary Tables of Changes.  
  Memory Aliasing of Code Pages May Cause Unpredictable System Behavior  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncachable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	  If this erratum occurs the system may have unpredictable behavior including a system hang. The aliasing of memory regions, a condition necessary for this erratum to occur, is documented as being unsupported in the Intel 64 and IA-32 Intel® Architecture Software Developer's Manual, Volume 3A, in the section titled Programming the PAT. Intel has not observed this erratum with any commercially available software or system.  	 Code pages should not be mapped with uncacheable and cacheable memory types at the same time. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counters May Count Incorrectly  	  Under certain circumstances, a general purpose performance counter, IA32_PMC0-4 (C1H - C4H), may count at core frequency or not count at all instead of counting the programmed event.  	  The Performance Monitor Counter IA32_PMCx may not properly count the programmed event. Due to the requirements of the workaround there may be an interruption in the counting of a previously programmed event during the programming of a new event.  	 Before programming the performance event select registers, IA32_PERFEVTSELx MSR (186H - 189H), the internal monitoring hardware must be cleared. This is accomplished by first disabling, saving valid events and clearing from the select registers, then programming three event values 0x4300D2, 0x4300B1 and 0x4300B5 into the IA32_PERFEVTSELx MSRs, and finally continuing with new event programming and restoring previous programming if necessary. Each performance counter, IA32_PMCx, must have its corresponding IA32_PREFEVTSELx MSR programmed with at least one of the event values and must be enabled in IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [3:0]. All three values must be written to either the same or different IA32_PERFEVTSELx MSRs before programming the performance counters. Note that the performance counter will not increment when its IA32_PERFEVTSELx MSR has a value of 0x4300D2, 0x4300B1 or 0x4300B5 because those values have a zero UMASK field (bits [15:8]). 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor Forward Progress Mechanism Interacting With Certain MSR/CSR Writes May Cause Unpredictable System Behavior  	  Under specific internal conditions, a mechanism within the processor to ensure forward progress may interact with writes to a limited set of MSRs/CSRs and consequently may lead to unpredictable system behavior.  	  This erratum may cause unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   33 
  Performance Monitor Event Offcore_response_0 (B7H) Does Not Count NT Stores to Local DRAM Correctly  	  When a IA32_PERFEVTSELx MSR is programmed to count the Offcore_response_0 event (Event:B7H), selections in the OFFCORE_RSP_0 MSR (1A6H) determine what is counted. The following two selections do not provide accurate counts when counting NT (Non-Temporal) Stores: • OFFCORE_RSP_0 MSR bit [14] is set to 1 (LOCAL_DRAM) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are not counted when they should have been. • OFFCORE_RSP_0 MSR bit [9] is set to (OTHER_CORE_HIT_SNOOP) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are counted when they should not have been.  	  The counter for the Offcore_response_0 event may be incorrect for NT stores.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  34  For the steppings affected, see the Summary Tables of Changes.  
  System May Hang if MC_CHANNEL_{0,1}_MC_DIMM_INIT_CMD.DO_ZQCL Commands Are Not Issued in Increasing Populated DDR3 Rank Order  	  ZQCL commands are used during initialization to calibrate DDR3 termination. A ZQCL command can be issued by writing 1 to the MC_CHANNEL_{0,1}_MC_DIMM_INIT_CMD.DO_ZQCL (Device 4,5,6, Function 0, Offset 15, bit[15]) field and it targets the DDR3 rank specified in the RANK field (bits[7:5]) of the same register. If the ZQCL commands are not issued in increasing populated rank order then ZQ calibration may not complete, causing the system to hang.  	  Due to this erratum the system may hang if writes to the MC_CHANNEL_{0,1}_MC_DIMM_INIT_CMD.DO_ZQCL field are not in increasing populated DDR3 rank order.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Package C3/C6 Transitions When Memory 2x Refresh is Enabled May Result in a System Hang  	  If ASR_PRESENT (MC_CHANNEL_{0,1}_REFRESH_THROTTLE_SUPPORT CSR function 0, offset 68H, bit [0], Auto Self Refresh Present) is clear which indicates that high temperature operation is not supported on the DRAM, the memory controller will not enter self-refresh if software has REF_2X_NOW (bit 4 of the MC_CLOSED_LOOP CSR, function 3, offset 84H) set. This scenario may cause the system to hang during C3/C6 entry.  	  Failure to enter self-refresh can delay C3/C6 power state transitions to the point that a system hang may result with CATERR being asserted. REF_2X_NOW is used to double the refresh rate when the DRAM is operating in extended temperature range. The ASR_PRESENT was intended to allow low power self refresh with DRAM that does not support automatic self refresh.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Back to Back Uncorrected Machine Check Errors May Overwrite IA32_MC3_STATUS.MSCOD  	  When back-to-back uncorrected machine check errors occur that would both be logged in the IA32_MC3_STATUS MSR (40CH), the IA32_MC3_STATUS.MSCOD (bits [31:16]) field may reflect the status of the most recent error and not the first error. The rest of the IA32_MC3_STATUS MSR contains the information from the first error.  	  Software should not rely on the value of IA32_MC3_STATUS.MSCOD if IA32_MC3_STATUS.OVER (bit [62]) is set.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   35 
  Memory Intensive Workloads with Core C6 Transitions May Cause System Hang  	  Under a complex set of internal conditions, a system running a high cache stress and I/ O workload combined with the presence of frequent core C6 transitions may result in a system hang.  	  Due to this erratum, the system may hang.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corrected Errors With a Yellow Error Indication May be Overwritten by Other Corrected Errors  	  A corrected cache hierarchy data or tag error that is reported with IA32_MCi_STATUS.MCACOD (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one) and a yellow threshold-based error status indication (bits [54:53] equal to 10B) may be overwritten by a corrected error with a no tracking indication (00B) or green indication (01B).  	  Corrected errors with a yellow threshold-based error status indication may be overwritten by a corrected error without a yellow indication.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PSI# Signal May Incorrectly be Left Asserted  	  When some of the cores in the processor are in C3/C6 state, the PSI# (Power Status Indicator) signal may incorrectly be left asserted when another core makes a frequency change request without changing the operating voltage. Since this erratum results in a possible maximum core current greater than the PSI# threshold of 15A, PSI# should have been de-asserted.  	 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.  
  Performance Monitor Events DCACHE_CACHE_LD and DCACHE_CACHE_ST May Overcount  	  The performance monitor events DCACHE_CACHE_LD (Event 40H) and DCACHE_CACHE_ST (Event 41H) count cacheable loads and stores that hit the L1 cache. Due to this erratum, in addition to counting the completed loads and stores, the counter will incorrectly count speculative loads and stores that were aborted prior to completion.  	  The performance monitor events DCACHE_CACHE_LD and DCACHE_CACHE_ST may reflect a count higher than the actual number of events.  	 None identified. 	  36  For the steppings affected, see the Summary Tables of Changes.  
  Rapid Core C3/C6 Transitions May Cause Unpredictable System Behavior  	  Under a complex set of internal conditions, cores rapidly performing C3/C6 transitions in a system with Intel® Hyper-Threading Technology enabled may cause a machine check error (IA32_MCi_STATUS.MCACOD = 0x0106), system hang or unpredictable system behavior.  	  This erratum may cause a machine check error, system hang or unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events INSTR_RETIRED and MEM_INST_RETIRED May Count Inaccurately  	  The performance monitor event INSTR_RETIRED (Event C0H) should count the number of instructions retired, and MEM_INST_ RETIRED (Event 0BH) should count the number of load or store instructions retired. However, due to this erratum, they may undercount.  	  The performance monitor event INSTR_RETIRED and MEM_INST_RETIRED may reflect a count lower than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Page Fault May Not be Generated When the PS bit is set to "1" in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	  Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.  	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to "1". 	  For the steppings affected, see the Summary Tables of Changes. 
  CPURESET Bit Does Not Get Cleared  	  CPURESET (bit 10 of SYRE Device 8; Function 2; Offset 0CCH) allows the processor to be independently reset without assertion of the PLTRST# signal upon a 0 to 1 transition. The CPURESET bit does not get cleared and must be cleared by software.  	  The processor will not be reset if a 1 is written to this bit while it is already a one.  	 The CPURESET bit must be cleared by software prior to setting it. 	  For the steppings affected, see the Summary Tables of Changes.   37 
  PHOLD Disable in MISCCTRLSTS Register Does Not Work  	  PHOLD Disable (PCI Hold Disable, bit [23] in MISCCTRLSTS Device 0; Function 0; Offset 188H) does not function as described. Setting this bit will not cause the processor to respond with Unsupported Request and log a fatal error upon receiving an Assert_PHOLD message from the PCH (Platform Controller Hub).  	  Due to this erratum, it is not possible to disable PHOLD requests from the PCH.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe PMCSR Power State Field Incorrectly Allows Requesting of the D1 and D2 Power States  	  The PCIe PMCSR (Power Management Control and Status Register, Device 3,4,5,6; Function 0; Offset E4H) incorrectly allows the writing/requesting of the D1 and D2 Power States in the Power State field (bits[1:0] of PMCSR) when these states are not supported.  	  Given that the device does not support the D1 and D2 states, attempts to write those states should have been ignored. The PCIe port does not change power state from D0 or D3hot when the Power State bits are written to D1 or D2, so there is no functional impact to the PCIe port. However, the Power State field is incorrectly modified.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI Accesses to Registers May Fail When Processor is Transitioning to/from Package C6 Power State  	  A PECI (Platform Environment Control Interface) access to PCI configuration registers while the device is transitioning to or from package C6 may fail. Writes may not update the target register and reads may return incorrect data. The PECI bus will not show any indication the transaction failed.  	  PECI accesses to PCI configuration registers may not be processed correctly.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Concurrent Updates to a Segment Descriptor May be Lost  	  If a logical processor attempts to set the accessed bit in a code or data segment descriptor while another logical processor is modifying the same descriptor, both modifications of the descriptor may be lost.  	  Due to this erratum, updates to segment descriptors may not be preserved. Intel has not observed this erratum with any commercially available software or system.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  38  For the steppings affected, see the Summary Tables of Changes.  
  PMIs May be Lost During Core C6 Transitions  	  If a performance monitoring counter overflows and causes a PMI (Performance Monitoring Interrupt) at the same time that the core is entering C6, then the PMI may be lost.  	  PMIs may be lost during a C6 transition.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Uncacheable Access to a Monitored Address Range May Prevent Future Triggering of the Monitor Hardware  	  It is possible that an address range which is being monitored via the MONITOR instruction could be written without triggering the monitor hardware. A read from the monitored address range which is issued as uncacheable (for example having the CR0.CD bit set) may prevent subsequent writes from triggering the monitor hardware. A write to the monitored address range which is issued as uncacheable, may not trigger the monitor hardware and may prevent subsequent writes from triggering the monitor hardware.  	  The MWAIT instruction will not exit the optimized power state and resume program flow if the monitor hardware is not triggered.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  BIST Results May be Additionally Reported After a GETSEC[WAKEUP] or INIT-SIPI Sequence  	  BIST results should only be reported in EAX the first time a logical processor wakes up from the Wait-For-SIPI state. Due to this erratum, BIST results may be additionally reported after INIT-SIPI sequences and when waking up RLP's from the SENTER sleep state using the GETSEC[WAKEUP] command.  	  An INIT-SIPI sequence may show a non-zero value in EAX upon wakeup when a zero value is expected. RLP's waking up for the SENTER sleep state using the GETSEC[WAKEUP] command may show a different value in EAX upon wakeup than before going into the SENTER sleep state.  	 If necessary software may save the value in EAX prior to launching into the secure environment and restore upon wakeup and/or clear EAX after the INIT-SIPI sequence. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	  Software may observe #MF being signaled before pending interrupts are serviced.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   39 
  VM Exits Due to "NMI-Window Exiting" May Be Delayed by One Instruction  	  If VM entry is executed with the "NMI-window exiting" VM-execution control set to 1, a VM exit with exit reason "NMI window" should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	  VMM software using "NMI-window exiting" for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Malformed PCIe Packet Generated Under Heavy Outbound Load  	  When running the PCIe ports in a 2x8 configuration at 5.0GT/S speed with heavy outbound write traffic, malformed packets could be generated. The length in the header field will not match the actual payload size.  	  Due to this erratum, malformed PCIe packets could be transmitted.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Operation in x16 Mode With Inbound Posted Writes May be Unreliable  	  Under a complex set of conditions, it is possible that with PCIe configured for x16 operation inbound writes may store incorrect data.  	  PCIe operation with inbound writes in x16 mode may be unreliable.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unpredictable PCI Behavior Accessing Non-existent Memory Space  	  Locked instructions whose memory reference is split across cache line boundaries and are aborted on PCI behind Intel® 5 Series Chipset and Intel® 3400 Series Chipset may cause subsequent PCI writes to be unpredictable.  	  Aborted split lock accesses to non existent PCI memory space behind Intel 5 Series Chipset and Intel 3400 Series Chipset may cause PCI devices to subsequently become inoperable until a platform reset. Intel has not observed this erratum with commercially available software and has only observed this in a synthetic test environment.  	 None identified. 	  40  For the steppings affected, see the Summary Tables of Changes.  
  PECI MbxGet() Commands May Fail Several Times Before Passing When Issued During Package C6  	  PECI (Platform Environment Control Interface) MbxSend() requests may become blocked when the processor is in package C6. This temporary blocking may cause subsequent MbxGet() commands to result in the receipt of a bad write FCS (frame checksum).  	  Due to this erratum, as long as the host retries the MbxGet() command the results will be delivered upon the subsequent exit from package C6, but this may take several milliseconds depending on the platform or operating system.  	 PECI MbxGet() commands may need to be retried several times before successful completion. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to EPT Violations Do Not Record Information About PreIRET NMI Blocking  	  With certain settings of the VM-execution controls VM exits due to EPT violations set bit 12 of the exit qualification if the EPT violation was a result of an execution of the IRET instruction that commenced with non-maskable interrupts (NMIs) blocked. Due to this erratum, such VM exits will instead clear this bit.  	  Due to this erratum, a virtual-machine monitor that relies on the proper setting of bit 12 of the exit qualification may deliver NMIs to guest software prematurely.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® VT-d Receiving Two Identical Interrupt Requests May Corrupt Attributes of Remapped Interrupt or Hang a Subsequent InterruptRemap-Cache Invalidation Command  	  If the Intel® VT-d (Intel® Virtualization Technology for Directed I/O) interruptremapping hardware receives two identical back-to-back interrupt requests, then the attributes of the remapped interrupt returned may be corrupted. This interrupt sequence may also hang the system if the software executes a subsequent interruptremap-cache invalidation command.  	  This scenario may lead to unpredictable external interrupt behavior; or a subsequent interrupt-remap-cache invalidation command submitted by software may hang.  	 	  For the steppings affected, see the Summary Tables of Changes. 
  S1 Entry May Cause Cores to Exit C3 or C6 C-State  	  Under specific circumstances, S1 entry may cause a logical processor to spuriously wake up from C3 or C6 and transition to a C0/S1 state. Upon S1 exit, these logical processors will be operating in C0.  	  In systems where S1 is used for power savings, customers may observe higher S1 power than expected and software may observe a different C-state on S1 exit than on S1 entry.  	 It possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   41 
  Multiple Performance Monitor Interrupts are Possible on Overflow of IA32_FIXED_CTR2  	  When multiple performance counters are set to generate interrupts on an overflow and more than one counter overflows at the same time, only one interrupt should be generated. However, if one of the counters set to generate an interrupt on overflow is the IA32_FIXED_CTR2 (MSR 30BH) counter, multiple interrupts may be generated when the IA32_FIXED_CTR2 overflows at the same time as any of the other performance counters.  	  Multiple counter overflow interrupts may be unexpectedly generated.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBRs May Not be Initialized During Power-On Reset of the Processor  	  If a second reset is initiated during the power-on processor reset cycle, the LBRs (Last Branch Records) may not be properly initialized.  	  Due to this erratum, debug software may not be able to rely on the LBRs out of poweron reset.  	 Ensure that the processor has completed its power-on reset cycle prior to initiating a second reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected Interrupts May Occur on C6 Exit If Using APIC Timer to Generate Interrupts  	  If the APIC timer is being used to generate interrupts, unexpected interrupts not related to the APIC timer may be signaled when a core exits the C6 power state. This erratum may occur when the APIC timer is near expiration when entering the core C6 state.  	  Due to this erratum, unexpected interrupt vectors could be sent from the APIC to a logical processor.  	 Software should stop the APIC timer (by writing 0 to the Initial Count Register) before allowing the core to enter the C6 state. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTM or BTS Records May have Incorrect Branch From Information After an EIST Transition, T-states, C1E, or Adaptive Thermal Throttling  	  The "From" address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after an EIST (Enhanced Intel® SpeedStep Technology) transition, T-states, C1E (C1 Enhanced), or Adaptive Thermal Throttling.  	  When the LBRs, BTM or BTS are enabled, some records may have incorrect branch "From" addresses for the first branch after an EIST transition, T-states, C1E, or Adaptive Thermal Throttling.  	 None identified. 	  42  For the steppings affected, see the Summary Tables of Changes.  
  PECI GetTemp() Reads May Return Invalid Temperature Data in Package C6 State  	  The PECI (Platform Environment Control Interface) GetTemp() command may occasionally return incorrect temperature data.  	  The temperature data reported over PECI should always be a negative value and represents a delta below the onset of TCC (thermal control circuit) activation, as indicated by PROCHOT#. The PECI GetTemp() command may occasionally return incorrect temperature data when the processor is in the package C6 state. The error occurrence rate and returned processor temperature values are random including both hot and cold readings. Note that this error may cause the processor to return positive PECI temperature values that may not necessarily be indicative of a thermal event requiring an immediate shutdown.  	 Intel recommends discarding processor temperature values less than -100 or greater than 0, and the use of appropriate temperature smoothing filters in the range -100 to 0 to minimize fan speed fluctuations, if any, due to these errors. Intel does not recommend initiating system shutdown solely based on PECI readings. For systems using the PECI temperature data to facilitate system shutdown, Intel recommends initiating a shutdown only if a PECI value of 0 is returned over three consecutive PECI temperature reads. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI PCIConfigRd() Followed by a GetTemp() May Cause System Hang in Package C6 State  	  The PECI (Platform Environment Control Interface) PCIConfigRd() command immediately followed by a PECI GetTemp() command may result in a system hang.  	  When the processor is in the package C6 state, a PECI PCIConfigRd() command immediately followed by a GetTemp() command may result in a system hang. If PCIConfigRd() is never used, then this erratum will not be observed.  	 A PCIConfigWr() command should be issued in between PCIConfigRd() and GetTemp() commands. The PCIConfigWr() command may be issued to any valid PECI writable CSR address, including a benign CSR address such as 0x23058. 	  For the steppings affected, see the Summary Tables of Changes. 
  PECI Mailbox Commands During Package C6 Idle State Transitions May Result in Unpredictable Processor Behavior  	  If a PECI (Platform Environment Control Interface) mailbox command is executed at the same time that the processor is entering or exiting the package C6 idle state, unpredictable processor behavior or an incorrect mailbox response may result.  	  The PECI mailbox commands are not reliable during processor package C6 idle state and may result in unpredictable processor behavior or incorrect PECI responses.  	 It is possible for the BIOS to contain a workaround for this erratum. This workaround involves disabling PECI mailbox functions during package C6 idle state causing the processor to miss responding to requests during this time. The workaround may also result in PECI mailbox completion code responses of 0x85 ("Mailbox is Idle - no data available") when executed during normal active operating conditions. 	  For the steppings affected, see the Summary Tables of Changes.   43 
  VMX-Preemption Timer Does Not Count Down at the Rate Specified  	  The VMX-preemption timer should count down by 1 every time a specific bit in the TSC (Time Stamp Counter) changes. (This specific bit is indicated by IA32_VMX_MISC bits [4:0] (0x485h) and has a value of 5 on the affected processors.) Due to this erratum, the VMX-preemption timer may instead count down at a different rate and may do so only intermittently.  	  The VMX-preemption timer may cause VM exits at a rate different from that expected by software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Multiple Performance Monitor Interrupts are Possible on Overflow of Fixed Counter 0  	  The processor can be configured to issue a PMI (performance monitor interrupt) upon overflow of the IA32_FIXED_CTR0 MSR (309H). A single PMI should be observed on overflow of IA32_FIXED_CTR0, however multiple PMIs are observed when this erratum occurs. This erratum only occurs when IA32_FIXED_CTR0 overflows and the processor and counter are configured as follows: • Intel® Hyper-Threading Technology is enabled • IA32_FIXED_CTR0 local and global controls are enabled • IA32_FIXED_CTR0 is set to count events only on its own thread (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] = ‘0) • PMIs are enabled on IA32_FIXED_CTR0 (IA32_FIXED_CTR_CTRL MSR bit [3] = ‘1) • Freeze_on_PMI feature is enabled (IA32_DEBUGCTL MSR (1D9H) bit [12] = ‘1)  	  When this erratum occurs there may be multiple PMIs observed when IA32_FIXED_CTR0 overflows  	 Disable the FREEZE_PERFMON_ON_PMI feature in IA32_DEBUGCTL MSR (1D9H) bit [12]. 	  For the steppings affected, see the Summary Tables of Changes. 
  SVID and SID of Devices 8 and 16 only implement bits [7:0]  	  Bits [15:8] of SVID (Subsystem Vendor ID, Offset 2CH) and the SID (Subsystem Device ID, Offset 2EH) of devices 8 and 16 are not implemented. Only the lower bits [7:0] of these registers can be written to, though the PCI-e specification indicates that these are 16-bit registers.  	  Only bits [7:0] of SVID and SID can be written. Bits [15:8] will always be read as 0.  	 None identified. 	  44  For the steppings affected, see the Summary Tables of Changes.  
  No_Soft_Reset Bit in the PMCSR Does Not Operate as Expected  	  When the No_Soft_Reset bit in the Power Management Control and Status Register (PMCSR; Bus 0; Devices 0, 3, 4, 5; Function 0; Offset 0xE4; Bit 3) is cleared the device should perform an internal reset upon transitioning from D3hot to D0. Due to this erratum the device does not perform an internal reset upon transitioning from D3hot to D0.  	  When the No_Soft_reset bit in the PMCSR register is set or cleared no internal reset of the device will be preformed when transitioning from D3hot to D0.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to LIDT/LGDT/SIDT/SGDT Do Not Report Correct Operand Size  	  When a VM exit occurs due to a LIDT, LGDT, SIDT, or SGDT instruction with a 32-bit operand, bit 11 of the VM-exit instruction information field should be set to 1. Due to this erratum, this bit is instead cleared to 0 (indicating a 16-bit operand).  	  Virtual-machine monitors cannot rely on bit 11 of the VM-exit instruction information field to determine the operand size of the instruction causing the VM exit.  	 Virtual-machine monitor software may decode the instruction to determine operand size. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIConfigRd() and PCIConfigWr() PECI Commands May Silently Fail During Package C6 Exit Events  	  When PCIConfigRd() or PCIConfigWr() commands coincide with processor package C6 exits under the right timing conditions, they may fail to execute but still produce 'passing' responses.  	  When the timing conditions of this erratum are met, reads will return a value of “all zeroes” for the return data and writes will have no effect while both commands will return a passing completion code. The rate of occurrence of this issue is dependent on frequency and duration of C6 entry/exit events and PECI polling rate.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA May Not Count Events Correctly  	  Performance Monitor Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA should only increment the count when a load is blocked by a store. Due to this erratum, the count will be incremented whenever a load hits a store, whether it is blocked or can forward. In addition this event does not count for specific threads correctly.  	  If Intel® Hyper-Threading Technology is disabled, the Performance Monitor events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA may indicate a higher occurrence of loads blocked by stores than have actually occurred. If Intel Hyper-Threading Technology is enabled, the counts of loads blocked by stores may be unpredictable and they could be higher or lower than the correct count.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   45 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	  When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	  The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Following INVEPT or INVVPID May Fail to Flush All Translations for a Large Page  	  This erratum applies if the address of the memory operand of an INVEPT or INVVPID instruction resides on a page larger than 4KBytes and either (1) that page includes the low 1 MBytes of physical memory; or (2) the physical address of the memory operand matches an MTRR that covers less than 4 MBytes. A subsequent execution of INVLPG that targets the large page and that occurs before the next VM-entry instruction may fail to flush all TLB entries for the page. Such entries may persist in the TLB until the next VM-entry instruction.  	  Accesses to the large page between INVLPG and the next VM-entry instruction may incorrectly use translations that are inconsistent with the in-memory page tables.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The PECI Bus May be Tri-stated After System Reset  	  During power-up, the processor may improperly assert the PECI (Platform Environment Control Interface) pin. This condition is cleared as soon as Bus Clock starts toggling. However, if the PECI host (also referred to as the master or originator) incorrectly determines this asserted state as another PECI host initiating a transaction, it may release control of the bus resulting in a permanent tri-state condition.  	  Due to this erratum, the PECI host may incorrectly determine that it is not the bus master and consequently PECI commands initiated by the PECI software layer may receive incorrect/invalid responses.  46   	 To workaround this erratum the PECI host should pull the PECI bus low to initiate a PECI transaction. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	  The values of the LER MSRs may be unreliable.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	  The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Exit From the Core C6-state May Result in the Dropping of an Interrupt  	  In a complex set of internal conditions when the processor exits from Core C6 state, it is possible that an interrupt may be dropped.  	  Due to this erratum, an interrupt may be dropped. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Extended Capability Structures May be Incorrect  	  The PCIe Extended Capability structure at Offset 0x100 of Bus 0; Devices 0, 3, 4, 5 and 6 contains a Capability ID of AER (Advanced Error Reporting), but these devices do not support AER. The Next Capability Offset field of this Extended Capability structure contains 0x150 which is the offset of the next Extended Capability structure. For Bus 0;   47  Devices 4, 5, and 6, the Next Capability Offset field of the Extended Capability structure at offset 0x150 should contain 0 to indicate the end of the capability chain but instead contains 0x160. All fields of the Extended Capability structure at offset 0x160 are 0x0. A Capability ID of 0x0 is a reserved Capability ID. 	  Software that enables features based upon the existence of the AER may not observe the expected behavior associated with this capability.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMIs During Core C6 Transitions May Cause the System to Hang  	  If a performance monitoring counter overflows and causes a PMI (Performance Monitoring Interrupt) at the same time that the core enters C6, then this may cause the system to hang.  	  Due to this erratum, the processor may hang when a PMI coincides with core C6 entry.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC8_CTL2 MSR is Not Cleared on Processor Warm Reset  	  After processor warm reset the IA32_MC8_CTL2 MSR (288H) should be zero. Due to this erratum the IA32_MC8_CTL2 MSR is not zeroed on processor warm reset.  	  When this erratum occurs, the IA32_MC8_CTL2 MSR will not be zeroed by warm reset. Software that expects the values to be 0 coming out of warm reset may not behave as expected.  	 BIOS should zero the IA32_MC8_CTL2 MSR after a warm reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  The TPM's Locality 1 Address Space Can Not be Opened  	  Due to this erratum, writing to TXT.CMD.OPEN.LOCALITY1 (FED2_0380H) does not open the Locality 1 address space to the TPM (Trusted Platform Module).  	  Software that uses the TPM's Locality 1 address space will not be able to gain access to it.  	 All operations for the TPM should be done using Locality 0 or Locality 2 instead of Locality 1. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Combination of a Page-Split Lock Access And Data Accesses That Are Split Across Cacheline Boundaries May Lead to Processor Livelock  	  Under certain complex micro-architectural conditions, the simultaneous occurrence of a page-split lock and several data accesses that are split across cacheline boundaries may lead to processor livelock.  	  Due to this erratum, a livelock may occur that can only be terminated by a processor reset. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  48  For the steppings affected, see the Summary Tables of Changes.  
  PCIe Link Bit Errors Present During L0s Entry May Cause the System to Hang During L0s Exit  	  During L0s entry PCIe link bit errors may be generated due to a slow shutdown response from the PCIe analog circuits. As a result, the PCIe analog circuits may now take longer to establish bit lock during the L0s exit sequence. In some cases bit lock may not be achieved and may result in a system hang.  	  While exiting from L0s the PCIe bus may go into recovery mode. At the 5 GB/s rate system hangs may occur while exiting from L0s; however the hangs have not been seen on commercially available systems.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  IOTLB Invalidations Not Completing on Intel ® VT-d Engine for Integrated High Definition Audio  	  IOTLB invalidation in the Intel® VT-d engine for integrated High Definition Audio device may not complete and cause IVT field, bit [63] of IOTLBINV register (Offset 0x1208 in Memory Mapped IO region described by VTBAR {device 8, function 0, offset 0x180}), to not be cleared as expected. As a result, software may continue to poll this bit and not detect successful invalidation completion.  	  When Intel VT-d engine for integrated High Definition Audio device is enabled and software requests for IOTLB invalidation while audio traffic is active, the request may not complete and may result in a software hang. Intel has not observed this erratum with any commercially available software.  	 A BIOS workaround has been identified. Please refer to the latest version (Revision 1.3) of the BIOS specification and release notes. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May Be Lost  	  The IO_SMI bit (bit 0) in the IO state field at SMRAM offset 7FA4H is set to "1" by the processor to indicate a System Management Interrupt (SMI) is either taken immediately after a successful I/O instruction or is taken after a successful iteration of a REP I/O instruction. Due to this erratum, the setting of the IO_SMI bit may be lost. This may happen under a complex set of internal conditions with Intel® Hyper-   49  Threading Technology enabled and has not been observed with commercially available software. 	  Due to this erratum, SMI handlers may not be able to identify the occurrence of I/O SMIs.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Squelch Detect May be Slow to Respond During L0s Entry and May Cause a Surprise Link Down Condition  	  When entering the L0s idle state the PCIe squelch detect response may be slower than expected. This slow response can cause the PCIe interface at the downstream port to unexpectedly enter the L0s.FTS (Fast Training Sequence) state instead of the normal operation which is staying in the L0s.idle state until the Tx side of the upstream port exits squelch. This unexpected state transition may cause a recovery entry leading to a Surprise Link Down condition.  	  This erratum may cause a system hang while trying reach the L0s state.  	 A BIOS workaround has been identified. Please refer to the latest version (Revision 1.31) of the BIOS specification and release notes. 	  For the steppings affected, see the Summary Tables of Changes. 
  TR Corruption Due to Save/Restore x87 FPU Pointers in SMRAM  	  When the system software enables the saving/restoring of x87 FPU instruction and data pointers in SMRAM by setting the SMM_SAVE_CONTROL MSR (3EH) bit 0 to 1, the TR (Task Register) selector may be restored incorrectly on the exit from SMM.  	  The TR selector containing incorrect data may cause unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Lanes Returning to The Active Power State May Cause The System to Hang  	  Under certain conditions, when the PCIe lanes come out of the S0 power savings state, the clocks may change asynchronously leading to a system hang.  	  A System hang may occur when coming out of the S0 power saving state.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events for Hardware Prefetches Which Miss The L1 Data Cache May be Over-Counted  	  Hardware prefetches that miss the L1 data cache but cannot be processed immediately due to resource conflicts will count and then retry. This may lead to incorrectly incrementing the L1D_PREFETCH.MISS (event 4EH, umask 02H) event multiple times for a single miss.  	  The count reported by the L1D_PREFETCH.MISS event may be higher than expected.  	 None identified. 	  50  For the steppings affected, see the Summary Tables of Changes.  
  VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]  	  If the “load IA32_PERF_GLOBAL_CTRL” VM-exit control is 1, a VM exit should load the IA32_PERF_GLOBAL_CTRL MSR (38FH) from the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS. Due to this erratum, such a VM exit may instead clear bits 34:32 of the MSR, loading only bits 31:0 from the VMCS.  	  All fixed-function performance counters will be disabled after an affected VM exit, even if the VM exit should have enabled them based on the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS.  	 A VM monitor that wants the fixed-function performance counters to be enabled after a VM exit may do one of two things: (1) clear the “load IA32_PERF_GLOBAL_CTRL” VMexit control; or (2) include an entry for the IA32_PERF_GLOBAL_CTRL MSR in the VMexit MSR-load list. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Port’s LTSSM May Not Transition Properly in the Presence of TS1 or TS2 Ordered Sets That Have Unexpected Symbols Within those Sets  	  When a PCIe port receives TS1 and/or TS2 ordered sets with unexpected symbols (per the PCIe Base Specification), the port’s LTSSM (Link Training State Machine) might not transition according to the PCIe Base Specification requirements. The LTSSM may incorrectly stay in its current state, or transition to an incorrect state. If the unexpected symbols are sporadic in nature the link will recover and go to the proper state.  	  PCIe Port’s LTSMM may not transition according to PCIe Base Specification as described above. This problem has not been seen in real system testing, but was discovered by synthetic tests designed to check for illegal conditions.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  NTB/RP Link Will Send Extra TS2 Ordered Set During Link Training  	  The NTB (Non-Transparent Bridge) when operating in NTB/RP (Root Port) mode will send a superfluous TS2 ordered set after transitioning to the CONFIGURATION.IDLE state during link training. This TS2 ordered set may contain invalid capability data.  	  NTB/RP Link will transmit a TS2 ordered set after transitioning to the CONFIGURATION.IDLE state. No impact expected for specification compliant PCIe partners. Specification compliant PCIe link partners will have transitioned to CONFIGURATION.IDLE before this ordered set is sent and will ignore it.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Ports May Not Enter Slave Loopback Mode From the Configuration LTSSM State  	  If a PCIe port’s LTSSM (Link Training State Machine) is in the CONFIG.LINK_WIDTH_START state, it may not enter slave loopback mode when requested to do so by the link partner. If the request is missed the link will continue to train and enter the Slave loopback mode after it first transitions through the L0 and RECOVERY LTSSM states.  	  Due to this erratum, PCIe ports may be delayed in entering the slave loopback mode.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   51 
  DTS Temperature Data May Be Incorrect On a Return From the Package C6 Low Power State.  	  The DTS (Digital Thermal Sensor) temperature value may be incorrect for a small period (less than 2ms) after a return from the package C6 low power state.  	  The DTS temperature data (including temperatures read by Platform Environment Control Interface) may be reported lower than the actual temperature. Fan speed control or other system functions which are reliant on correct DTS temperature data may behave unpredictably.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected DMI and PCIe Link Retraining and Correctable Errors Reported  	  When the processor exits the package C6 power state, the PCIe and DMI ports may enter a state where they will NAK all packets for a short time. If this condition persists long enough so that the same packet is NAKed four times, the link will retrain and a correctable error may be signaled by the PCIe end point. Overall performance of the link is not impacted.  	  Due to this erratum, unexpected link retraining and correctable errors may be reported.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  QPI Lane May Be Dropped During Full Frequency Deskew Phase of Training  	  A random QPI Lane may be dropped during the lane deskew phase while the QPI Bus is training at full frequency.  	  When there are multiple resets after the QPI Bus has reached full speed operation there is a small chance that a lane could be dropped during the deskew phase of training. In the case of a lane being dropped this will be detected and a retry will be done until the link is established and the lane is re-trained.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PerfMon Overflow Status Can Not be Cleared After Certain Conditions Have Occurred  	  Under very specific timing conditions, if software tries to disable a PerfMon counter through MSR IA32_PERF_GLOBAL_CTRL (0x38F) or through the per-counter eventselect (e.g. MSR 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in MSR IA32_PERF_GLOBAL_STAT (0x38E) may be left set with no way for software to clear it.  	  Due to this erratum, software may be unable to clear the PerfMon counter overflow status indication.  	 Software may avoid this erratum by clearing the PerfMon counter value prior to disabling it and then clearing the overflow status indication bit. 	NA
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations.  	  Under certain conditions as described in the Software Developers Manual section “Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	  Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4H is set to “1” by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: • A non-I/O instruction • SMI is pending while a lower priority event interrupts • A REP I/O read • A I/O read that redirects to MWAIT  	  SMM handlers may get false IO_SMI indication.  	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  20  For the steppings affected, see the Summary Tables of Changes.  
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	  Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	  In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame.  	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	  The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of teption). Intel has not observed this erratum with any commercially available software.  	 None identified 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g. Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	  Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   21 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR or XSAVE/XRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the FXSAVE or XSAVE image or a partial memory state restore of the FXRSTOR or XRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR or XSAVE/XRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM Will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.  
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1. MOV or POP instruction to SS (Stack Segment) selector; 2. Next instruction is FP (Floating Point) that gets FP assist 3. Another instruction after the FP instruction completes successfully 4. A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4.  	  Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints.  	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes.   23 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	  The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	  The values of the LER MSRs may be unreliable.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	  When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay.  	 None identified.  24  	NA
  PEBS Record not Updated when in Probe Mode  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflows of the counter can result in storage of a PEBS record in the PEBS buffer. Due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new PEBS record may not be added to the PEBS buffer.  	  Due to this erratum, the PEBS buffer may not be updated by overflows that occur during probe mode.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting MMX Instruction May Incorrectly Update x87 FPU Tag Word  	  Under a specific set of conditions, MMX stores (MOVD, MOVQ, MOVNTQ, MASKMOVQ) which cause memory access faults (#GP, #SS, #PF, or #AC), may incorrectly update the x87 FPU tag word register. This erratum will occur when the following additional conditions are also met. • The MMX store instruction must be the first MMX instruction to operate on x87 FPU state (i.e. the x87 FP tag word is not already set to 0x0000). • For MOVD, MOVQ, MOVNTQ stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to MASKMOVQ).  	  If the erratum conditions are met, the x87 FPU tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   25 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	  An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6.B0-B3 May Not Report All Breakpoints Matched When a MOV/POP SS is Followed by a Store or an MMX Instruction  	  Normally, data breakpoints matches that occur on a MOV SS, r/m or POP SS will not cause a debug exception immediately after MOV/POP SS but will be delayed until the instruction boundary following the next instruction is reached. After the debug exception occurs, DR6.B0-B3 bits will contain information about data breakpoints matched during the MOV/POP SS as well as breakpoints detected by the following instruction. Due to this erratum, DR6.B0-B3 bits may not contain information about data breakpoints matched during the MOV/POP SS when the following instruction is either an MMX instruction that uses a memory addressing mode with an index or a store instruction.  	  When this erratum occurs, DR6 may not contain information about all breakpoints matched. This erratum will not be observed under the recommended usage of the MOV SS,r/m or POP SS instructions (i.e., following them only with an instruction that writes (E/R)SP).  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.  
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	  Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type.  	 Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTM or BTS Records May have Incorrect Branch From Information After an EIST/T-state/S-state/C1E Transition or Adaptive Thermal Throttling  	  The “From” address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after a transition of: • EIST (Enhanced Intel® SpeedStep Technology) • T-state (Thermal Monitor states) • S1-state (ACPI package sleep state) • C1E (Enhanced C1 Low Power state) • Adaptive Thermal Throttling  	  When the LBRs, BTM or BTS are enabled, some records may have incorrect branch “From” addresses for the first branch after a transition of EIST, T-states, S-states, C1E, or Adaptive Thermal Throttling.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   27 
  Fault Not Reported When Setting Reserved Bits of Intel® VT-d Queued Invalidation Descriptors  	  Reserved bits in the Queued Invalidation descriptors of Intel VT-d (Virtualization Technology for Directed I/O) are expected to be zero, meaning that software must program them as zero while the processor checks if they are not zero. Upon detection of a non-zero bit in a reserved field an Intel VT-d fault should be recorded. Due to this erratum the processor does not check reserved bit values for Queued Invalidation descriptors.  	  Due to this erratum, faults will not be reported when writing to reserved bits of Intel VT-d Queued Invalidation Descriptors.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMREAD/VMWRITE Instruction May Not Fail When Accessing an Unsupported Field in VMCS  	  The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B states that execution of VMREAD or VMWRITE should fail if the value of the instruction’s register source operand corresponds to an unsupported field in the VMCS (Virtual Machine Control Structure). The correct operation is that the logical processor will set the ZF (Zero Flag), write 0CH into the VM-instruction error field and for VMREAD leave the instruction’s destination operand unmodified. Due to this erratum, the instruction may instead clear the ZF, leave the VM-instruction error field unmodified and for VMREAD modify the contents of its destination operand.  	  Accessing an unsupported field in VMCS will fail to properly report an error. In addition, VMREAD from an unsupported VMCS field may unexpectedly change its destination operand. Intel has not observed this erratum with any commercially available software.  	 Software should avoid accessing unsupported fields in a VMCS. 	  28  For the steppings affected, see the Summary Tables of Changes.  
  Spurious Interrupts May be Generated From the Intel® VT-d Remap Engine  	  If software clears the F (Fault) bit 127 of the Fault Recording Register (FRCD_REG at offset 0x208 in Remap Engine BAR) by writing 1b through RW1C command (Read Write 1 to Clear) when the F bit is already clear then a spurious interrupt from Intel VT-d (Virtualization Technology for Directed I/O) Remap Engine may be observed.  	  Due to this erratum, spurious interrupts will occur from the Intel VT-d Remap Engine following RW1C clearing F bit.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Malformed PCIe Transactions May be Treated as Unsupported Requests Instead of as Critical Errors  	  PCIe MSG/MSG_D TLPs (Transaction Layer Packets) with incorrect Routing Code as well as the deprecated TCfgRD and TCfgWr types should be treated as malformed transactions leading to a critical error. Due to this erratum, the integrated PCIe controller's root ports may treat such messages as UR (Unsupported Requests).  	  Legacy malformed PCIe transactions may be treated as UR instead of as critical errors.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reception of Certain Malformed Transactions May Cause PCIe Port to Hang Rather Than Reporting an Error  	  If the processor receives an upstream malformed non posted packet for which the type field is IO, Configuration or the deprecated TCfgRd and the format is 4 DW header, then due to this erratum the integrated PCIe controller may hang instead of reporting the malformed packet error or issuing an unsupported request completion transaction.  	  Due to this erratum, the processor may hang without reporting errors when receiving a malformed PCIe transaction. Intel has not observed this erratum with any commercially available device.  	 None identified. Upstream transaction initiators should avoid issuing unsupported requests with 4 DW header formats. 	  For the steppings affected, see the Summary Tables of Changes. 
  Clock Modulation Duty Cycle Cannot be Programmed to 6.25%  	  When programming field T_STATE_REQ of the IA32_CLOCK_MODULATION MSR (19AH) bits [3:0] to '0001, the actual clock modulation duty cycle will be 12.5% instead of the expected 6.25% ratio.  	  Due to this erratum, it is not possible to program the clock modulation to a 6.25% duty cycle.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29 
  Processor May Fail to Acknowledge a TLP Request  	  When a PCIe root port’s receiver is in Receiver L0s power state and the port initiates a Recovery event, it will issue Training Sets to the link partner. The link partner will respond by initiating an L0s exit sequence. Prior to transmitting its own Training Sets, the link partner may transmit a TLP (Transaction Layer Packet) request. Due to this erratum, the root port may not acknowledge the TLP request.  	  After completing the Recovery event, the PCIe link partner will replay the TLP request. The link partner may set a Correctable Error status bit, which has no functional effect.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Unexpected PMI May Occur After Writing a Large Value to IA32_FIXED_CTR2  	  If the fixed-function performance counter IA32_FIXED_CTR2 MSR (30BH) is configured to generate a performance-monitor interrupt (PMI) on overflow and the counter’s value is greater than FFFFFFFFFFC0H, then this erratum may incorrectly cause a PMI if software performs a write to this counter.  	  A PMI may be generated unexpectedly when programming IA32_FIXED_CTR2. Other than the PMI, the counter programming is not affected by this erratum as the attempted write operation does succeed.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to the IA32_FIXED_CTR1 MSR May Result in Incorrect Value in Certain Conditions  	  Under specific internal conditions, if software tries to write the IA32_FIXED_CTR1 MSR (30AH) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (i.e. its value was 0xFFFF FFFF FFFF), then due to this erratum the new value in the MSR may be corrupted.  	  Due to this erratum, IA32_FIXED_CTR1 MSR may be written with a corrupted value.  	 Software may avoid this erratum by writing zeros to the IA32_FIXED_CTR1 MSR, before the desired write operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* LTR Incorrectly Reported as Being Supported  	  LTR (Latency Tolerance Reporting) is a new optional feature specified in PCIe rev. 2.1. The processor reports LTR as supported in LTRS bit in DCAP2 register (bus 0; Device 1; Function 0; offset 0xc4), but this feature is not supported.  	  Due to this erratum, LTR is always reported as supported by the LTRS bit in the DCAP2 register.  	 None identified. 	  30  For the steppings affected, see the Summary Tables of Changes.  
  PerfMon Overflow Status Can Not be Cleared After Certain Conditions Have Occurred  	  Under very specific timing conditions, if software tries to disable a PerfMon counter through MSR IA32_PERF_GLOBAL_CTRL (0x38F) or through the per-counter eventselect (e.g. MSR 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in MSR IA32_PERF_GLOBAL_STAT (0x38E) may be left set with no way for software to clear it.  	  Due to this erratum, software may be unable to clear the PerfMon counter overflow status indication.  	 Software may avoid this erratum by clearing the PerfMon counter value prior to disabling it and then clearing the overflow status indication bit. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions  	  When a 2-byte opcode of a conditional branch (opcodes 0F8xH, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid VEX prefix, it may sometimes signal a #GP fault (illegal instruction length > 15-bytes) instead of a #UD (illegal opcode) fault.  	  Due to this erratum, #GP fault instead of a #UD may be signaled on an illegal instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Interrupt From Local APIC Timer May Not Be Detectable While Being Delivered  	  If the local-APIC timer’s CCR (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the LVT timer register and then reading the bit in the IRR (interrupt-request register) corresponding to the vector in the LVT timer register. If both values are read as 0, no timer interrupt should be in the process of being delivered. Due to this erratum, a timer interrupt may be delivered even if the CCR is 0 and the LVT and IRR bits are read as 0. This can occur only if the DCR (Divide Configuration Register) is greater than or equal to 4. The erratum does not occur if software writes zero to the Initial Count Register before reading the LVT and IRR bits.  	  Software that relies on reads of the LVT and IRR bits to determine whether a timer interrupt is being delivered may not operate properly.  	 Software that uses the local-APIC timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading CCR and the LVT and IRR bits; alternatively, software can avoid the problem by writing zero to the Initial Count Register before reading the LVT and IRR bits. 	  For the steppings affected, see the Summary Tables of Changes.   31 
  PCI Express* Differential Peak-Peak Tx Voltage Swing May Violate the Specification  	  Under certain conditions, including extreme voltage and temperature, the peak-peak voltage may be higher than the specification.  	  Violation of PCI Express® Base Specification of the VTX--DIFF-PP voltage. No failures have been observed due to this erratum.  	 None identified. 	NA
  PCMPESTRI, PCMPESTRM, VPCMPESTRI and VPCMPESTRM Always Operate with 32-bit Length Registers  	  In 64-bit mode, using REX.W=1 with PCMPESTRI and PCMPESTRM or VEX.W=1 with VPCMPESTRI and VPCMPESTRM should support a 64-bit length operation with RAX/ RDX. Due to this erratum, the length registers are incorrectly interpreted as 32-bit values.  	  Due to this erratum, using REX.W=1 with PCMPESTRI and PCMPESTRM as well as VEX.W=1 with VPCMPESTRI and VPCMPESTRM do not result in promotion to 64-bit length registers.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Multiple Performance Monitor Interrupts are Possible on Overflow of Fixed Counter 0  	  The processor can be configured to issue a PMI (performance monitor interrupt) upon overflow of the IA32_FIXED_CTR0 MSR (309H). A single PMI should be observed on overflow of IA32_FIXED_CTR0, however multiple PMIs are observed when this erratum occurs. This erratum only occurs when IA32_FIXED_CTR0 overflows and the processor and counter are configured as follows: • Intel® Hyper-Threading Technology is enabled • IA32_FIXED_CTR0 local and global controls are enabled • IA32_FIXED_CTR0 is set to count events only on its own thread (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] = ‘0). • PMIs are enabled on IA32_FIXED_CTR0 (IA32_FIXED_CTR_CTRL MSR bit [3] = ‘1)	NA	NA	NA
  	NA	  When this erratum occurs there may be multiple PMIs observed when IA32_FIXED_CTR0 overflows. 	NA	NA
 bit [12]. 	NA	NA	NA	  32  For the steppings affected, see the Summary Tables of Changes.  
  IA32_FEATURE_CONTROL MSR May be Uninitialized on a Cold Reset  	  IA32_FEATURE_CONTROL MSR (3Ah) may have random values after RESET (including the reserved and Lock bits), and the read-modify-write of the reserved bits and/or the Lock bit being incorrectly set may cause an unexpected GP fault.  	  Due to this erratum, an unexpected GP fault may occur and BIOS may not complete initialization.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6.B0-B3 May Not Report All Breakpoints Matched When a MOV/POP SS is Followed by a REP MOVSB or STOSB  	  Normally, data breakpoints matches that occur on a MOV SS, r/m or POP SS will not cause a debug exception immediately after MOV/POP SS but will be delayed until the instruction boundary following the next instruction is reached. After the debug exception occurs, DR6.B0-B3 bits will contain information about data breakpoints matched during the MOV/POP SS as well as breakpoints detected by the following instruction. Due to this erratum, DR6.B0-B3 bits may not contain information about data breakpoints matched during the MOV/POP SS when the following instruction is either an REP MOVSB or REP STOSB.  	  When this erratum occurs, DR6 may not contain information about all breakpoints matched. This erratum will not be observed under the recommended usage of the MOV SS,r/m or POP SS instructions (i.e., following them only with an instruction that writes (E/R)SP).  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Setting Hardware Autonomous Speed Disable Configuration Bit Will Block Initial Speed Upgrade  	  The PCI Express* Base Specification Revision 3.0 states that the Hardware Autonomous Speed Disable bit (Link Control Register 2, bit 5) does not block the initial transition to the highest supported common link speed. Setting this bit will block all autonomous speed changes.  	  Due to this erratum, if the Hardware Autonomous Speed Disable bit is set, a given PCIe link may remain at 2.5 GT/s transfer rate. This erratum has not been observed with any commercially available add-in cards.  	 It is possible for software to initiate a directed speed change. 	  For the steppings affected, see the Summary Tables of Changes. 
  LTR Message is Not Treated as an Unsupported Request  	  The PCIe* root port does not support LTR (Latency Tolerance Reporting) capability. However, a received LTR message is not treated as a UR (Unsupported Request).  	  Due to this erratum, an LTR message does not generate a UR error.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   33 
  64-bit REP MOVSB/STOSB May Clear The Upper 32-bits of RCX, RDI And RSI Before Any Data is Transferred  	  If a REP MOVSB/STOSB is executed in 64-bit mode with an address size of 32 bits, and if an interrupt is being recognized at the start of the instruction operation, the upper 32-bits of RCX, RDI and RSI may be cleared, even though no data has yet been copied or written.  	  Due to this erratum, the upper 32-bits of RCX, RDI and RSI may be prematurely cleared.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Interrupt Recognized Prior to First Iteration of REP MOVSB/STOSB May Result EFLAGS.RF Being Incorrectly Set  	  If a REP MOVSB/STOSB is executed and an interrupt is recognized prior to completion of the first iteration of the string operation, EFLAGS may be saved with RF=1 even though no data has been copied or stored. The Software Developer’s Manual states that RF will be set to 1 for such interrupt conditions only after the first iteration is complete.  	  Software may not operate correctly if it relies on the value saved for EFLAGS.RF when an interrupt is recognized prior to the first iteration of a string instruction. Debug exceptions due to instruction breakpoints are delivered correctly despite this erratum; this is because the erratum occurs only after the processor has evaluated instructionbreakpoint conditions.  	 Software whose correctness depends on value saved for EFLAGS.RF by delivery of the affected interrupts can disable fast-string operation by clearing Fast-String Enable in bit 0 in the IA32_MISC_ENABLE MSR (1A0H). 	  For the steppings affected, see the Summary Tables of Changes. 
  Accessing Physical Memory Space 0-640K through the Graphics Aperture May Cause Unpredictable System Behavior  	  The physical memory space 0-640K when accessed through the graphics aperture may result in a failure for writes to complete or reads to return incorrect results.  	  A hang or functional failure may occur during graphics operation such as OGL or OCL conformance tests, 2D/3D games and graphics intensive application.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS May Unexpectedly Signal a PMI After The PEBS Buffer is Full  	  The Software Developer’s Manual states that no PMI should be generated when PEBS index reaches PEBS Absolute Maximum. Due to this erratum, a PMI may be generated even though the PEBS buffer is full.  	  PEBS may trigger a PMI even though the PEBS index has reached the PEBS Absolute Maximum.  	 None identified. 	  34  For the steppings affected, see the Summary Tables of Changes.  
  Instructions Retired Event May Over Count Execution of IRET Instructions  	  Under certain conditions, the performance monitoring event Instructions Retired (Event C0H, Unmask 00H) may over count the execution of IRET instruction.  	  Due to this erratum, performance monitoring event Instructions Retired may over count.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Link May Unexpectedly Exit Loopback State  	  The PCIe Port is capable of functioning as 3 independent PCIe controllers. Due to this erratum, if more than one of the controllers is in Loopback.Active state and configured as a loopback slave and if any one of these controllers transition to Loopback.Exit, all controllers in Loopback.Active will transition to Loopback.Exit.  	  Loopback.Active state on a given Link may unexpectedly exit. Software should avoid configuring more than one of the PCIe Controllers as Loopback slave concurrently.  	 PCIe endpoints should avoid configuring more than one of PCIe Controllers as Loopback slave. 	  For the steppings affected, see the Summary Tables of Changes. 
  The RDRAND Instruction Will Not Execute as Expected  	  On processors that support the RDRAND instruction, that capability should be reported via the setting of CPUID.01H:ECX.RDRAND[bit 30]. Due to this erratum, that bit will not be set, and the execution of the RDRAND instruction will result in a #UD exception.  	  Software will not be able to utilize the RDRAND instruction  	 It is possible for the BIOS to contain a workaround for this erratum to report RDRAND as present via CPUID and allow proper execution of RDRAND. 	  For the steppings affected, see the Summary Tables of Changes. 
  A PCIe* Device That Initially Transmits Minimal Posted Data Credits May Cause a System Hang  	  Under certain conditions, if a PCIe device that initially transmits posted data credits less than Max_Payload_Size/16 + 4 (16B/4DW is unit of data flow control) and is the target of a Peer-to-Peer write of Max_Payload_Size, the system may hang due to Posted Data credit starvation.  	  Under certain conditions, the processor may encounter a Posted Data credit starvation scenario and hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   35 
  PCI Express* Gen3 Receiver Return Loss May Exceed Specifications  	  The PCIe Base Specification includes a graph that sets requirements for maximum receiver return loss versus frequency. Due to this erratum, the receiver return loss for common mode and differential mode may exceed those requirements at certain frequencies. Under laboratory conditions, Intel has observed violations of as much as 1 dB.  	  The PCI Express Gen3 Base Specification for receiver return loss may be exceeded. No functional failures have been observed due to this erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Direct Access Via VT-d to The Processor Graphics Device May Lead to a System Hang  	  Under a complex set of conditions, while using VT-d (Virtualization Technology for Directed I/O) with the processor graphics device, direct access to the virtualized processor graphics device can lead to a system hang or restart.  	  Systems providing direct access to processor graphics device via VT-d may hang or restart. Intel has not observed this erratum with any commercially available system.  	 VMM’s should ensure that all processor graphics device interactions conform to guidance published in the Intel® Open Source HD Graphics Programmer's Reference Manual and driver writers guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Event May Intervene Before a System Management Interrupt That Results from IN or INS  	  If an I/O instruction (IN, INS, OUT, or OUTS) results in an SMI (system-management interrupt), the processor will set the IO_SMI bit at offset 7FA4H in SMRAM. This interrupt should be delivered immediately after execution of the I/O instruction so that the software handling the SMI can cause the I/O instruction to be re-executed. Due to this erratum, it is possible for another event (e.g., a nonmaskable interrupt) to be delivered before the SMI that follows the execution of an IN or INS instruction.  	  If software handling an affected SMI uses I/O instruction restart, the handler for the intervening event will not be executed.  	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  36  For the steppings affected, see the Summary Tables of Changes.  
  PCIe* May Associate Lanes That Are Not Part of Initial Link Training to L0 During Upconfiguration  	  The processor should not associate any lanes that were not part of the initial link training in subsequent upconfiguration requests from an endpoint. Due to this erratum, the processor may associate any Lane that has exited Electrical Idle, even if it is beyond the width of the initial Link training.  	  Upconfiguration requests may result in a Link wider than the initially-trained Link.  	 Endpoints must ensure that upconfiguration requests do not request a Link width wider than that negotiated during initial Link training. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Not Comply With PCIe* Equalization Preset Reflection Requirements for 8 GT/s Mode of Operation  	  In endpoint-initiated transitions to Polling.Compliance at the 8 GT/s transfer rate, the processor must reflect, in its ordered sets, the Transmitter Preset requested by the endpoint regardless of preset legality. Due to this erratum, the processor will reflect the Transmitter Preset in use after an endpoint requests a reserved Transmitter Preset rather than the requested preset.  	  Endpoints requiring reserved Transmitter Presets to be reflected may be adversely affected. Intel has not observed failures due to this erratum with any commercially available devices.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Issue PCIe* EIEOS at Incorrect Rate  	  When initiating a Secondary Bus Reset or Link Disable procedure while a PCIe Link is in Recovery state, the processor should send an EIEOS (Electrical Idle Exit Ordered Set) after every 32 TS (Training Set) Ordered Sets. Due to this erratum, the processor may send an EIEOS after every 33 TS Ordered Sets.  	  The processor may send an incorrect number of TS Ordered Sets between two EIEOS Ordered Sets when it initiates Secondary Bus Reset or Link Disable. Intel has not observed any failures with commercially available devices due to this erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reduced Swing Output Mode Needs Zero De-emphasis to be Supported in PCIe* 5GT/s Speed  	  It may not be possible to support the PCIe Transmitter Preset 1 and/or Transmitter Preset 0 equalization requests in Phase 0 or Phase 2 of Recovery.Equalization LTSSM states when operating in 8GT/s in reduced or half swing mode, if 0dB transmitter deemphasis needs to be supported when operating at 5GT/s.  	  This erratum does not affect normal full swing mode of operation. Endpoints requiring 0dB support in half-swing mode should avoid requesting Transmitter Preset 1 and/or Transmitter Preset 0 as preset requests in Phase 0 or Phase 2 of Recovery.Equalization when operating in 8GT/s.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   37 
  PCIe* Root-port Initiated Compliance State Transmitter Equalization Settings May be Incorrect  	  If the processor is directed to enter PCIe Polling.Compliance at 5.0 GT/s or 8.0 GT/s transfer rates, it should use the Link Control 2 Compliance Preset/De-emphasis field (bits [15:12]) to determine the correct de-emphasis level. Due to this erratum, when the processor is directed to enter Polling.Compliance from 2.5 GT/s transfer rate, it retains 2.5 GT/s de-emphasis values.  	  The processor may operate in Polling.Compliance mode with an incorrect transmitter de-emphasis level.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Controller May Incorrectly Log Errors on Transition to RxL0s  	  Due to this erratum, if a link partner transitions to RxL0s state within 20 ns of entering L0 state, the PCIe controller may incorrectly log an error in ?Correctable Error Status.Receiver Error Status? field (Bus 0, Device 2, Function 0, 1, 2 and Device 6, Function 0, offset 1D0H, bit 0).  	  Correctable receiver errors may be incorrectly logged. Intel has not observed any functional impact due to this erratum with any commercially available add-in cards.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reception of Certain Malformed Transactions May Cause PCIe* Port to Hang Rather Than Reporting an Error  	  If the processor receives an upstream malformed non posted packet for which the type field is IO, Configuration or the deprecated TCfgRd and the format is 4 DW header, then due to this erratum the integrated PCIe controller may hang instead of reporting the malformed packet error or issuing an unsupported request completion transaction.  	  Due to this erratum, the processor may hang without reporting errors when receiving a malformed PCIe transaction. Intel has not observed this erratum with any commercially available device.  	 None identified. Upstream transaction initiators should avoid issuing unsupported requests with 4 DW header formats. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Link Width May Degrade After a Warm Reset  	  PCIe link width may degrade after a warm reset if the Link is operating at 8.0 GT/s or 5.0 GT/s transfer speeds prior to the reset.  	  Due to this erratum, the PCIe link may retain to a narrower width, e.g. from x16 to x4.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. . 	  38  For the steppings affected, see the Summary Tables of Changes.  
  MSR_PKG_Cx_RESIDENCY MSRs May Not be Accurate  	  If the processor is in a package C-state for an extended period of time (greater than 40 seconds) with no wake events, the value in the MSR_PKG_C{2,3,6,7}_RESIDENCY MSRs (60DH and 3F8H–3FAH) will not be accurate.  	  Utilities that report C-state residency times will report incorrect data in cases of long duration package C-states.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of Package C7 May Result in a Hang  	  Under certain conditions, execution of Package C7 may result in a system hang on a subsequent C7 exit.  	  Due to this erratum, the processor package may not exit Package C7, resulting in a system hang.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Link May Not Enter Loopback.Active When Directed  	  When an endpoint directs the processor to enter loopback slave mode at 8 GT/s via TS1 ordered sets with both the Loopback and Compliance Receive bits set, the PCIe link should directly enter Loopback.Active state. Due to this erratum, the processor must achieve block alignment on all looped back lanes prior to entering Loopback.Active.  	  The processor will not enter Loopback.Active state as a loopback slave if any lane in a link cannot achieve block alignment.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for VEX.vvvv May Produce a #NM Exception  	  The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (InvalidOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to this erratum, if CR0.TS is “1”, the processor may instead produce a #NM (Device-NotAvailable) exception.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should always set the vvvv field of the VEX prefix to 1111b for instances of the VAESIMC and VAESKEYGENASSIST instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VZEROALL/VZEROUPPER  	  Execution of the VZEROALL or VZEROUPPER instructions in 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.  	 Compilers should encode VEX.W = 0 for the VZEROALL and VZEROUPPER instructions. 	  For the steppings affected, see the Summary Tables of Changes.   39 
  PCIe* Root Port May Not Initiate Link Speed Change  	  The PCIe Base specification requires the upstream component to maintain the PCIe link at the target link speed or the highest speed supported by both components on the link, whichever is lower. PCIe root port will not initiate the link speed change without being triggered by the software when the root port maximum link speed is configured to be 5.0 GT/s. System BIOS will trigger the link speed change under normal boot scenarios. However, BIOS is not involved in some scenarios such as link disable/reenable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. This erratum does not affect the ability of the downstream component to initiate a link speed change. All known 5.0Gb/s-capable PCIe downstream components have been observed to initiate the link speed change without relying on the root port to do so.  	  Due to this erratum, the PCIe root port may not initiate a link speed change during some hardware scenarios causing the PCIe link to operate at a lower than expected speed. Intel has not observed this erratum with any commercially available platform.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in	NA	NA	NA
 Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	NA	  Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used.  	 Software can avoid this by: 1. Avoid using Freeze PerfMon on PMI bit 2. Enable only one fixed counter at a time when using Freeze PerfMon on PMI 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of FXSAVE or FXRSTOR With the VEX Prefix May Produce a #NM Exception  	  Attempt to use FXSAVE or FXRSTOR with a VEX prefix should produce a #UD (InvalidOpcode) exception. If either the TS or EM flag bits in CR0 are set, a #NM (device-notavailable) exception will be raised instead of #UD exception.  	  Due to this erratum a #NM exception may be signaled instead of a #UD exception on an FXSAVE or an FXRSTOR with a VEX prefix.  	 Software should not use FXSAVE or FXRSTOR with the VEX prefix. 	  40  For the steppings affected, see the Summary Tables of Changes.  
  VM Exits Due to “NMI-Window Exiting” May Not Occur Following a VM Entry to the Shutdown State  	  If VM entry is made with the “virtual NMIs” and “NMI-window exiting”, VM-execution controls set to 1, and if there is no virtual-NMI blocking after VM entry, a VM exit with exit reason “NMI window” should occur immediately after VM entry unless the VM entry put the logical processor in the wait-for SIPI state. Due to this erratum, such VM exits do not occur if the VM entry put the processor in the shutdown state.  	  A VMM may fail to deliver a virtual NMI to a virtual machine in the shutdown state.  	 Before performing a VM entry to the shutdown state, software should check whether the “virtual NMIs” and “NMI-window exiting” VM-execution controls are both 1. If they are, software should clear “NMI-window exiting” and inject an NMI as part of VM entry. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of INVVPID Outside 64-Bit Mode Cannot Invalidate Translations For 64-Bit Linear Addresses  	  Executions of the INVVPID instruction outside 64-bit mode with the INVVPID type “individual-address invalidation” ignore bits 63:32 of the linear address in the INVVPID descriptor and invalidate translations for bits 31:0 of the linear address.  	  The INVVPID instruction may fail to invalidate translations for linear addresses that set bits in the range 63:32. Because this erratum applies only to executions outside 64-bit mode, it applies only to attempts by a 32-bit virtual-machine monitor (VMM) to invalidate translations for a 64-bit guest. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Controller May Not Properly Indicate Link Electrical Idle Condition  	  The processor supports a x16 PCIe* port, which can be bifurcated into three independent links, enumerated as Bus 0, Device 1, Function 0-2. Due to this erratum, if the port is bifurcated and Function 1 or 2 is disabled, the PCIe controller may not properly indicate Link electrical idle condition to the Power Control Unit.  	  An incorrect Link electrical idle indication may prevent the processor from entering the lowest power mode, which may cause higher power consumption on VccIO and VccSA. Intel has not observed any functional failure or performance impact due to this erratum.  	 If Bus 0, Device 1, Function 1 or 2 is disabled, do not configure the x16 port to allocate lanes to those functions. 	  For the steppings affected, see the Summary Tables of Changes.   41 
  PCIe* Controller May Not Enter Loopback  	  The PCIe controller is expected to enter loopback if any lane in the link receives two consecutive TS1 ordered sets with the Loopback bit set. Due to this erratum, if two consecutive TS1 ordered sets are received only on certain lanes, the controller may not enter loopback.  	  Intel has not observed any functional issue with any commercially available PCIe devices.  	  None Identified.  	  For the steppings affected, see the Summary Tables of Changes. 
  Link Margin Characterization May Hang Link  	  The processor supports tools and mechanisms to characterize and measure margins for the PCIe interface. Due to this erratum, when performing link margin-to-failure characterization, it is possible that a high bit error rate may cause the link to hang.  	  Under extreme conditions, poor link quality during link characterization may result in processor hang. Intel has not observed this erratum with any commercially available platforms under normal operating conditions.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unused PCIe* Lanes May Report Correctable Errors  	  Due to this erratum, during PCIe* link downconfiguration, unused lanes may report a Correctable Error Detected in Bus 0, Device 1, Function 0-2, and Device 6, Function 0, Offset 158H, Bit 0.  	  Correctable Errors may be reported by a PCIe controller for unused lanes.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  RDMSR of IA32_PERFEVTSEL{4-7} May Return Erroneous Information  	  When CPUID.0AH:EAX[15:8] reports 8 general-purpose performance monitoring counters per logical processor, RDMSR of IA32_PERFEVTSEL{4-7} (MSR 18AH-18DH) may not return the same value previously written by software.  	  Software should not rely on values read from these MSRs.  	 None identified. 	  42  For the steppings affected, see the Summary Tables of Changes.  
  PCIe* Link May Fail Link Width Upconfiguration  	  The processor supports PCIe Hardware Autonomous Width management, in which a PCIe link can autonomously vary its width. Due to this erratum, a link that performs a speed change while in a reduced width may no longer be able to return to a wider link width.  	  PCIe links that perform speed changes while at a reduced link width may be limited to the link width in effect at the time of the speed change. Intel has not observed this erratum with any commercially available devices or platforms.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Graphics L3 Cache Parity Errors May Not be Detected  	  The graphics engine should detect parity errors within the Graphics L3 cache. However, due to this erratum, graphics L3 cache parity errors may not be detected.  	  There may be undetected parity errors from workloads submitted to the execution units of the graphics engine leading to unpredictable graphics system behavior.  	  It is possible for the graphics driver to contain a workaround for this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  A PCIe* Link That is in Link Disable State May Prevent DDR I/O Buffers From Entering a Power Gated State  	  When entering Link Disable LTSSM state, the PCIe controller may not properly indicate the Link electrical idle condition.  	  An incorrect Link electrical idle indication may prevent the DDR I/O buffers from entering a power gated state, which may cause higher power consumption on VccIO and VccSA. Intel has not observed any functional failure or performance impact due to this erratum.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Graphics L3 Cache Redundancy May Not Behave as Expected  	  The processor graphics L3 cache is designed to have redundancy to improve resilience to cache related errors. Due to this erratum, that redundancy may not function as expected, resulting in a potential increase in L3 cache related errors.  	  Under certain conditions, the lack of redundancy may lead to unpredictable graphics system behavior when processor graphics L3 cache is utilized.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   43 
  REP MOVSB May Incorrectly Update ECX, ESI, and EDI  	  Under certain conditions, if the execution of a REP MOVSB instruction is interrupted, the values of ECX, ESI and EDI may contain values that represent a later point in the execution of the instruction than the actual interruption point.  	  Due to this erratum ECX, ESI, and EDI may be incorrectly advanced, resulting in unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes 
  Performance-Counter Overflow Indication May Cause Undesired Behavior  	  Under certain conditions (listed below) when a performance counter overflows, its overflow indication may remain set indefinitely. This erratum affects the generalpurpose performance counters IA32_PMC{0-7} and the fixed-function performance counters IA32_FIXED_CTR{0-2}. The erratum may occur if any of the following conditions are applied concurrent to when an actual counter overflow condition is reached: 1. Software disables the counter either globally through the IA32_PERF_GLOBAL_CTRL MSR (38FH), or locally through the IA32_PERFEVTSEL{0-7} MSRs (186H-18DH), or the IA32_FIXED_CTR_CTRL MSR (38DH).	NA	NA	NA
 [12]. 3. The processor attempts to disable the counters by updating the state of the IA32_PERF_GLOBAL_CTRL MSR (38FH) as part of transitions such as VM exit, VM entry, SMI, RSM, or processor C-state.  	NA	  Due to this erratum, the corresponding overflow status bit in IA32_PERF_GLOBAL_STATUS MSR (38DH) for an affected counter may not get cleared when expected. If a corresponding counter is configured to issue a PMI (performance monitor interrupt), multiple PMIs may be signaled from the same overflow condition. Likewise, if a corresponding counter is configured in PEBS mode (applies to only the general purpose counters), multiple PEBS events may be signaled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes 
  RDMSR of IA32_PERFEVTSEL4-7 May Return an Incorrect Result  	  When CPUID.A.EAX[15:8] reports 8 general-purpose performance monitoring counters per logical processor, RDMSR of IA32_PERFEVTSEL4-7 (MSR 18AH:18DH) may not return the same value as previously written.  	  Software should not rely on the value read from these MSRs. Writing these MSRs functions as expected.  	 None identified. 	  44  For the steppings affected, see the Summary Tables of Changes  
  VEX.L is Not Ignored with VCVT*2SI Instructions  	  The VEX.L bit should be ignored for the VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions, however due to this erratum the VEX.L bit is not ignored and will cause a #UD.  	  Unexpected #UDs will be seen when the VEX.L bit is set to 1 with VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions.  	 Software should ensure that the VEX.L bit is set to 0 for all scalar instructions. 	  For the steppings affected, see the Summary Tables of Changes 
  Intel® Turbo Boost Technology May be Incorrectly Reported as Supported on Intel® Core™ i3-3217U  	  The Intel® Core™ i3-3217U processor may incorrectly report support for Intel® Turbo Boost Technology via CPUID.06H.EAX bit 1.  	  The CPUID instruction may report Turbo Boost Technology as supported even though the processor does not permit operation above the Maximum Non-Turbo Frequency.  	 None identified 	  For the steppings affected, see the Summary Tables of Changes 
  Concurrently Changing the Memory Type and Page Size May Lead to a System Hang  	  Under a complex set of microarchitectural conditions, the system may hang if software changes the memory type and page size used to translate a linear address while a TLB (Translation Lookaside Buffer) holds a valid translation for that linear address.  	  Due to this erratum, the system may hang. Intel has not observed this erratum with any commercially available software.  	 None identified. Please refer to Software Developer’s Manual, volume 3, section “Recommended Invalidation” for the proper procedure for concurrently changing page attributes and page size. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCI_ADDR May be Incorrect For Cache Parity Errors  	  In cases when a WBINVD instruction evicts a line containing an address or data parity error (MCACOD of 0x124, and MSCOD of 0x10), the address of this error should be logged in the MCi_ADDR register. Due to this erratum, the logged address may be incorrect, even though MCi_Status.ADDRV (bit 63) is set.  	  The address reported in MCi_ADDR may not be correct for cases of a parity error found during WBINVD execution.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   45 
  During Package Power States Repeated PCIe* and/or DMI L1 Transitions May Cause a System Hang  	  Under a complex set of internal conditions and operating temperature, when the processor is in a deep power state (package C3, C6 or C7) and the PCIe and/or DMI links are toggling in and out of L1 state, the system may hang.  	  Due to this erratum, the system may hang.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetches Page-Table Walks May be Made Speculatively to Uncacheable Memory  	  Page-table walks on behalf of instruction fetches may be made speculatively to uncacheable (UC) memory.  	  If any paging structures are located at addresses in uncacheable memory that are used for memory-mapped I/O, such I/O operations may be invoked as a result of speculative execution that would never actually occur in the executed code path. Intel has not observed this erratum with any commercially available software.  	 Software should avoid locating paging structures at addresses in uncacheable memory  that are used for memory-mapped I/O. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Not Properly Execute Code Modified Using A Floating-Point Store  	  Under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.  	  Self- or cross-modifying code may not execute as expected. Intel has not observed this erratum with any commercially available software.  	 None identified. Do not use floating-point stores to modify code. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of GETSEC[SEXIT] May Cause a Debug Exception to be Lost  	  A debug exception occurring at the same time that GETSEC[SEXIT] is executed or when an SEXIT doorbell event is serviced may be lost.  	  Due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of GETSEC[SEXIT]. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  46  For the steppings affected, see the Summary Tables of Changes.  
  VM Exits Due to GETSEC May Save an Incorrect Value for “Blocking by STI” in the Context of Probe-Mode Redirection  	  The GETSEC instruction causes a VM exit when executed in VMX non-root operation. Such a VM exit should set bit 0 in the Interruptability-state field in the virtual-machine control structure (VMCS) if the STI instruction was blocking interrupts at the time GETSEC commenced execution. Due to this erratum, a VM exit executed in VMX non-root operation may erroneously clear bit 0 if redirection to probe mode occurs on the GETSEC instruction.  	  After returning from probe mode, a virtual interrupt may be incorrectly delivered prior to GETSEC instruction. Intel has not observed this erratum with any commercially software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Specific Graphics Blitter Instructions May Result in Unpredictable Graphics Controller Behavior  	  Specific source-copy blitter instructions in Intel® HD Graphics 2500 and 4000 Processor may result in unpredictable behavior when a blit source and destination overlap.  	  Due to this erratum, the processor may exhibit unpredictable graphics controller behavior. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC5_CTL2 is Not Cleared by a Warm Reset  	  IA32_MC5_CTL2 MSR (285H) is documented to be cleared on any reset. Due to this erratum this MSR is only cleared upon a cold reset.  	  The algorithm documented in Software Developer's Manual, Volume 3, section titled "CMCI Initialization" or any other algorithm that counts the IA32_MC5_CTL2 MSR being cleared on reset will not function as expected after a warm reset.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction May Not Report the Processor Number in the Brand String for Intel® Core™ i3-3227U and i5-3337U Processors.  	  When the CPUID instruction is executed with EAX = 80000002H, 80000003H, and 80000004H, the returned brand string may be incomplete; it may be missing the processor number.  	  When this erratum occurs, the processor may be missing the processor number in the brand string. In addition, if the affected processors are paired with the Intel® 7 Series Chipset BD82UM77 chipset, the BIOS may incorrectly report this combination as unsupported.  	 It is possible for the BIOS to contain a workaround for this erratum, except if paired with the Intel 7 Series Chipset BD82UM77 chipset. 	  For the steppings affected, see the Summary Tables of Changes.   47 
  Performance Monitor Counters May Produce Incorrect Results  	  When operating in hyper-threaded mode, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled counter on the physical core’s other thread rather than the thread experiencing the event.  The list of affected memory at-retirement events is as follows: MEM_UOP_RETIRED.LOADS MEM_UOP_RETIRED.STORES MEM_UOP_RETIRED.LOCK MEM_UOP_RETIRED.SPLIT MEM_UOP_RETIRED.STLB_MISS MEM_LOAD_UOPS_RETIRED.HIT_LFB MEM_LOAD_UOPS_RETIRED.L1_HIT MEM_LOAD_UOPS_RETIRED.L2_HIT MEM_LOAD_UOPS_RETIRED.LLC_HIT MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HIT MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HITM MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_MISS MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_NONE MEM_LOAD_UOPS_RETIRED.LLC_MISS MEM_LOAD_UOPS_LLC_MISS_RETIRED.LOCAL_DRAM MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_DRAM MEM_LOAD_UOPS_RETIRED.L2_MISS 	  Due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	  The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Spurious VT-d Interrupts May Occur When the PFO Bit is Set  	  When the PFO (Primary Fault Overflow) field (bit [0] in the VT-d FSTS [Fault Status] register) is set to 1, further faults should not generate an interrupt. Due to this erratum, further interrupts may still occur.  	  Unexpected Invalidation Queue Error interrupts may occur. Intel has not observed this erratum with any commercially available software.  	 Software should be written to handle spurious VT-d fault interrupts. 	  48  For the steppings affected, see the Summary Tables of Changes.  
  Processor May Livelock During On Demand Clock Modulation  	  The processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the IA32_CLOCK_MODULATION MSR (19AH) and the clock modulation duty cycle is set to 12.5 % (02H in bits 3:0 of the same MSR), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access UC memory.  	  Program execution may stall on both threads of the core subject to this erratum.  	 This erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the IA32_CLOCK_MODULATION MSR is 18.75% or higher. 	NA
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions as described in the Software Developers Manual section "Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors" the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation. 	Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May Be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g., NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commerciallyavailable software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   17  
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	 Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. • If an instruction that performs a memory load causes a code segment limit violation. • If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending. • If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Topof-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	 In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the sideeffect. Particularly, while CR0.TS [Bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception. 	Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault. 	In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  18  For the steppings affected, see the Summary Tables of Changes.   
  Incorrect Address Computed for Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM Will Be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect.  Note:  This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e., residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer's Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in Ring 3. Faults are usually processed in Ring 0 and stack switch occurs when transferring to Ring 0. Intel has not observed this erratum on any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   19  
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection Fault (#GP) for Instructions Greater Than 15 Bytes May Be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g., Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	 Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4-G limit (0ffffffffh) may not signal a #GP fault.  	 When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault. 	Software should ensure that memory accesses in 32-bit mode do not occur above the 4-G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address When an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with Bits 63 to 48 incorrectly sign extended to all 1's. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	 LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt. 	None identified. 	  20  For the steppings affected, see the Summary Tables of Changes.   
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	 When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially-available software. 	Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register during RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, Bit 0) and the first FAR JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first FAR JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the FAR JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Read Miss to Level 3 Cache Fill Occupancy Counter May Be Incorrect  	  Whenever an Level 3 cache fill conflicts with another request's address, the miss to fill occupancy counter, UNC_GQ_ALLOC.RT_LLC_MISS (Event 02H), will provide erroneous results.  	 The Performance Monitoring UNC_GQ_ALLOC.RT_LLC_MISS event may count a value higher than expected. The extent to which the value is higher than expected is determined by the frequency of the L3 address conflict. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   21  
  A VM Exit on MWAIT May Incorrectly Report the Monitoring Hardware As Armed  	  A processor write to the address range armed by the MONITOR instruction may not immediately trigger the monitoring hardware. Consequently, a VM exit on a later MWAIT may incorrectly report the monitoring hardware as armed, when it should be reported as unarmed due to the write occurring prior to the MWAIT.  	 If a write to the range armed by the MONITOR instruction occurs between the MONITOR and the MWAIT, the MWAIT instruction may start executing before the monitoring hardware is triggered. If the MWAIT instruction causes a VM exit, this could cause its exit qualification to incorrectly report 0x1. In the recommended usage model for MONITOR/MWAIT, there is no write to the range armed by the MONITOR instruction between the MONITOR and the MWAIT. 	Software should never write to the address range armed by the MONITOR instruction between the MONITOR and the subsequent MWAIT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Delivery Status of the LINT0 Register of the Local Vector Table May Be Lost  	  The Delivery Status bit of the LINT0 Register of the Local Vector Table will not be restored after a transition out of C6 under the following conditions • LINT0 is programmed as level-triggered • The delivery mode is set to either Fixed or ExtINT • There is a pending interrupt which is masked with the interrupt enable flag (IF)  	 Due to this erratum, the Delivery Status bit of the LINT0 Register will unexpectedly not be set. Intel has not observed this erratum with any commercially available software or system. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event SEGMENT_REG_LOADS Counts Inaccurately  	  The performance monitor event SEGMENT_REG_LOADS (Event 06H) counts instructions that load new values into segment registers. The value of the count may be inaccurate.  	 The performance monitor event SEGMENT_REG_LOADS may reflect a count higher or lower than the actual number of events. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	 An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.   
  Improper Parity Error Signaled in the IQ Following Reset When a Code Breakpoint Is Set on a #GP Instruction  	  While coming out of cold reset or exiting from C6, if the processor encounters an instruction longer than 15 bytes (which causes a #GP) and a code breakpoint is enabled on that instruction, an IQ (Instruction Queue) parity error may be incorrectly logged resulting in an MCE (Machine Check Exception).  	 When this erratum occurs, an MCE may be incorrectly signaled. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction If It Is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially-available software or system. 	As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MPERF Counter Stops Counting during On-Demand TM1  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, the ratio of IA32_MPERF (MSR E7H) to IA32_APERF (MSR E8H) should reflect actual performance while TM1 or on-demand throttling is activated. Due to this erratum, IA32_MPERF MSR stops counting while TM1 or on-demand throttling is activated, and the ratio of the two will indicate higher processor performance than actual.  	 The incorrect ratio of IA32_APERF/IA32_MPERF can mislead software P-state (performance state) management algorithms under the conditions described above. It is possible for the Operating System to observe higher processor utilization than actual, which could lead the OS into raising the P-state. During TM1 activation, the OS P-state request is irrelevant and while on-demand throttling is enabled, it is expected that the OS will not be changing the P-state. This erratum should result in no practical implication to software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23  
  The Memory Controller tTHROT_OPREF Timings May Be Violated during Self Refresh Entry  	  During self-refresh entry, the memory controller may issue more refreshes than permitted by tTHROT_OPREF (bits 29:19 in MC_CHANNEL_{0,1}_REFRESH_TIMING CSR).  	 The intention of tTHROT_OPREF is to limit current. Since current supply conditions near self refresh entry are not critical, there is no measurable impact due to this erratum. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Over Count Correctable Cache MESI State Errors  	  Under a specific set of conditions, correctable Level 2 cache hierarchy MESI state errors may be counted more than once per occurrence of a correctable error.  	 Correctable Level 2 cache hierarchy MESI state errors may be reported in the MCi_STATUS register at a rate higher than their actual occurrence. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Synchronous Reset of IA32_APERF/IA32_MPERF Counters on Overflow Does Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. This synchronous reset does not work. Instead, both MSRs increment and overflow independently.  	 Software can not rely on synchronous reset of the IA32_APERF/IA32_MPERF registers. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Disabling Thermal Monitor While Processor Is Hot, Then Re-enabling, May Result in Stuck Core Operating Ratio  	  If a processor is at its TCC (Thermal Control Circuit) activation temperature and then Thermal Monitor is disabled by a write to IA32_MISC_ENABLES MSR (1A0H) Bit [3], a subsequent re-enable of Thermal Monitor will result in an artificial ceiling on the maximum core P-state. The ceiling is based on the core frequency at the time of Thermal Monitor disable. This condition will only correct itself once the processor reaches its TCC activation temperature again.  	 Since Intel requires that Thermal Monitor be enabled in order to be operating within specification, this erratum should never be seen during normal operation. 	Software should not disable Thermal Monitor during processor operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  OVER Bit for IA32_MCi_STATUS Register May Get Set on Specific lnternal Error  	  If a specific type of internal unclassified error is detected, as identified by IA32_MCi_STATUS.MCACOD=0x0405, the IA32_MCi_ STATUS.OVER (overflow) Bit [62] may be erroneously set.  	 The OVER bit of the MCi_STATUS register may be incorrectly set for a specific internal unclassified error. 	None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.   
  Writing the Local Vector Table (LVT) When an Interrupt Is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting Intel® MMX™ Technology Instruction May Incorrectly Update x87 FPU Tag Word  	  Under a specific set of conditions, Intel MMX technology stores (MOVD, MOVQ, MOVNTQ, MASKMOVQ) which cause memory access faults (#GP, #SS, #PF, or #AC), may incorrectly update the x87 FPU tag word register. This erratum will occur when the following additional conditions are also met. • The Intel MMX technology store instruction must be the first Intel MMX technology instruction to operate on x87 FPU state (i.e. the x87 FP tag word is not already set to 0x0000). • For MOVD, MOVQ, MOVNTQ stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to MASKMOVQ).  	 If the erratum conditions are met, the x87 FPU tag word register may be incorrectly set to a 0x0000 value when it should not have been modified. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  xAPIC Timer May Decrement Too Quickly following an Automatic Reload While in Periodic Mode  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	 When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   25  
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	 Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type. 	Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 for Non-Enabled Breakpoints May Be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1. MOV or POP instruction to SS (Stack Segment) selector; 2. Next instruction is FP (Floating Point) that gets FP assist 3. Another instruction after the FP instruction completes successfully 4. A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4.  	 Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints. 	Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes. 
  Core C6 May Clear Previously Logged TLB Errors  	  Following an exit from core C6, previously logged TLB (Translation Lookaside Buffer) errors in IA32_MCi_STATUS may be cleared.  	 Due to this erratum, TLB errors logged in the associated machine check bank prior to core C6 entry may be cleared. Provided machine check exceptions are enabled, the machine check exception handler can log any uncorrectable TLB errors prior to core C6 entry. The TLB marks all detected errors as uncorrectable. 	As long as machine check exceptions are enabled, the machine check exception handler can log the TLB error prior to core C6 entry. This will ensure the error is logged before it is cleared. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event MISALIGN_MEM_REF May Over Count  	  The MISALIGN_MEM_REF Performance Monitoring (Event 05H) may over count memory misalignment events, possibly by orders of magnitude.  	 Software relying on MISALIGN_MEM_REF to count cache line splits for optimization purposes may read excessive number of memory misalignment events. 	None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	 Memory ordering may be violated. Intel has not observed this erratum with any commercially-available software. 	Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
  Running with Write Major Mode Disabled May Lead to a System Hang  	  With write major mode disabled, reads will be favored over writes and under certain circumstances this can lead to a system hang.  	 Due to this erratum a system hang may occur. 	It is possible for the BIOS to contain a workaround for this erratum 	  For the steppings affected, see the Summary Tables of Changes. 
  Infinite Stream of Interrupts May Occur If an ExtINT Delivery Mode Interrupt Is Received While All Cores in C6  	  If all logical processors in a core are in C6, an ExtINT delivery mode interrupt is pending in the xAPIC and interrupts are blocked with EFLAGS.IF=0, the interrupt will be processed after C6 wakeup and after interrupts are re-enabled (EFLAGS.IF=1). However, the pending interrupt event will not be cleared.  	 Due to this erratum, an infinite stream of interrupts will occur on the core servicing the external interrupt. Intel has not observed this erratum with any commercially-available software/system. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Two xAPIC Timer Event Interrupts May Unexpectedly Occur  	  If an xAPIC timer event is enabled and while counting down the current count reaches 1 at the same time that the processor thread begins a transition to a low power Cstate, the xAPIC may generate two interrupts instead of the expected one when the processor returns to C0.  	 Due to this erratum, two interrupts may unexpectedly be generated by an xAPIC timer event. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EOI Transaction May Not Be Sent If Software Enters Core C6 during an Interrupt Service Routine  	  If core C6 is entered after the start of an interrupt service routine but before a write to the APIC EOI register, the core may not send an EOI transaction (if needed) and further interrupts from the same priority level or lower may be blocked.  	 EOI transactions may be lost and interrupts may be blocked when core C6 is used during interrupt service routines. 	Software should check the ISR register and if any interrupts are in service only enter C1. 	  For the steppings affected, see the Summary Tables of Changes.   27  
  FREEZE_WHILE_SMM Does Not Prevent Event from Pending PEBS during SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, Bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if 1. a performance counter overflowed before an SMI 2. a PEBS record has not yet been generated because another count of the event has not occurred 3. the monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM.  	 A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May Be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector Bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	 Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6 May Contain Incorrect Information When the First Instruction after a MOV SS,r/m or POP SS Is a Store  	  Normally, each instruction clears the changes in DR6 (Debug Status Register) caused by the previous instruction. However, the instruction following a MOV SS,r/m (MOV to the stack segment selector) or POP SS (POP stack segment selector) instruction will not clear the changes in DR6 because data breakpoints are not taken immediately after a MOV SS,r/m or POP SS instruction. Due to this erratum, any DR6 changes caused by a MOV SS,r/m or POP SS instruction may be cleared if the following instruction is a store.  	 When this erratum occurs, incorrect information may exist in DR6. This erratum will not be observed under normal usage of the MOV SS,r/m or POP SS instructions (i.e., following them with an instruction that writes [e/r]SP). When debugging or when developing debuggers, this behavior should be noted. 	None identified. 	  28  For the steppings affected, see the Summary Tables of Changes.   
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	 Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_PERF_GLOBAL_CTRL MSR May Be Incorrectly Initialized  	  The IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [34:32] may be incorrectly set to 7H after reset; the correct value should be 0H.  	 The IA32_PERF_GLOBAL_CTRL MSR bits [34:32] may be incorrect after reset (EN_FIXED_CTR{0, 1, 2} may be enabled). 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Interrupts Generated from Uncore Fixed Counters (394H) May Be Ignored  	  Performance monitor interrupts (PMI’s) from Uncore fixed counters are ignored when Uncore general performance monitor counters 3B0H-3BFH are not programmed.  	 This erratum blocks a usage model in which each of the cores can sample its own performance monitor events synchronously based on single interrupt from the Uncore. 	Program any one of the Uncore general performance monitor counters with a valid performance monitor event and enable the event by setting the local enable bit in the corresponding performance monitor event select MSR. For the usage model where no counting is desired, program that Uncore general performance counter's global enable bit to be zero. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counter INST_RETIRED.STORES May Count Higher Than Expected  	  Performance Monitoring counter INST_RETIRED.STORES (Event: C0H) is used to track retired instructions which contain a store operation. Due to this erratum, the processor may also count other types of instructions including WRMSR and MFENCE.  	 Performance Monitoring counter INST_RETIRED.STORES may report counts higher than expected. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29  
  Sleeping Cores May Not Be Woken Up on Logical Cluster Mode Broadcast IPI Using Destination Field Instead of Shorthand  	  If software sends a logical cluster broadcast IPI using a destination shorthand of 00B (No Shorthand) and writes the cluster portion of the Destination Field of the Interrupt Command Register to all ones while not using all 1s in the mask portion of the Destination Field, target cores in a sleep state that are identified by the mask portion of the Destination Field may not be woken up. This erratum does not occur if the destination shorthand is set to 10B (All Including Self) or 11B (All Excluding Self).  	 When this erratum occurs, cores which are in a sleep state may not wake up to handle the broadcast IPI. Intel has not observed this erratum with any commercially-available software. 	Use destination shorthand of 10B or 11B to send broadcast IPIs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting Executions of FXRSTOR May Update State Inconsistently  	  The state updated by a faulting FXRSTOR instruction may vary from one execution to another.  	 Software that relies on x87 state or SSE state following a faulting execution of FXRSTOR may behave inconsistently. 	Software handling a fault on an execution of FXRSTOR can compensate for execution variability by correcting the cause of the fault and executing FXRSTOR again. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event EPT.EPDPE_MISS May Be Counted While EPT Is Disabled  	  Performance monitor event EPT.EPDPE_MISS (Event: 4FH, Umask: 08H) is used to count Page Directory Pointer table misses while EPT (extended page tables) is enabled. Due to this erratum, the processor will count Page Directory Pointer table misses regardless of whether EPT is enabled or not.  	 Due to this erratum, performance monitor event EPT.EPDPE_MISS may report counts higher than expected. 	Software should ensure this event is only enabled while in EPT mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  Memory Aliasing of Code Pages May Cause Unpredictable System Behavior  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncachable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	 If this erratum occurs the system may have unpredictable behavior including a system hang. The aliasing of memory regions, a condition necessary for this erratum to occur, is documented as being unsupported in the Intel 64 and IA-32 Intel® Architecture Software Developer's Manual, Volume 3A, in the section titled Programming the PAT. Intel has not observed this erratum with any commercially-available software or system. 	Code pages should not be mapped with uncacheable and cacheable memory types at the same time. 	  30  For the steppings affected, see the Summary Tables of Changes.   
  Performance Monitor Counters May Count Incorrectly  	  Under certain circumstances, a general purpose performance counter, IA32_PMC0-4 (C1H - C4H), may count at core frequency or not count at all instead of counting the programmed event.  	 The Performance Monitor Counter IA32_PMCx may not properly count the programmed event. Due to the requirements of the workaround there may be an interruption in the counting of a previously programmed event during the programming of a new event. 	Before programming the performance event select registers, IA32_PERFEVTSELx MSR (186H - 189H), the internal monitoring hardware must be cleared. This is accomplished by first disabling, saving valid events and clearing from the select registers, then programming three event values 0x4300D2, 0x4300B1 and 0x4300B5 into the IA32_PERFEVTSELx MSRs, and finally continuing with new event programming and restoring previous programming if necessary. Each performance counter, IA32_PMCx, must have its corresponding IA32_PREFEVTSELx MSR programmed with at least one of the event values and must be enabled in IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [3:0]. All three values must be written to either the same or different IA32_PERFEVTSELx MSRs before programming the performance counters. Note that the performance counter will not increment when its IA32_PERFEVTSELx MSR has a value of 0x4300D2, 0x4300B1 or 0x4300B5 because those values have a zero UMASK field (bits [15:8]). 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor Forward Progress Mechanism Interacting with Certain MSR/CSR Writes May Cause Unpredictable System Behavior  	  Under specific internal conditions, a mechanism within the processor to ensure forward progress may interact with writes to a limited set of MSRs/CSRs and consequently may lead to unpredictable system behavior.  	 This erratum may cause unpredictable system behavior. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event Offcore_response_0 (B7H) Does Not Count NT Stores to Local DRAM Correctly  	  When a IA32_PERFEVTSELx MSR is programmed to count the Offcore_response_0 event (Event:B7H), selections in the OFFCORE_RSP_0 MSR (1A6H) determine what is counted. The following two selections do not provide accurate counts when counting NT (Non-Temporal) Stores: • OFFCORE_RSP_0 MSR Bit [14] is set to 1 (LOCAL_DRAM) and Bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are not counted when they should have been. • OFFCORE_RSP_0 MSR Bit [9] is set to (OTHER_CORE_HIT_SNOOP) and Bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are counted when they should not have been.  	 The counter for the Offcore_response_0 event may be incorrect for NT stores. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   31  
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	 None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit. 	If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  System May Hang if MC_CHANNEL_{0,1}_MC_DIMM_INIT_CMD.DO_ZQCL Commands Are Not Issued in Increasing Populated DDR3 Rank Order  	  ZQCL commands are used during initialization to calibrate DDR3 termination. A ZQCL command can be issued by writing 1 to the MC_CHANNEL_{0,1}_MC_DIMM_INIT_CMD.DO_ZQCL (Device 4,5,6, Function 0, Offset 15, Bit[15]) field and it targets the DDR3 rank specified in the RANK field (bits[7:5]) of the same register. If the ZQCL commands are not issued in increasing populated rank order then ZQ calibration may not complete, causing the system to hang.  	 Due to this erratum the system may hang if writes to the MC_CHANNEL_{0,1}_MC_DIMM_INIT_CMD.DO_ZQCL field are not in increasing populated DDR3 rank order. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Package C3/C6 Transitions When Memory 2x Refresh Is Enabled May Result in a System Hang  	  If ASR_PRESENT (MC_CHANNEL_{0,1}_REFRESH_THROTTLE_SUPPORT CSR Function 0, Offset 68H, Bit [0], Auto Self Refresh Present) is clear which indicates that high temperature operation is not supported on the DRAM, the memory controller will not enter self-refresh if software has REF_2X_NOW (Bit 4 of the MC_CLOSED_LOOP CSR, Function 3, Offset 84H) set. This scenario may cause the system to hang during C3/C6 entry.  	 Failure to enter self-refresh can delay C3/C6 power state transitions to the point that a system hang may result with CATERR being asserted. REF_2X_NOW is used to double the refresh rate when the DRAM is operating in extended temperature range. The ASR_PRESENT was intended to allow low power self refresh with DRAM that does not support automatic self refresh. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  32  For the steppings affected, see the Summary Tables of Changes.   
  Back to Back Uncorrected Machine Check Errors May Overwrite IA32_MC3_STATUS.MSCOD  	  When back-to-back uncorrected machine check errors occur that would both be logged in the IA32_MC3_STATUS MSR (40CH), the IA32_MC3_STATUS.MSCOD (bits [31:16]) field may reflect the status of the most recent error and not the first error. The rest of the IA32_MC3_STATUS MSR contains the information from the first error.  	 Software should not rely on the value of IA32_MC3_STATUS.MSCOD if IA32_MC3_STATUS.OVER (Bit [62]) is set. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Memory Intensive Workloads with Core C6 Transitions May Cause System Hang  	  Under a complex set of internal conditions, a system running a high cache stress and I/ O workload combined with the presence of frequent core C6 transitions may result in a system hang.  	 Due to this erratum, the system may hang. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corrected Errors with a Yellow Error Indication May Be Overwritten by Other Corrected Errors  	  A corrected cache hierarchy data or tag error that is reported with IA32_MCi_STATUS.MCACOD (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one) and a yellow threshold-based error status indication (bits [54:53] equal to 10B) may be overwritten by a corrected error with a no tracking indication (00B) or green indication (01B).  	 Corrected errors with a yellow threshold-based error status indication may be overwritten by a corrected error without a yellow indication. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PSI# Signal May Incorrectly Be Left Asserted  	  When some of the cores in the processor are in C3/C6 state, the PSI# (Power Status Indicator) signal may incorrectly be left asserted when another core makes a frequency change request without changing the operating voltage. Since this erratum results in a possible maximum core current greater than the PSI# threshold of 15A, PSI# should have been de-asserted.  	 Due to this erratum, platform voltage regulator tolerances may be exceeded and a subsequent system reset may occur. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   33  
  Performance Monitor Events DCACHE_CACHE_LD and DCACHE_CACHE_ST May Overcount  	  The performance monitor events DCACHE_CACHE_LD (Event 40H) and DCACHE_CACHE_ST (Event 41H) count cacheable loads and stores that hit the L1 cache. Due to this erratum, in addition to counting the completed loads and stores, the counter will incorrectly count speculative loads and stores that were aborted prior to completion.  	 The performance monitor events DCACHE_CACHE_LD and DCACHE_CACHE_ST may reflect a count higher than the actual number of events. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Rapid Core C3/C6 Transitions May Cause Unpredictable System Behavior  	  Under a complex set of internal conditions, cores rapidly performing C3/C6 transitions in a system with Intel® Hyper-Threading Technology enabled may cause a machine check error (IA32_MCi_STATUS.MCACOD = 0x0106), system hang or unpredictable system behavior.  	 This erratum may cause a machine check error, system hang or unpredictable system behavior. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events INSTR_RETIRED and MEM_INST_RETIRED May Count Inaccurately  	  The performance monitor event INSTR_RETIRED (Event C0H) should count the number of instructions retired, and MEM_INST_ RETIRED (Event 0BH) should count the number of load or store instructions retired. However, due to this erratum, they may undercount.  	 The performance monitor event INSTR_RETIRED and MEM_INST_RETIRED may reflect a count lower than the actual number of events. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Page Fault May Not Be Generated When the PS Bit Is Set to "1" in a PML4E or PDPTE  	  On processors supporting Intel 64 architecture, the PS bit (Page Size, Bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	Software should not set Bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to "1". 	  34  For the steppings affected, see the Summary Tables of Changes.   
  CPURESET Bit Does Not Get Cleared  	  CPURESET (Bit 10 of SYRE Device 8; Function 2; Offset 0CCH) allows the processor to be independently reset without assertion of the PLTRST# signal upon a 0 to 1 transition. The CPURESET bit does not get cleared and must be cleared by software.  	 The processor will not be reset if a 1 is written to this bit while it is already a one. 	The CPURESET bit must be cleared by software prior to setting it. 	  For the steppings affected, see the Summary Tables of Changes. 
  PHOLD Disable in MISCCTRLSTS Register Does Not Work  	  PHOLD Disable (PCI Hold Disable, Bit [23] in MISCCTRLSTS Device 0; Function 0; Offset 188H) does not function as described. Setting this bit will not cause the processor to respond with Unsupported Request and log a fatal error upon receiving an Assert_PHOLD message from the PCH (Platform Controller Hub).  	 Due to this erratum, it is not possible to disable PHOLD requests from the PCH. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe PMCSR Power State Field Incorrectly Allows Requesting of the D1 and D2 Power States  	  The PCIe PMCSR (Power Management Control and Status Register, Device 3,4,5,6; Function 0; Offset E4H) incorrectly allows the writing/requesting of the D1 and D2 Power States in the Power State field (bits[1:0] of PMCSR) when these states are not supported.  	 Given that the device does not support the D1 and D2 states, attempts to write those states should have been ignored. The PCIe port does not change power state from D0 or D3hot when the Power State bits are written to D1 or D2, so there is no functional impact to the PCIe port. However, the Power State field is incorrectly modified. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Concurrent Updates to a Segment Descriptor May Be Lost  	  If a logical processor attempts to set the accessed bit in a code or data segment descriptor while another logical processor is modifying the same descriptor, both modifications of the descriptor may be lost.  	 Due to this erratum, updates to segment descriptors may not be preserved. Intel has not observed this erratum with any commercially available software or system. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMIs May Be Lost during Core C6 Transitions  	  If a performance monitoring counter overflows and causes a PMI (Performance Monitoring Interrupt) at the same time that the core is entering C6, then the PMI may be lost.  	 PMIs may be lost during a C6 transition. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   35  
  Uncacheable Access to a Monitored Address Range May Prevent Future Triggering of the Monitor Hardware  	  It is possible that an address range which is being monitored via the MONITOR instruction could be written without triggering the monitor hardware. A read from the monitored address range which is issued as uncacheable (for example having the CR0.CD bit set) may prevent subsequent writes from triggering the monitor hardware. A write to the monitored address range which is issued as uncacheable, may not trigger the monitor hardware and may prevent subsequent writes from triggering the monitor hardware.  	 The MWAIT instruction will not exit the optimized power state and resume program flow if the monitor hardware is not triggered. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  BIST Results May Be Additionally Reported after a GETSEC[WAKEUP] or INIT-SIPI Sequence  	  BIST results should only be reported in EAX the first time a logical processor wakes up from the Wait-For-SIPI state. Due to this erratum, BIST results may be additionally reported after INIT-SIPI sequences and when waking up RLP's from the SENTER sleep state using the GETSEC[WAKEUP] command.  	 An INIT-SIPI sequence may show a non-zero value in EAX upon wakeup when a zero value is expected. RLP's waking up for the SENTER sleep state using the GETSEC[WAKEUP] command may show a different value in EAX upon wakeup than before going into the SENTER sleep state. 	If necessary software may save the value in EAX prior to launching into the secure environment and restore upon wakeup and/or clear EAX after the INIT-SIPI sequence. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) May Be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	 Software may observe #MF being signaled before pending interrupts are serviced. 	None identified. 	  36  For the steppings affected, see the Summary Tables of Changes.   
  VM Exits Due to "NMI-Window Exiting" May Be Delayed by One Instruction  	  If VM entry is executed with the "NMI-window exiting" VM-execution control set to 1, a VM exit with exit reason "NMI window" should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	 VMM software using "NMI-window exiting" for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Malformed PCIe Packet Generated under Heavy Outbound Load  	  When running the PCIe ports in a 2x8 configuration at 5.0GT/S speed with heavy outbound write traffic, malformed packets could be generated. The length in the header field will not match the actual payload size.  	 Due to this erratum, malformed PCIe packets could be transmitted. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Operation in x16 Mode with Inbound Posted Writes May Be Unreliable  	  Under a complex set of conditions, it is possible that with PCIe configured for x16 operation inbound writes may store incorrect data.  	 PCIe operation with inbound writes in x16 mode may be unreliable. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unpredictable PCI Behavior Accessing Non-existent Memory Space  	  Locked instructions whose memory reference is split across cache line boundaries and are aborted on PCI behind Intel® 5 Series Chipset and Intel® 3400 Series Chipset may cause subsequent PCI writes to be unpredictable.  	 Aborted split lock accesses to non existent PCI memory space behind Intel 5 Series Chipset and Intel 3400 Series Chipset may cause PCI devices to subsequently become inoperable until a platform reset. Intel has not observed this erratum with commercially available software and has only observed this in a synthetic test environment. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   37  
  VM Exits Due to EPT Violations Do Not Record Information about PreIRET NMI Blocking  	  With certain settings of the VM-execution controls VM exits due to EPT violations set Bit 12 of the exit qualification if the EPT violation was a result of an execution of the IRET instruction that commenced with non-maskable interrupts (NMIs) blocked. Due to this erratum, such VM exits will instead clear this bit.  	 Due to this erratum, a virtual-machine monitor that relies on the proper setting of Bit 12 of the exit qualification may deliver NMIs to guest software prematurely. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® VT-d Receiving Two Identical Interrupt Requests May Corrupt Attributes of Remapped Interrupt or Hang a Subsequent InterruptRemap-Cache Invalidation Command  	  If the Intel® VT-d (Intel® Virtualization Technology for Directed I/O) interruptremapping hardware receives two identical back-to-back interrupt requests, then the attributes of the remapped interrupt returned may be corrupted. This interrupt sequence may also hang the system if the software executes a subsequent interruptremap-cache invalidation command.  	 This scenario may lead to unpredictable external interrupt behavior; or a subsequent interrupt-remap-cache invalidation command submitted by software may hang. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  S1 Entry May Cause Cores to Exit C3 or C6 C-State  	  Under specific circumstances, S1 entry may cause a logical processor to spuriously wake up from C3 or C6 and transition to a C0/S1 state. Upon S1 exit, these logical processors will be operating in C0.  	 In systems where S1 is used for power savings, customers may observe higher S1 power than expected and software may observe a different C-state on S1 exit than on S1 entry. 	It possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Multiple Performance Monitor Interrupts Are Possible on Overflow of IA32_FIXED_CTR2  	  When multiple performance counters are set to generate interrupts on an overflow and more than one counter overflows at the same time, only one interrupt should be generated. However, if one of the counters set to generate an interrupt on overflow is the IA32_FIXED_CTR2 (MSR 30BH) counter, multiple interrupts may be generated when the IA32_FIXED_CTR2 overflows at the same time as any of the other performance counters.  	 Multiple counter overflow interrupts may be unexpectedly generated. 	None identified. 	  38  For the steppings affected, see the Summary Tables of Changes.   
  LBRs May Not Be Initialized during Power-On Reset of the Processor  	  If a second reset is initiated during the power-on processor reset cycle, the LBRs (Last Branch Records) may not be properly initialized.  	 Due to this erratum, debug software may not be able to rely on the LBRs out of poweron reset. 	Ensure that the processor has completed its power-on reset cycle prior to initiating a second reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected Interrupts May Occur on C6 Exit If Using APIC Timer to Generate Interrupts  	  If the APIC timer is being used to generate interrupts, unexpected interrupts not related to the APIC timer may be signaled when a core exits the C6 power state. This erratum may occur when the APIC timer is near expiration when entering the core C6 state.  	 Due to this erratum, unexpected interrupt vectors could be sent from the APIC to a logical processor. 	Software should stop the APIC timer (by writing 0 to the Initial Count Register) before allowing the core to enter the C6 state. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTM or BTS Records May Have Incorrect Branch from Information after an Enhanced Intel SpeedStep® Technology Transition, T-states, C1E, or Adaptive Thermal Throttling  	  The "From" address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after an Enhanced Intel SpeedStep Technology transition, T-states, C1E (C1 Enhanced), or Adaptive Thermal Throttling.  	 When the LBRs, BTM or BTS are enabled, some records may have incorrect branch "From" addresses for the first branch after an Enhanced Intel SpeedStep Technology transition, T-states, C1E, or Adaptive Thermal Throttling. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMX-Preemption Timer Does Not Count Down at the Rate Specified  	  The VMX-preemption timer should count down by 1 every time a specific bit in the TSC (Time Stamp Counter) changes. (This specific bit is indicated by IA32_VMX_MISC bits [4:0] (0x485h) and has a value of 5 on the affected processors.) Due to this erratum, the VMX-preemption timer may instead count down at a different rate and may do so only intermittently.  	 The VMX-preemption timer may cause VM exits at a rate different from that expected by software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   39  
  Multiple Performance Monitor Interrupts Are Possible on Overflow of Fixed Counter 0  	  The processor can be configured to issue a PMI (performance monitor interrupt) upon overflow of the IA32_FIXED_CTR0 MSR (309H). A single PMI should be observed on overflow of IA32_FIXED_CTR0, however multiple PMIs are observed when this erratum occurs. This erratum only occurs when IA32_FIXED_CTR0 overflows and the processor and counter are configured as follows: • Intel® Hyper-Threading Technology is enabled • IA32_FIXED_CTR0 local and global controls are enabled • IA32_FIXED_CTR0 is set to count events only on its own thread (IA32_FIXED_CTR_CTRL MSR (38DH) Bit [2] = ‘0) • PMIs are enabled on IA32_FIXED_CTR0 (IA32_FIXED_CTR_CTRL MSR Bit [3] = ‘1) • Freeze_on_PMI feature is enabled (IA32_DEBUGCTL MSR (1D9H) Bit [12] = ‘1)  	 When this erratum occurs there may be multiple PMIs observed when IA32_FIXED_CTR0 overflows. 	Disable the FREEZE_PERFMON_ON_PMI feature in IA32_DEBUGCTL MSR (1D9H) Bit [12]. 	  For the steppings affected, see the Summary Tables of Changes. 
  SVID and SID of Devices 8 and 16 Only Implement Bits [7:0]  	  Bits [15:8] of SVID (Subsystem Vendor ID, Offset 2CH) and the SID (Subsystem Device ID, Offset 2EH) of devices 8 and 16 are not implemented. Only the lower bits [7:0] of these registers can be written to, though the PCI-e specification indicates that these are 16-bit registers.  	 Only bits [7:0] of SVID and SID can be written. Bits [15:8] will always be read as 0. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  No_Soft_Reset Bit in the PMCSR Does Not Operate As Expected  	  When the No_Soft_Reset bit in the Power Management Control and Status Register (PMCSR; Bus 0; Devices 0, 3, 4, 5; Function 0; Offset 0xE4; Bit 3) is cleared the device should perform an internal reset upon transitioning from D3hot to D0. Due to this erratum the device does not perform an internal reset upon transitioning from D3hot to D0.  	 When the No_Soft_reset bit in the PMCSR register is set or cleared no internal reset of the device will be preformed when transitioning from D3hot to D0. 	None identified. 	  40  For the steppings affected, see the Summary Tables of Changes.   
  VM Exits Due to LIDT/LGDT/SIDT/SGDT Do Not Report Correct Operand Size  	  When a VM exit occurs due to a LIDT, LGDT, SIDT, or SGDT instruction with a 32-bit operand, Bit 11 of the VM-exit instruction information field should be set to 1. Due to this erratum, this bit is instead cleared to 0 (indicating a 16-bit operand).  	 Virtual-machine monitors cannot rely on Bit 11 of the VM-exit instruction information field to determine the operand size of the instruction causing the VM exit. 	Virtual Machine Monitor software may decode the instruction to determine operand size. 	  For the steppings affected, see the Summary Tables of Changes. 
  DPRSLPVR Signal May Be Incorrectly Asserted on Transition Between Low Power C-states  	  On entry to or exit from package C6 states, DPRSLPVR (Deeper Sleep Voltage Regulator) signal may be incorrectly asserted.  	 Due to this erratum, platform voltage regulator may shutdown 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA May Not Count Events Correctly  	  Performance Monitor Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA should only increment the count when a load is blocked by a store. Due to this erratum, the count will be incremented whenever a load hits a store, whether it is blocked or can forward. In addition this event does not count for specific threads correctly.  	 If Intel® Hyper-Threading Technology is disabled, the Performance Monitor events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA may indicate a higher occurrence of loads blocked by stores than have actually occurred. If Intel Hyper-Threading Technology is enabled, the counts of loads blocked by stores may be unpredictable and they could be higher or lower than the correct count. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	 When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   41  
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	 The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially-available software. 	None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Following INVEPT or INVVPID May Fail to Flush All Translations for a Large Page  	  This erratum applies if the address of the memory operand of an INVEPT or INVVPID instruction resides on a page larger than 4 KBytes and either (1) that page includes the low 1 MBytes of physical memory; or (2) the physical address of the memory operand matches an MTRR that covers less than 4 MBytes. A subsequent execution of INVLPG that targets the large page and that occurs before the next VM-entry instruction may fail to flush all TLB entries for the page. Such entries may persist in the TLB until the next VM-entry instruction.  	 Accesses to the large page between INVLPG and the next VM-entry instruction may incorrectly use translations that are inconsistent with the in-memory page tables. 	None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	 The values of the LER MSRs may be unreliable. 	None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (Bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	 Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality. 	None identified. 	  42  For the steppings affected, see the Summary Tables of Changes.   
  Debug Exception Flags DR6.B0-B3 Flags May Be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	 The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Exit From the Core C6-state May Result in the Dropping of an Interrupt  	  In a complex set of internal conditions when the processor exits from Core C6 state, it is possible that an interrupt may be dropped.  	 Due to this erratum, an interrupt may be dropped. Intel has not observed this erratum with any commercially available software. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Extended Capability Structures May Be Incorrect  	  The PCIe Extended Capability structure at Offset 0x100 of Bus 0; Devices 0, 3, 4, 5 and 6 contains a Capability ID of AER (Advanced Error Reporting), but these devices do not support AER. The Next Capability Offset field of this Extended Capability structure contains 0x150 which is the offset of the next Extended Capability structure. For Bus 0; Devices 4, 5, and 6, the Next Capability Offset field of the Extended Capability structure at Offset 0x150 should contain 0 to indicate the end of the capability chain but instead contains 0x160. All fields of the Extended Capability structure at Offset 0x160 are 0x0. A Capability ID of 0x0 is a reserved Capability ID.  	 Software that enables features based upon the existence of the AER may not observe the expected behavior associated with this capability. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMIs during Core C6 Transitions May Cause the System to Hang  	  If a performance monitoring counter overflows and causes a PMI (Performance Monitoring Interrupt) at the same time that the core enters C6, then this may cause the system to hang.  	 Due to this erratum, the processor may hang when a PMI coincides with core C6 entry. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   43  
  2MB Page Split Lock Accesses Combined with Complex Internal Events May Cause Unpredictable System Behavior  	  A 2-MB Page Split Lock (a locked access that spans two 2-MB large pages) coincident with additional requests that have particular address relationships in combination with a timing sensitive sequence of complex internal conditions may cause unpredictable system behavior.  	 This erratum may cause unpredictable system behavior. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC8_CTL2 MSR Is Not Cleared on Processor Warm Reset  	  After processor warm reset the IA32_MC8_CTL2 MSR (288H) should be zero. Due to this erratum the IA32_MC8_CTL2 MSR is not zeroed on processor warm reset.  	 When this erratum occurs, the IA32_MC8_CTL2 MSR will not be zeroed by warm reset. Software that expects the values to be 0 coming out of warm reset may not behave as expected 	BIOS should zero the IA32_MC8_CTL2 MSR after a warm reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  The TPM’s Locality 1 Address Space Cannot Be Opened  	  Due to this erratum, writing to TXT.CMD.OPEN.LOCALITY1 (FED2_0380H) does not open the Locality 1 address space to the TPM (Trusted Platform Module).  	 Software that uses the TPM’s Locality 1 address space will not be able to gain access to it. 	All operations for the TPM should be done using Locality 0 or Locality 2 instead of Locality 1. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Link Bit Errors Present during L0s Entry May Cause the System to Hang during L0s Exit  	  During L0s entry PCIe link bit errors may be generated due to a slow shutdown response from the PCIe analog circuits. As a result, the PCIe analog circuits may now take longer to establish bit lock during the L0s exit sequence. In some cases bit lock may not be achieved and may result in a system hang.  	 While exiting from L0s the PCIe bus may go into recovery mode. At the 5 GB/s rate system hangs may occur while exiting from L0s; however the hangs have not been seen on commercially available systems. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  44  For the steppings affected, see the Summary Tables of Changes.   
  The Combination of a Page-Split Lock Access and Data Accesses That Are Split across Cacheline Boundaries May Lead to Processor Livelock  	  Under certain complex micro-architectural conditions, the simultaneous occurrence of a page-split lock and several data accesses that are split across cacheline boundaries may lead to processor livelock.  	 Due to this erratum, a livelock may occur that can only be terminated by a processor reset. Intel has not observed this erratum with any commercially available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated after an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect. 	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	 For the steppings affected, see the Summary Tables of Changes. 
  IOTLB Invalidations Not Completing on Intel ® VT-d Engine for Integrated High Definition Audio  	  IOTLB invalidation in the Intel® VT-d engine for integrated High Definition Audio device may not complete and cause IVT field, bit [63] of IOTLBINV register (Offset 0x1208 in Memory Mapped IO region described by VTBAR {device 8, function 0, offset 0x180}), to not be cleared as expected. As a result, software may continue to poll this bit and not detect successful invalidation completion.  	 When Intel VT-d engine for integrated High Definition Audio device is enabled and software requests for IOTLB invalidation while audio traffic is active, the request may not complete and may result in a software hang. Intel has not observed this erratum with any commercially available software. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May Be Lost  	  The IO_SMI bit (bit 0) in the IO state field at SMRAM offset 7FA4H is set to "1" by the processor to indicate a System Management Interrupt (SMI) is either taken immediately after a successful I/O instruction or is taken after a successful iteration of a REP I/O instruction. Due to this erratum, the setting of the IO_SMI bit may be lost. This may happen under a complex set of internal conditions with Intel® HyperThreading Technology enabled and has not been observed with commercially available software. 	 Due to this erratum, SMI handlers may not be able to identify the occurrence of I/O SMIs. 	None identified. 	 For the steppings affected, see the Summary Tables of Changes.   45  
  PCIe Squelch Detect May be Slow to Respond During L0s Entry and May Cause a Surprise Link Down Condition  	  When entering the L0s idle state the PCIe squelch detect response may be slower than expected. This slow response can cause the PCIe interface at the downstream port to unexpectedly enter the L0s.FTS (Fast Training Sequence) state instead of the normal operation which is staying in the L0s.idle state until the Tx side of the upstream port exits squelch. This unexpected state transition may cause a recovery entry leading to a Surprise Link Down condition.  	 This erratum may cause a system hang while trying reach the L0s state. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  TR Corruption Due to Save/Restore x87 FPU Pointers in SMRAM  	  If x87 FPU instruction and data pointers are saved in SMRAM, the TR (Task Register) selector may be restored incorrectly on the exit from SMM.  	 The TR selector containing incorrect data may cause unpredictable system behavior. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Lanes Returning to The Active Power State May Cause The System to Hang  	  Under certain conditions, when the PCIe lanes come out of the S0 power savings state, the clocks may change asynchronously leading to a system hang.  	 A System hang may occur when coming out of the S0 power saving state. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events for Hardware Prefetches Which Miss The L1 Data Cache May be Over Counted  	  Hardware prefetches that miss the L1 data cache but cannot be processed immediately due to resource conflicts will count and then retry. This may lead to incorrectly incrementing the L1D_PREFETCH.MISS (event 4EH, umask 02H) event multiple times for a single miss.  	 The count reported by the L1D_PREFETCH.MISS event may be higher than expected. 	None identified. 	  46  For the steppings affected, see the Summary Tables of Changes.   
  Poisoned Write Caused by an Internal Parity Error Targeting IIO PCI Configuration Registers or MMIO Space will Not be Suppressed  	  When due to an internal parity error, a processor attempts to write poisoned data to a PCI configuration register in the IIO (Integrated I/O) module (internal PCI devices on bus IIOBUSNO) or to the MMIO space decoded by a BAR in the IIO module, the poisoned data will not be dropped. However, even though the poisoned data will not be dropped the internal Intel® QuickPath Interconnect logic will log and report an error in the IA32_MC0_STATUS MSR (401H) with MCACOD equal to 0000 1110 xxxx xx11 and bit 16 or 17 set.  	 Poisoned data may be written to PCI configuration registers or MMIO space causing a machine check exception. It is possible for these writes to lead to unpredictable system behavior. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]  	  If the “load IA32_PERF_GLOBAL_CTRL” VM-exit control is 1, a VM exit should load the IA32_PERF_GLOBAL_CTRL MSR (38FH) from the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS. Due to this erratum, such a VM exit may instead clear bits 34:32 of the MSR, loading only bits 31:0 from the VMCS.  	 All fixed-function performance counters will be disabled after an affected VM exit, even if the VM exit should have enabled them based on the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS. 	A VM monitor that wants the fixed-function performance counters to be enabled after a VM exit may do one of two things: (1) clear the “load IA32_PERF_GLOBAL_CTRL” VMexit control; or (2) include an entry for the IA32_PERF_GLOBAL_CTRL MSR in the VMexit MSR-load list. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Port’s LTSSM May Not Transition Properly in the Presence of TS1 or TS2 Ordered Sets That Have Unexpected Symbols Within those Sets  	  When a PCIe port receives TS1 and/or TS2 ordered sets with unexpected symbols (per the PCIe Base Specification), the port’s LTSSM (Link Training State Machine) might not transition according to the PCIe Base Specification requirements. The LTSSM may incorrectly stay in its current state, or transition to an incorrect state. If the unexpected symbols are sporadic in nature the link will recover and go to the proper state.  	 PCIe Port’s LTSMM may not transition according to PCIe Base Specification as described above. This problem has not been seen in real system testing, but was discovered by synthetic tests designed to check for illegal conditions. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  NTB/RP Link Will Send Extra TS2 Ordered Set During Link Training  	  The NTB (Non-Transparent Bridge) when operating in NTB/RP (Root Port) mode will send a superfluous TS2 ordered set after transitioning to the CONFIGURATION.IDLE state during link training. This TS2 ordered set may contain invalid capability data.  	 NTB/RP Link will transmit a TS2 ordered set after transitioning to the CONFIGURATION.IDLE state. No impact expected for specification compliant PCIe partners. Specification compliant PCIe link partners will have transitioned to CONFIGURATION.IDLE before this ordered set is sent and will ignore it. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   47  
  PCIe Ports May Not Enter Slave Loopback Mode From the Configuration LTSSM State  	  If a PCIe port’s LTSSM (Link Training State Machine) is in the CONFIG.LINK_WIDTH_START state, it may not enter slave loopback mode when requested to do so by the link partner. If the request is missed the link will continue to train and enter the Slave loopback mode after it first transitions through the L0 and RECOVERY LTSSM states.  	 Due to this erratum, PCIe ports may be delayed in entering the slave loopback mode. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected DMI and PCIe Link Retraining and Correctable Errors Reported  	  When the processor exits the package C6 power state, the PCIe and DMI ports may enter a state where they will NAK all packets for a short time. If this condition persists long enough so that the same packet is NAKed four times, the link will retrain and a correctable error may be signaled by the PCIe end point. Overall performance of the link is not impacted.  	 Due to this erratum, unexpected link retraining and correctable errors may be reported. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  QPI Lane May Be Dropped During Full Frequency Deskew Phase of Training  	  A random QPI Lane may be dropped during the lane deskew phase while the QPI Bus is training at full frequency.  	 When there are multiple resets after the QPI Bus has reached full speed operation there is a small chance that a lane could be dropped during the deskew phase of training. In the case of a lane being dropped this will be detected and a retry will be done until the link is established and the lane is re-trained. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PerfMon Overflow Status Can Not be Cleared After Certain Conditions Have Occurred  	  Under very specific timing conditions, if software tries to disable a PerfMon counter through MSR IA32_PERF_GLOBAL_CTRL (0x38F) or through the per-counter eventselect (e.g. MSR 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in MSR IA32_PERF_GLOBAL_STAT (0x38E) may be left set with no way for software to clear it.  	 Due to this erratum, software may be unable to clear the PerfMon counter overflow status indication. 	Software may avoid this erratum by clearing the PerfMon counter value prior to disabling it and then clearing the overflow status indication bit. 	  48  For the steppings affected, see the Summary Tables of Changes.   
  An Unexpected Page Fault or EPT Violation May Occur After Another Logical Processor Creates a Valid Translation for a Page  	  An unexpected page fault (#PF) or EPT violation may occur for a page under the following conditions: • The paging structures initially specify no valid translation for the page. • Software on one logical processor modifies the paging structures so that there is a valid translation for the page (e.g., by setting to 1 the present bit in one of the pagingstructure entries used to translate the page). • Software on another logical processor observes this modification (e.g., by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). • Shortly thereafter, software on that other logical processor performs a store to a linear address on the page. In this case, the store may cause a page fault or EPT violation that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). Intel has not observed this erratum with any commercially available software.  	 An unexpected page fault may be reported. There are no other side effects due to this erratum. 	System software can be constructed to tolerate these unexpected page faults. See Section “Propagation of Paging-Structure Changes to Multiple Processors” of Volume 3A of IA-32 Intel® Architecture Software Developer’s Manual, for recommendations for software treatment of asynchronous paging-structure updates. 	  For the steppings affected, see the Summary Tables of Changes. 
  L1 Data Cache Errors May be Logged With Level Set to 1 Instead of 0  	  When an L1 Data Cache error is logged in IA32_MCi_STATUS[15:0], which is the MCA Error Code Field, with a cache error type of the format 0000 0001 RRRR TTLL, the LL field may be incorrectly encoded as 01b instead of 00b.  	 An error in the L1 Data Cache may report the same LL value as the L2 Cache. Software should not assume that an LL value of 01b is the L2 Cache. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Stack Pushes May Not Occur Properly for Events Delivered Immediately After VM Entry to 16-Bit Software  	  The stack pushes for an event delivered after VM entry and before execution of an instruction in VMX non-root operation may not occur properly. The erratum applies only if the VM entry establishes IA32_EFER.LMA = 0 and CS.D = 0 and only if the event handler is also invoked with CS.D = 0.  	 This erratum affects events that are pending upon completion of VM entry and that do not cause VM exits. Examples include debug exceptions, interrupts, and generalprotection faults generated in virtual-8086 mode by the mode’s virtual interrupt mechanism. The erratum applies only if the VM entry is not to IA-32e mode and is to 16-bit operation, and only if the relevant handler uses 16-bit operation. The incorrect stack pushes resulting from the erratum may cause incorrect guest operation. Intel has not observed this erratum with any commercially available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   49  
  Executing The GETSEC Instruction While Throttling May Result in a Processor Hang  	  If the processor throttles due to either high temperature thermal conditions or due to an explicit operating system throttling request (TT1) while executing GETSEC[SENTER] or GETSEC[SEXIT] instructions, then under certain circumstances, the processor may hang. Intel has not been observed this erratum with any commercially available software.  	 Possible hang during execution of GETSEC instruction. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PerfMon Event LOAD_HIT_PRE.SW_PREFETCH May Overcount  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH (event 4CH, umask 01H) should count load instructions hitting an ongoing software cache fill request initiated by a preceding software prefetch instruction. Due to this erratum, this event may also count when there is a preceding ongoing cache fill request initiated by a locking instruction.  	 PerfMon event LOAD_HIT_PRE.SW_PREFETCH may overcount. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	 Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used. 	Software can avoid this by: 1. Avoid using Freeze PerfMon on PMI bit 2. Enable only one fixed counter at a time when using Freeze PerfMon on PMI 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions  	  When a 2-byte opcode of conditional branch (opcodes 0F8xH, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid VEX prefix, it may sometimes signal a #GP fault (illegal instruction length > 15-bytes) instead of #UD (illegal opcode).  	 #GP fault instead of a #UD signaled on an illegal instruction. 	None identified. 	  50  For the steppings affected, see the Summary Tables of Changes.   
  A Logical Processor May Wake From Shutdown State When BranchTrace Messages or Branch-Trace Stores Are Enabled  	  Normally, a logical processor that entered the shutdown state will remain in that state until a break event (NMI, SMI, INIT) occurs. Due to this erratum, if CR4.MCE (Machine Check Enable) is 0 and a branch-trace message or branch-trace store is pending at the time of a machine check, the processor may not remain in shutdown state. In addition, if the processor was in VMX non-root operation when it improperly woke from shutdown state, a subsequent VM exit may save a value of 2 into the activity-state field in the VMCS (indicating shutdown) even though the VM exit did not occur while in shutdown state.  	 This erratum may result in unexpected system behavior. If a VM exit saved a value of 2 into the activity-state field in the VMCS, the next VM entry will take the processor to shutdown state. 	Software should ensure that CR4.MCE is set whenever IA32_DEBUGCTL MSR (60EH) TR bit [6] is set. 	  For the steppings affected, see the Summary Tables of Changes. 
  Task Switch to a TSS With an Inaccessible LDTR Descriptor May Cause Unexpected Faults  	  A task switch may load the LDTR (Local Descriptor Table Register) with an incorrect segment descriptor if the LDT (Local Descriptor Table) segment selector in the new TSS specifies an inaccessible location in the GDT (Global Descriptor Table).  	 Future accesses to the LDT may result in unpredictable system behavior. 	Operating system code should ensure that segment selectors used during task switches to the GDT specify offsets within the limit of the GDT and that the GDT is fully paged into memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entries That Return From SMM Using VMLAUNCH May Not Update The Launch State of the VMCS  	  Successful VM entries using the VMLAUNCH instruction should set the launch state of the VMCS to "launched". Due to this erratum, such a VM entry may not update the launch state of the current VMCS if the VM entry is returning from SMM.  	 Subsequent VM entries using the VMRESUME instruction with this VMCS will fail. RFLAGS.ZF is set to 1 and the value 5 (indicating VMRESUME with non-launched VMCS) is stored in the VM-instruction error field. This erratum applies only if dual monitor treatment of SMI and SMM is active. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Clear Bytes 81H-83H on Virtual-APIC Page When "Use TPR Shadow" Is 0  	  VM entry should not clear bytes 81H-83H on the virtual-APIC page if the "use TPR shadow" VM-execution control is 0. Due to this erratum, VM entry will do so if the "virtualize x2APIC mode" VM-execution control is 1.  	 VM entries with the 0-setting of the "use TPR shadow" VM-execution control and the 1setting of the "virtualize x2APIC mode" VM-execution control cause any non-zero data at bytes 81H-83H on the virtual-APIC page to be lost. Note that this combination of settings is not allowed; any such VM entry will fail after clearing these bytes. 	Software should always set the "use TPR shadow" VM-execution control to 1 whenever it sets that "virtualize x2APIC mode" VM-execution control to 1. 	  For the steppings affected, see the Summary Tables of Changes.   51  
  A First Level Data Cache Parity Error May Result in Unexpected Behavior  	  When a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accessesthe processor may exhibit unexpected behavior.  	 Due to this erratum unpredictable system behavior may occur. Intel has not observed this erratum with any commercially available system. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® Trusted Execution Technology ACM Revocation  	  SINIT ACM i7_QUAD_SINIT_20.BIN or earlier are revoked and will not launch with new processor configuration information.  	 Due to this erratum, SINIT ACM i7_QUAD_SINIT_20.BIN and earlier will be revoked. 	It is possible for the BIOS to contain a workaround for this erratum. All Intel® TXT enabled software must use SINIT ACM i7_QUAD_SINIT_51.BIN or later. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Event May Intervene Before a System Management Interrupt That Results from IN or INS  	  If an I/O instruction (IN, INS, OUT, or OUTS) results in an SMI (system-management interrupt), the processor will set the IO_SMI bit at offset 7FA4H in SMRAM. This interrupt should be delivered immediately after execution of the I/O instruction so that the software handling the SMI can cause the I/O instruction to be re-executed. Due to this erratum, it is possible for another event (e.g., a nonmaskable interrupt) to be delivered before the SMI that follows the execution of an IN or INS instruction.  	 If software handling an affected SMI uses I/O instruction restart, the handler for the intervening event will not be executed. 	The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	 The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged. 	None identified. 	NA
  EFLAGS Discrepancy on Page Faults after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault. This can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	 None identified. Although the EFLAGS value saved may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without a page fault. 	 If the page fault handler inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Operation for Large (2M/4M) Pages May be Incomplete under Certain Conditions  	  The INVLPG instruction may not completely invalidate Translation Look-aside Buffer (TLB) entries for large pages (2M/4M) when both of the following conditions exist: •  Address range of the page being invalidated spans several Memory Type Range Registers (MTRRs) with different memory types specified  •  INVLPG operation is preceded by a Page Assist Event (Page Fault (#PF) or an access that results in either A or D bits being set in a Page Table Entry (PTE))  	 Stale translations may remain valid in TLB after a PTE update resulting in unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 Software should ensure that the memory type specified in the MTRRs is the same for the entire address range of the large page. 	  18  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  
  Store to WT Memory Data May be Seen in Wrong Order by Two Subsequent Loads  	  When data of Store to WT memory is used by two subsequent loads of one thread and another thread performs cacheable write to the same address the first load may get the data from external memory or L2 written by another core, while the second load will get the data straight from the WT Store.  	 Software that uses WB to WT memory aliasing may violate proper store ordering. 	 Do not use WB to WT aliasing. 	  For the steppings affected, see the Summary Tables of Changes. 
  Non-Temporal Data Store May be Observed in Wrong Program Order  	  When non-temporal data is accessed by multiple read operations in one thread while another thread performs a cacheable write operation to the same address, the data stored may be observed in wrong program order (i.e. later load operations may read older data).  	 Software that uses non-temporal data without proper serialization before accessing the non-temporal data may observe data in wrong program order. 	 Software that conforms to the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, section “Buffering of Write Combining Memory Locations” will operate correctly. 	  For the steppings affected, see the Summary Tables of Changes. 
  Page Access Bit May be Set Prior to Signaling a Code Segment Limit Fault  	  If code segment limit is set close to the end of a code page, then due to this erratum the memory page Access bit (A bit) may be set for the subsequent page prior to general protection fault on code segment limit.  	 When this erratum occurs, a non-accessed page which is present in memory and follows a page that contains the code segment limit may be tagged as accessed. 	 Erratum can be avoided by placing a guard page (non-present or nonexecutable page) as the last page of the segment or after the page that includes the code segment limit. 	  For the steppings affected, see the Summary Tables of Changes. 
  Updating Code Page Directory Attributes without TLB Invalidation May Result in Improper Handling of Code #PF  	  Code #PF (Page Fault exception) is normally handled in lower priority order relative to both code #DB (Debug Exception) and code Segment Limit  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  19   Violation #GP (General Protection Fault). Due to this erratum, code #PF may be handled incorrectly, if all of the following conditions are met: • •  •  A PDE (Page Directory Entry) is modified without invalidating the corresponding TLB (Translation Look-aside Buffer) entry Code execution transitions to a different code page such that both o The target linear address corresponds to the modified PDE o The PTE (Page Table Entry) for the target linear address has an A (Accessed) bit that is clear One of the following simultaneous exception conditions is present following the code transition o Code #DB and code #PF o Code Segment Limit Violation #GP and code #PF  	 Software may observe either incorrect processing of code #PF before code Segment Limit Violation #GP or processing of code #PF in lieu of code #DB. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	 When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	 The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software. 20  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A REP STOS/MOVS to a MONITOR/MWAIT Address Range May Prevent Triggering of the Monitoring Hardware  	  The MONITOR instruction is used to arm the address monitoring hardware for the subsequent MWAIT instruction. The hardware is triggered on subsequent memory store operations to the monitored address range. Due to this erratum, REP STOS/MOVS fast string operations to the monitored address range may prevent the actual triggering store to be propagated to the monitoring hardware.  	 A logical processor executing an MWAIT instruction may not immediately continue program execution if a REP STOS/MOVS targets the monitored address range. 	 Software can avoid this erratum by not using REP STOS/MOVS store operations within the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event MISALIGN_MEM_REF May Over Count  	  Performance monitoring event MISALIGN_MEM_REF (05H) is used to count the number of memory accesses that cross an 8-byte boundary and are blocked until retirement. Due to this erratum, the performance monitoring event MISALIGN_MEM_REF also counts other memory accesses.  	 The performance monitoring event MISALIGN_MEM_REF may over count. The extent of the over counting depends on the number of memory accesses retiring while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  21  
  Code Segment Limit Violation May Occur on 4 Gigabyte Limit Check  	  Code Segment limit violation may occur on 4 Gigabyte limit check when the code streamwraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.  	 This is a rare condition that may result in a system hang. Intel has not observed this erratum with any commercially available software, or system. 	 Avoid code that wraps around segment limit. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory-based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, e.g. CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Last Branch Records (LBR) Updates May be Incorrect after a Task Switch  	  A Task-State Segment (TSS) task switch may incorrectly set the LBR_FROM value to the LBR_TO value.  	 The LBR_FROM will have the incorrect address of the Branch Instruction. 	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations.  	  Under certain conditions as described in the Software Developers Manual section “Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation. 	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Upper 32 bits of ‘From’ Address Reported through BTMs or BTSs May be Incorrect  	  When a far transfer switches the processor from 32-bit mode to IA-32e mode, the upper 32 bits of the ‘From’ (source) addresses reported through the BTMs (Branch Trace Messages) or BTSs (Branch Trace Stores) may be incorrect.  	 The upper 32 bits of the ‘From’ address debug information reported through BTMs or BTSs may be incorrect during this transition. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Address Reported by Machine-Check Architecture (MCA) on Single-bit L2 ECC Errors May be Incorrect  	  When correctable Single-bit ECC errors occur in the L2 cache, the address is logged in the MCA address register (MCi_ADDR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in MCi_ADDR, for Single-bit L2 ECC errors. 	 None identified. Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  23   	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.)  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Store Ordering May be Incorrect between WC and WP Memory Types  	  According to Intel® 64 and IA-32 Intel Architecture Software Developer's Manual, Volume 3A "Methods of Caching Available", WP (Write Protected) stores should drain the WC (Write Combining) buffers in the same way as UC (Uncacheable) memory type stores do. Due to this erratum, WP stores may not drain the WC buffers.  	 Memory ordering may be violated between WC and WP stores. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EFLAGS, CR0, CR4 and the EXF4 Signal May be Incorrect after Shutdown  	  When the processor is going into shutdown due to an RSM inconsistency failure, EFLAGS, CR0 and CR4 may be incorrect. In addition the EXF4 signal may still be asserted. This may be observed if the processor is taken out of shutdown by NMI#.  	 A processor that has been taken out of shutdown may have an incorrect EFLAGS, CR0 and CR4. In addition the EXF4 signal may still be asserted. 	 None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. 1) If an instruction that performs a memory load causes a code segment limit violation. 2) If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending. 3) If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Top-of-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	 In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side-effect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception. 	 Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Retired Instructions (C0H) May Not Be Accurate  	  The INST_RETIRED performance monitor may miscount retired instructions as follows: •  Repeat string and repeat I/O operations are not counted when a hardware interrupt is received during or after the last iteration of the repeat flow.  •  VMLAUNCH and VMRESUME instructions are not counted.  •  HLT and MWAIT instructions are not counted. The following instructions, if executed during HLT or MWAIT events, are also not counted: a) RSM from a C-state SMI during an MWAIT instruction. b) RSM from an SMI during a HLT instruction.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  25   	 There may be a smaller than expected value in the INST_RETIRED performance monitoring counter. The extent to which this value is smaller than expected is determined by the frequency of the above cases. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  For the steppings affected, see the Summary Tables of Changes. 
  CMPSB, LODSB, or SCASB in 64-bit Mode with Count Greater or Equal to 248 May Terminate Early  	  In 64-bit Mode CMPSB, LODSB, or SCASB executed with a repeat prefix and count greater than or equal to 248 may terminate early. Early termination may result in one of the following. •  The last iteration not being executed  •  Signaling of a canonical limit fault (#GP) on the last iteration  	 While in 64-bit mode, with count greater or equal to 248, repeat string operations CMPSB, LODSB or SCASB may terminate without completing the last iteration. Intel has not observed this erratum with any commercially available software. 	 Do not use repeated string operations with RCX greater than or equal to 248. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 26  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel® SpeedStep® Technology transitions or Thermal Monitor 1 events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VERW/VERR/LSL/LAR Instructions May Unexpectedly Update the Last Exception Record (LER) MSR  	  The LER MSR may be unexpectedly updated, if the resultant value of the Zero Flag (ZF) is zero after executing the following instructions 1. VERR (ZF=0 indicates unsuccessful segment read verification) 2. VERW (ZF=0 indicates unsuccessful segment write verification) 3. LAR (ZF=0 indicates unsuccessful access rights load) 4. LSL (ZF=0 indicates unsuccessful segment limit load)  	 The value of the LER MSR may be inaccurate if VERW/VERR/LSL/LAR instructions are executed after the occurrence of an exception. 	 Software exception handlers that rely on the LER MSR value should read the LER MSR before executing VERW/VERR/LSL/LAR instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  INIT Does Not Clear Global Entries in the TLB  	  INIT may not flush a TLB entry when: •  The processor is in protected mode with paging enabled and the page global enable flag is set (PGE bit of CR4 register)  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  27   •  G bit for the page table entry is set  •  TLB entry is present in TLB when INIT occurs  	 Software may encounter unexpected page fault or incorrect address translation due to a TLB entry erroneously left in TLB after INIT. 	 Write to CR3, CR4 (setting bits PSE, PGE or PAE) or CR0 (setting bits PG or PE) registers before writing to memory early in BIOS code to clear all the global entries from TLB. 	  For the steppings affected, see the Summary Tables of Changes. 
  Split Locked Stores May not Trigger the Monitoring Hardware  	  Logical processors normally resume program execution following the MWAIT, when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation. Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store that spans across cache lines within the monitored address range.  	 The logical processor that executed the MWAIT instruction may not resume execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is split across cache lines. 	 Do not use locked stores that span cache lines in the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing Shared Unaligned Data that Crosses a Cache Line without Proper Semaphores or Barriers May Expose a Memory Ordering Issue  	  Software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory ordering issue if multiple loads access this shared data shortly thereafter.  28  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   Exposure to this problem requires the use of a data write which spans a cache line boundary. 	 This erratum may cause loads to be observed out of order. Intel has not observed this erratum with any commercially available software or system. 	 Software should ensure at least one of the following is true when modifying shared data by multiple agents: •  The shared data is aligned  •  Proper semaphores or barriers are used in order to prevent concurrent data accesses.  	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4G limit (0ffffffffh) may not signal a #GP fault.  	 When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault. 	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  An Asynchronous MCE During a Far Transfer May Corrupt ESP  	  If an asynchronous machine check occurs during an interrupt, call through gate, FAR RET or IRET and in the presence of certain internal conditions, ESP may be corrupted.  	 If the MCE (Machine Check Exception) handler is called without a stack switch, then a triple fault will occur due to the corrupted stack pointer, resulting in a processor shutdown. If the MCE is called with a stack switch, e.g. when the CPL (Current Privilege Level) was changed or when going through an interrupt task gate, then the corrupted ESP will be saved on the new stack or in the TSS (Task State Segment), and will not be used. 	 Use an interrupt task gate for the machine check handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Reports Architectural Performance Monitoring Version 2 is Supported, When Only Version 1 Capabilities are Available  	  CPUID leaf 0Ah reports the architectural performance monitoring version that is available in EAX[7:0]. Due to this erratum CPUID reports the supported version as 2 instead of 1.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  29   	 Software will observe an incorrect version number in CPUID.0Ah.EAX [7:0] in comparison to which features are actually supported. 	 Software should use the recommended enumeration mechanism described in the Architectural Performance Monitoring section of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3: System Programming Guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1.  MOV or POP instruction to SS (Stack Segment) selector;  2.  Next instruction is FP (Floating Point) that gets FP assist  3.  Another instruction after the FP instruction completes successfully  4.  A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction.  Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4. 	 Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints. 	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes. 
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	 BIOS must leave the xTPR update transactions disabled (default). 	  30  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  
  Performance Monitoring Event IA32_FIXED_CTR2 May Not Function Properly when Max Ratio is a Non-Integer Core-to-Bus Ratio  	  Performance Counter IA32_FIXED_CTR2 (MSR 30BH) event counts CPU reference clocks when the core is not in a halt state. This event is not affected by core frequency changes (e.g., P states, TM2 transitions) but counts at the same frequency as the Time-Stamp Counter IA32_TIME_STAMP_COUNTER (MSR 10H). Due to this erratum, the IA32_FIXED_CTR2 will not function properly when the non-integer core-tobus ratio multiplier feature is used and when a non-zero value is written to IA32_ FIXED_CTR2. Non-integer core-to-bus ratio enables additional operating frequencies. This feature can be detected by IA32_PLATFORM_ID (MSR 17H) bit [23].  	 The Performance Monitoring Event IA32_FIXED_CTR2 may result in an inaccurate count when the non-integer core-to-bus multiplier feature is used. 	 If writing to IA32_FIXED_CTR2 and using a non-integer core-to-bus ratio multiplier, always write a zero. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause a Livelock During Snoops of the L1 Data Cache  	  A livelock may be observed in rare conditions when instruction fetch causes multiple level one data cache snoops.  	 Due to this erratum, a livelock may occur. Intel has not observed this erratum with any commercially available software. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Use of Memory Aliasing with Inconsistent Memory Type may Cause a System Hang or a Machine Check Exception  	  Software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (MCE). This would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. If the cacheable address finds its way into the instruction cache, and the non-cacheable address is fetched in the IFU, the processor may invalidate the non-cacheable address from the fetch unit. Any micro-architectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and lack of it will cause a system hang or an MCE.  	 This erratum has not been observed with commercially available software.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  31   	 Although it is possible to have a single physical page mapped by two different linear addresses with different memory types, Intel has strongly discouraged this practice as it may lead to undefined results. Software that needs to implement memory aliasing should manage the memory type consistency. 	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
 Memory-Ordering Violations  	  Under certain conditions, as described in the Software Developers Manual section "Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors", the processor may perform REP MOVS or REP STOS as write combining stores (referred to as “fast strings”) for optimal	NA	NA	NA
 combining stores. Due to this erratum, stores of a WB (write back) memory	NA	NA	NA	NA
 	NA	NA	NA	NA
 related store. Intel has not observed this erratum with any commercially available software.	NA	NA	NA	NA
 subsequent write-back stores should add an MFENCE or SFENCE instruction	NA	NA	NA	NA
 such as that used for synchronization. 	NA	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exit with Exit Reason “TPR Below Threshold” Can Cause the Blocking by MOV/POP SS and Blocking by STI Bits to be Cleared in the Guest Interruptibility-State Field  	  As specified in Section, “VM Exits Induced by the TPR Shadow”, in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, a VM exit occurs immediately after any VM entry performed with the “use TPR shadow", "activate secondary controls”, and “virtualize APIC accesses” VMexecution controls all set to 1 and with the value of the TPR shadow (bits 7:4 in byte 80H of the virtual-APIC page) less than the TPR-threshold VMexecution control field. Due to this erratum, such a VM exit will clear bit 0 (blocking by STI) and bit 1 (blocking by MOV/POP SS) of the interruptibilitystate field of the guest-state area of the VMCS (bit 0 - blocking by STI and bit 1 - blocking by MOV/POP SS should be left unmodified).  	 Since the STI, MOV SS, and POP SS instructions cannot modify the TPR shadow, bits 1:0 of the interruptibility-state field will usually be zero before any VM entry meeting the preconditions of this erratum; behavior is correct in this case. However, if VMM software raises the value of the TPR-threshold VMexecution control field above that of the TPR shadow while either of those bits is 1, incorrect behavior may result. This may lead to VMM software 32  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   prematurely injecting an interrupt into a guest. Intel has not observed this erratum with any commercially available software. 	 VMM software raising the value of the TPR-threshold VM-execution control field should compare it to the TPR shadow. If the threshold value is higher, software should not perform a VM entry; instead, it could perform the actions that it would normally take in response to a VM exit with exit reason “TPR below threshold”. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using Memory Type Aliasing with Cacheable and WC Memory Types May Lead to Memory Ordering Violations  	  Memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory types. Memory type aliasing with a cacheable memory type and WC (write combining) may cause the processor to perform incorrect operations leading to memory ordering violations for WC operations.  	 Software that uses aliasing between cacheable and WC memory types may observe memory ordering errors within WC memory operations. Intel has not observed this erratum with any commercially available software. 	 None identified. Intel does not support the use of cacheable and WC memory type aliasing, and WC operations are defined as weakly ordered. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exit Caused by a SIPI Results in Zero to be Saved to the Guest RIP Field in the VMCS  	  If a logical processor is in VMX non-root operation and in the wait-for-SIPI state, an occurrence of a start-up IPI (SIPI) causes a VM exit. Due to this erratum, such VM exits always save zero into the RIP field of the guest-state area of the virtual-machine control structure (VMCS) instead of the value of RIP before the SIPI was received.  	 In the absence of virtualization, a SIPI received by a logical processor in the wait-for-SIPI state results in the logical processor starting execution from the vector sent in the SIPI regardless of the value of RIP before the SIPI was received. A virtual-machine monitor (VMM) responding to a SIPI-induced VM exit can emulate this behavior because the SIPI vector is saved in the lower 8 bits of the exit qualification field in the VMCS. Such a VMM should be unaffected by this erratum. A VMM that does not emulate this behavior may need to recover the old value of RIP through alternative means. Intel has not observed this erratum with any commercially available software. 	 VMM software that may respond to SIPI-induced VM exits by resuming the interrupt guest context without emulating the non-virtualized SIPI response should (1) save from the VMCS (using VMREAD) the value of RIP before any Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  33   VM entry to the wait-for SIPI state; and (2) restore to the VMCS (using VMWRITE) that value before the next VM entry that resumes the guest in any state other than wait-for-SIPI. 	  For the steppings affected, see the Summary Tables of Changes. 
  NMIs May Not Be Blocked by a VM-Entry Failure  	  The Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2 specifies that, following a VM-entry failure during or after loading guest state, “the state of blocking by NMI is what it was before VM entry.” If non-maskable interrupts (NMIs) are blocked and the “virtual NMIs” VM-execution control set to 1, this erratum may result in NMIs not being blocked after a VM-entry failure during or after loading guest state.  	 VM-entry failures that cause NMIs to become unblocked may cause the processor to deliver an NMI to software that is not prepared for it. 	 VMM software should configure the virtual-machine control structure (VMCS) so that VM-entry failures do not occur. 	  For the steppings affected, see the Summary Tables of Changes. 
  Partial Streaming Load Instruction Sequence May Cause the Processor to Hang  	  Under some rare conditions, when multiple streaming load instructions (MOVNTDQA) are mixed with non-streaming loads that split across cache lines, the processor may hang.  	 Under the scenario described above, the processor may hang. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. However, streaming behavior may be re-enabled by setting bit 5 to 1 of the MSR at address 0x21 for software development or testing purposes. If this bit is changed, then a read-modify-write should be performed to preserve other bits of this MSR. When the streaming behavior is enabled and using streaming load instructions, always consume a full cache line worth of data and/or avoid mixing them with non-streaming memory references. If streaming loads are used to read partial cache lines, and mixed with nonstreaming memory references, use fences to isolate the streaming load operations from non-streaming memory operations. 	  For the steppings affected, see the Summary Tables of Changes. 
  Self/Cross Modifying Code May Not be Detected or May Cause a Machine Check Exception  	  If instructions from at least three different ways in the same instruction cache set exist in the pipeline combined with some rare internal state, self-  34  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   modifying code (SMC) or cross-modifying code may not be detected and/or handled. 	 An instruction that should be overwritten by another instruction while in the processor pipeline may not be detected/modified, and could retire without detection. Alternatively the instruction may cause a Machine Check Exception. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Data TLB Eviction Condition in the Middle of a Cacheline Split Load Operation May Cause the Processor to Hang  	  If the TLB translation gets evicted while completing a cacheline split load operation, under rare scenarios the processor may hang.  	 The cacheline split load operation may not be able to complete normally, and the machine may hang and generate Machine Check Exception. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Update of Read/Write (R/W) or User/Supervisor (U/S) or Present (P) Bits without TLB Shootdown May Cause Unexpected Processor Behavior  	  Updating a page table entry by changing R/W, U/S or P bits, even when transitioning these bits from 0 to 1, without keeping the affected linear address range coherent with all TLB (Translation Lookaside Buffers) and paging-structures caches in the processor, in conjunction with a complex sequence of internal processor micro-architectural events and store operations, may lead to unexpected processor behavior.  	 This erratum may lead to livelock, shutdown or other unexpected processor behavior. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  RSM Instruction Execution under Certain Conditions May Cause Processor Hang or Unexpected Instruction Execution Results  	  RSM instruction execution, under certain conditions triggered by a complex sequence of internal processor micro-architectural events, may lead to processor hang, or unexpected instruction execution results.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  35   	 In the above sequence, the processor may live lock or hang, or RSM instruction may restart the interrupted processor context through a nondeterministic EIP offset in the code segment, resulting in unexpected instruction execution, unexpected exceptions or system hang. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. However due to this erratum, only Contributory Exceptions and Page Faults will cause a triple fault shutdown, whereas a benign exception may not.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Front Side Bus GTLREF Margin Results Are Reduced for Die-to-Die Data Transfers in Intel® Core™2 Extreme Processor QX9650, Which Can Lead to Unpredictable System Behavior  	  In a synthetic testing environment, Intel has observed that some processor, chipset, and motherboard configurations may experience reduced Front Side Bus (FSB) voltage margin during some certain die-to-die data transfers. This combination of configurations and data transfers is rare. This lower voltage margin could lead to FSB data bit errors, which can lead to unpredictable system behavior.  	 When this erratum occurs, it leads to FSB marginality in the system during processor die-to-die transactions, which can lead to unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May be Incorrectly Updated  	  The LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH) may contain incorrect values after any of the following:  36  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   •  Either STPCLK#, NMI (NonMaskable Interrupt) or external interrupts  •  CMP or TEST instructions with an uncacheable memory operand followed by a conditional jump  •  STI/POP SS/MOV SS instructions followed by CMP or TEST instructions and then by a conditional jump  	 When the conditions for this erratum occur, the value of the LER MSRs may be incorrectly updated. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Short Nested Loops That Span Multiple 16-Byte Boundaries May Cause a Machine Check Exception or a System Hang  	  Under a rare set of timing conditions and address alignment of instructions in a short nested loop sequence, software that contains multiple conditional jump instructions and spans multiple 16-byte boundaries, may cause a machine check exception or a system hang.  	 Due to this erratum, a machine check exception or a system hang may occur. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  37   floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Front Side Bus GTLREF Margin Results Are Reduced for Die-to-Die Data Transfers in Intel® Core™2 Extreme Processor QX9770, Which Can Lead to Unpredictable System Behavior  	  In a synthetic testing environment, Intel has observed that some processor, chipset, and motherboard configurations may experience reduced Front Side Bus (FSB) voltage margin during some certain die-to-die data transfers. This combination of configurations and data transfers is rare. This lower voltage margin could lead to FSB data bit errors, which can lead to unpredictable system behavior.  	 When this erratum occurs, it leads to FSB marginality in the system during processor die-to-die transactions, which can lead to unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A VM Exit Due to a Fault While Delivering a Software Interrupt May Save Incorrect Data into the VMCS  	  If a fault occurs during delivery of a software interrupt (INTn) in virtual-8086 mode when virtual mode extensions are in effect and that fault causes a VM exit, incorrect data may be saved into the VMCS. Specifically, information about the software interrupt may not be reported in the IDT-vectoring information field. In addition, the interruptibility-state field may indicate blocking by STI or by MOV SS if such blocking were in effect before execution of the INTn instruction or before execution of the VM-entry instruction that injected the software interrupt.  38  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   	 In general, VMM software that follows the guidelines given in the section “Handling VM Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide should not be affected. If the erratum improperly causes indication of blocking by STI or by MOV SS, the ability of a VMM to inject an interrupt may be delayed by one instruction. 	 VMM software should follow the guidelines given in the section “Handling VM Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  A VM Exit Occuring in IA-32e Mode May Not Produce a VMX Abort When Expected  	  If a VM exit occurs while the processor is in IA-32e mode and the “host address-space size” VM-exit control is 0, a VMX abort should occur. Due to this erratum, the expected VMX aborts may not occur and instead the VM Exit will occur normally. The conditions required to observe this erratum are a VM entry that returns from SMM with the “IA-32e guest” VM-entry control set to 1 in the SMM VMCS and the “host address-space size” VM-exit control cleared to 0 in the executive VMCS.  	 A VM Exit will occur when a VMX Abort was expected. 	 An SMM VMM should always set the “IA-32e guest” VM-entry control in the SMM VMCS to be the value that was in the LMA bit (IA32_EFER.LMA.LMA[bit 10]) in the IA32_EFER MSR (C0000080H) at the time of the last SMM VM exit. If this guideline is followed, that value will be 1 only if the “host address-space size” VM-exit control is 1 in the executive VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  39  
  PSI# Signal Asserted During Reset  	  Power Status Indicator (PSI) is a feature that, when available, may be used to enable voltage regulator power savings while idle and in the Deeper Sleep State (C4 state). Under proper operation the processor will assert the PSI# signal to indicate that the voltage regulator can enter a higher efficiency mode of operation. The processor will incorrectly assert the PSI# signal while the RESET# signal is asserted. This PSI# assertion will extend beyond the deassertion of the RESET# signal for a short duration (maximum of one millisecond).  	 When this erratum occurs on a platform designed to support PSI, the voltage regulator will transition to mode of operation that may not be capable of supplying the necessary voltage and current required by the processor. 	 Do not use PSI# signal without blocking the assertion during the error period as specified from RESET# assertion to a maximum of 1ms from the deasserted edge. 	  For the steppings affected, see the Summary Tables of Changes. 
  Thermal Interrupts are Dropped During and While Exiting Intel® Deep Power-Down State  	  Thermal interrupts are ignored while the processor is in Intel Deep PowerDown State as well as during a small window of time while exiting from Intel Deep Power-Down State. During this window, if the PROCHOT signal is driven or the internal value of the sensor reaches the programmed thermal trip point, then the associated thermal interrupt may be lost.  	 In the event of a thermal event while a processor is waking up from Intel Deep Power-Down State, the processor will initiate an appropriate throttle response. However, the associated thermal interrupt generated may be lost. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Fail When Attempting to Set IA32_DEBUGCTL.FREEZE_WHILE_SMM_EN  	  If bit 14 (FREEZE_WHILE_SMM_EN) is set in the IA32_DEBUGCTL field in the guest-state area of the VMCS, VM entry may fail as described in Section “VMEntry Failures During or After Loading Guest State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2. (The exit reason will be 80000021H and the exit qualification will be zero.) Note that the FREEZE_WHILE_SMM_EN bit in the guest IA32_DEBUGCTL field may be set due to a VMWRITE to that field or due to a VM exit that occurs while IA32_DEBUGCTL.FREEZE_WHILE_SMM_EN=1.  40  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   	 A VMM will not be able to properly virtualize a guest using the FREEZE_WHILE_SMM feature. 	 It is possible for the BIOS to contain a workaround for this erratum. Alternatively, the following software workaround may be used. If a VMM wants to use the FREEZE_WHILE_SMM feature, it can configure an entry in the VM-entry MSR-load area for the IA32_DEBUGCTL MSR (1D9H); the value in the entry should set the FREEZE_WHILE_SMM_EN bit. In addition, the VMM should use VMWRITE to clear the FREEZE_WHILE_SMM_EN bit in the guest IA32_DEBUGCTL field before every VM entry. (It is necessary to do this before every VM entry because each VM exit will save that bit as 1.) This workaround prevents the VM-entry failure and sets the FREEZE_WHILE_SMM_EN bit in the IA32_DEBUGCTL MSR. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Hold-off / Delay a PECI Transaction Longer than Specified by the PECI Protocol  	  PECI (Platform Environment Control Interface) transactions may be held off longer than the PECI protocol hold-off limit while the processor is exiting Cstates. This may occur if STPCLK# has been asserted by the system, the beginning of a PECI message coincides with a C-state transition, and the processor is executing a long instruction flow. Note that the processor can still complete the PECI transaction if the host chooses to process the remainder of the message.  	 Due to this erratum, the processor may violate the PECI hold-off protocol. 	 PECI hosts can choose to either complete or not complete PECI transactions when the processor goes beyond the hold-off limit. The processor generates the PECI hold-off indication by keeping the PECI bus high when the PECI host sends the first bit of the address timing negotiation phase. If the PECI host does not choose to complete the transaction, it should consider the transaction a failure and retry 1ms after the processor deactivates the holdoff indication. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Use Wrong Address to Access Virtual-APIC Page  	  When XFEATURE_ENABLED_MASK register (XCR0) bit 1 (SSE) is 1, a VM entry executed with the “use TPR shadow” VM-execution control set to 1 may use the wrong address to access data on the virtual-APIC page.  	 An affected VM entry may exhibit the following behaviors: (1) it may use wrong areas of the virtual-APIC page to determine whether VM entry fails or whether it induces a VM exit due to the TPR threshold; or (2) it may clear wrong areas of the virtual-APIC page. 	 It is possible for the BIOS to contain a workaround for this erratum. Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  41   	  For the steppings affected, see the Summary Tables of Changes. 
  XRSTORE Instruction May Cause Extra Memory Reads  	 	NA	NA	NA
 area locations containing the FCW/FSW and FOP/FTW Floating Point (FP) registers even though the 64-bit restore mask specified in the EDX:EAX register pair does not indicate to restore the x87 FPU state.  	NA	 Page faults, data breakpoint triggers, etc. may occur due to the unexpected non-speculative accesses to these memory locations. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction May Return Incorrect Brand String  	  When a CPUID instruction is executed with EAX = 8000_0002H, 8000_0003H, or 8000_0004H, the returned EAX, EBX, ECX, and/or EDX values may be incorrect.  	 When this erratum occurs, the processor may report an incorrect brand string. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Global Instruction TLB Entries May Not be Invalidated on a VM Exit or VM Entry  	  If a VMM is using global page entries (CR4.PGE is enabled and any present page-directories or page-table entries are marked global), then on a VM entry, the instruction TLB (Translation Lookaside Buffer) entries caching global page translations of the VMM may not be invalidated. In addition, if a guest is using global page entries, then on a VM exit, the instruction TLB entries caching global page translations of the guest may not be invalidated.  	 Stale global instruction linear to physical page translations may be used by a VMM after a VM exit or a guest after a VM entry. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  When Intel® Deep Power-Down State is Being Used, IA32_FIXED_CTR2 May Return Incorrect Cycle Counts  	  When the processor is operating at an N/2 core to front side bus ratio, after exiting an Intel Deep Power-Down State, the internal increment value for IA32_FIXED_CTR2 (Fixed Function Performance Counter 2, 30BH) will not take into account the half ratio setting.  42  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   	 Due to this erratum, IA32_FIXED_CTR2 MSR will not return reliable counts after returning from an Intel Deep Power-Down State. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Enabling PECI via the PECI_CTL MSR Does Not Enable PECI and May Corrupt the CPUID Feature Flags  	  Writing PECI_CTL MSR (Platform Environment Control Interface Control Register) will not update the PECI_CTL MSR (5A0H), instead it will write to the VMM Feature Flag Mask MSR (CPUID_FEATURE_MASK1, 478H).  	 Due to this erratum, PECI (Platform Environment Control Interface) will not be enabled as expected by the software. In addition, due to this erratum, processor features reported in ECX following execution of leaf 1 of CPUID (EAX=1) may be masked. Software utilizing CPUID leaf 1 to verify processor capabilities may not work as intended. 	 It is possible for the BIOS to contain a workaround for this erratum. Do not initialize PECI before processor update is loaded. Also, load processor update as soon as possible after RESET as documented in the RS – Wolfdale Processor Family Bios Writers Guide, Section 14.8.3 Bootstrap Processor Initialization Requirements. 	  For the steppings affected, see the Summary Tables of Changes. 
  INIT Incorrectly Resets IA32_LSTAR MSR  	  In response to an INIT reset initiated either via the INIT# pin or an IPI (Inter Processor Interrupt), the processor should leave MSR values unchanged. Due to this erratum IA32_LSTAR MSR (C0000082H), which is used by the iA32e SYSCALL instruction, is being cleared by an INIT reset.  	 If software programs a value in IA32_LSTAR to be used by the SYSCALL instruction and the processor subsequently receives an INIT reset, the SYSCALL instructions will not behave as intended. Intel has not observed this erratum in any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning7From Real Mode to Protected Mode  	  During the tranition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  43   	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	 LBR, BTS and BTM may report incorrect information in the event of an exception/interrupt. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The XRSTOR Instruction May Fail to Cause a General-Protection Exception  	  The XFEATURE_ENABLED_MASK register (XCR0) bits [63:9] are reserved and must be 0; consequently, the XRSTOR instruction should cause a generalprotection exception if any of the corresponding bits in the XSTATE_BV field	NA	NA	NA
 logical processor may fail to cause such an exception if one or more of these reserved bits are set to 1.  	NA	 Software may not operate correctly if it relies on the XRSTOR instruction to cause a general-protection exception when any of the bits [63:9] in the	NA	NA
 	NA	NA	 It is possible for the BIOS to contain a workaround for this erratum. 	  44  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  
 	NA	NA	NA	NA
 XSTATE_BV Field  	  Bits 63:2 of the HEADER.XSTATE_BV are reserved and must be 0. Due to this	NA	NA	NA
 bits.  	NA	 If one of bits 63:2 of the XSTATE_BV field in the header of the	NA	NA
 instruction, a subsequent execution of XRSTOR may not generate the #GP (general-protection exception) that would have occurred in the absence of this erratum. Alternatively, if one of those bits had been 0 and was then set	NA	NA	NA	NA
 #GP that would not have occurred in the absence of this erratum. 	NA	NA	 It is possible for the BIOS to contain a partial workaround for this erratum	NA
 ensure compatibility with future processors, software should not set any	NA	NA	NA	NA
 save area. 	NA	NA	NA	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
  	 	NA	NA	NA
 ordering violation with older store operations. The store operations done to	NA	NA	NA	NA
 used to store only the SSE context, may appear to execute before the completion of older store operations. 	NA	NA	NA	NA
 only, may not follow program order and may execute before older stores. Intel has not observed this erratum with any commercially available software. 	NA	NA	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Memory Ordering Violation With Stores/Loads Crossing a Cacheline Boundary  	  When two logical processors are accessing the same data that is crossing a cacheline boundary without serialization, with a specific set of processor internal conditions, it is possible to have an ordering violation between memory store and load operations.  	 Due to this erratum, proper load/store ordering may not be followed when multiple logical processors are accessing the same data that crosses a cacheline boundary without serialization. 	 It is possible for the BIOS to contain a workaround for this erratum. Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  45   	  For the steppings affected, see the Summary Tables of Changes. 
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel Architecture Software Developer's Manual Volume 3: System Programming Guide, including a General Protection Fault (GPF) or other unexpected behaviors. In the event that unpredictable execution causes a GPF the application executing the unsynchronized XMC operation would be terminated by the operating system. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel Architecture Software Developer's Manual Volume 3: System Programming Guide, Section: Handling Self- and Cross-Modifying Code. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1”. 	  For the steppings affected, see the Summary Tables of Changes. 
  Not-Present Page Faults May Set the RSVD Flag in the Error Code  	  An attempt to access a page that is not marked present causes a page fault. Such a page fault delivers an error code in which both the P flag (bit 0)  46  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor   and the RSVD flag (bit 3) are 0. Due to this erratum, not-present page faults may deliver an error code in which the P flag is 0 but the RSVD flag is 1. 	 Software may erroneously infer that a page fault was due to a reserved-bit violation when it was actually due to an attempt to access a not-present page. Intel has not observed this erratum with any commercially available software. 	 Page-fault handlers should ignore the RSVD flag in the error code if the P flag is 0. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to “NMI-Window Exiting” May Be Delayed by One Instruction  	  If VM entry is executed with the “NMI-window exiting” VM-execution control set to 1, a VM exit with exit reason “NMI window” should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	 VMM software using “NMI-window exiting” for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  Intel® Core™2 Extreme Processor and Intel® Core™2 Quad Processor  47   	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Overwrite the Value for the IA32_DEBUGCTL MSR Specified in the VM-Entry MSR-Load Area  	  Following a successful VM entry with the “load debug controls” VM-entry control set to 1, the IA32_DEBUGCTL MSR (1D9H) will always contain the value held in the guest IA32_DEBUGCTL field in the virtual-machine control structure (VMCS). If there is a value for the MSR in the VM-entry MSR-load area, the processor will incorrectly overwrite that value with the value in the VMCS.  	 Due to this erratum, VM entry may result in the wrong value being loaded into the IA32_DEBUGCTL MSR. Intel has not observed this erratum with any commercially available software. 	 Software seeking to load the IA32_DEBUGCTL MSR as part of VM entry should place the desired value in the guest IA32_DEBUGCTL field in the VMCS and set the “load debug controls” VM-entry control to 1. 	  For the steppings affected, see the Summary Tables of Changes. 
  64-bit Register IP-relative Instruction May Return Unexpected Results  	  Under an unlikely and complex sequence of conditions in 64-bit mode, a register IP-relative instruction result may be incorrect.  	 A register IP-relative instruction result may be incorrect and could cause software to read from or write to an incorrect memory location. This may result in an unexpected page fault or unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	NA
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions as described in the Software Developers Manual section "Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors" the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation. 	Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May Be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g., NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commerciallyavailable software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   21  
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	 Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. • If an instruction that performs a memory load causes a code segment limit violation. • If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending. • If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Topof-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	 In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the sideeffect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception. 	Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault. 	In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  22  For the steppings affected, see the Summary Tables of Changes.   
  Incorrect Address Computed for Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64-KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4-GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM Will Be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect.  Note:  This issue would only occur when one of the 3 above-mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e., residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Refer to "Procedure Calls for Block-Structured Languages" in IA-32 Intel® Architecture Software Developer's Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in Ring 3. Faults are usually processed in Ring 0 and stack switch occurs when transferring to Ring 0. Intel has not observed this erratum on any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23  
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection Fault (#GP) for Instructions Greater Than 15 Bytes May Be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g., Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	 Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4-G limit (0ffffffffh) may not signal a #GP fault.  	 When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault. 	Software should ensure that memory accesses in 32-bit mode do not occur above the 4-G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address When an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with Bits 63 to 48 incorrectly sign extended to all 1's. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	 LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt. 	None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.   
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	 When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially-available software. 	Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register during RSM While Transitioning from Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first FAR JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first FAR JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the FAR JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Read Miss to Level 3 Cache Fill Occupancy Counter May Be Incorrect  	  Whenever an Level 3 cache fill conflicts with another request's address, the miss to fill occupancy counter, UNC_GQ_ALLOC.RT_LLC_MISS (Event 02H), will provide erroneous results.  	 The Performance Monitoring UNC_GQ_ALLOC.RT_LLC_MISS event may count a value higher than expected. The extent to which the value is higher than expected is determined by the frequency of the L3 address conflict. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   25  
  A VM Exit on MWAIT May Incorrectly Report the Monitoring Hardware As Armed  	  A processor write to the address range armed by the MONITOR instruction may not immediately trigger the monitoring hardware. Consequently, a VM exit on a later MWAIT may incorrectly report the monitoring hardware as armed, when it should be reported as unarmed due to the write occurring prior to the MWAIT.  	 If a write to the range armed by the MONITOR instruction occurs between the MONITOR and the MWAIT, the MWAIT instruction may start executing before the monitoring hardware is triggered. If the MWAIT instruction causes a VM exit, this could cause its exit qualification to incorrectly report 0x1. In the recommended usage model for MONITOR/MWAIT, there is no write to the range armed by the MONITOR instruction between the MONITOR and the MWAIT. 	Software should never write to the address range armed by the MONITOR instruction between the MONITOR and the subsequent MWAIT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event SEGMENT_REG_LOADS Counts Inaccurately  	  The performance monitor event SEGMENT_REG_LOADS (Event 06H) counts instructions that load new values into segment registers. The value of the count may be inaccurate.  	 The performance monitor event SEGMENT_REG_LOADS may reflect a count higher or lower than the actual number of events. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP on Segment Selector Descriptor That Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	 An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Improper Parity Error Signaled in the IQ Following Reset When a Code Breakpoint Is Set on a #GP Instruction  	  While coming out of cold reset or exiting from C6, if the processor encounters an instruction longer than 15 bytes (which causes a #GP) and a code breakpoint is enabled on that instruction, an IQ (Instruction Queue) parity error may be incorrectly logged resulting in an MCE (Machine Check Exception).  	 When this erratum occurs, an MCE may be incorrectly signaled. 	None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction If It Is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially-available software or system. 	As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MPERF Counter Stops Counting during On-Demand TM1  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, the ratio of IA32_MPERF (MSR E7H) to IA32_APERF (MSR E8H) should reflect actual performance while Intel TM1 or ondemand throttling is activated. Due to this erratum, IA32_MPERF MSR stops counting while Intel TM1 or on-demand throttling is activated, and the ratio of the two will indicate higher processor performance than actual.  	 The incorrect ratio of IA32_APERF/IA32_MPERF can mislead software P-state (performance state) management algorithms under the conditions described above. It is possible for the Operating System to observe higher processor utilization than actual, which could lead the OS into raising the P-state. During Intel TM1 activation, the OS Pstate request is irrelevant and while on-demand throttling is enabled, it is expected that the OS will not be changing the P-state. This erratum should result in no practical implication to software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Memory Controller tTHROT_OPREF Timings May Be Violated during Self-Refresh Entry  	  During self-refresh entry, the memory controller may issue more refreshes than permitted by tTHROT_OPREF (bits 29:19 in MC_CHANNEL_{0,1}_REFRESH_TIMING CSR).  	 The intention of tTHROT_OPREF is to limit current. Since current supply conditions near self refresh entry are not critical, there is no measurable impact due to this erratum. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   27  
  Synchronous Reset of IA32_APERF/IA32_MPERF Counters on Overflow Does Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. This synchronous reset does not work. Instead, both MSRs increment and overflow independently.  	 Software can not rely on synchronous reset of the IA32_APERF/IA32_MPERF registers. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Disabling Thermal Monitor While Processor Is Hot, Then Re-enabling, May Result in Stuck Core Operating Ratio  	  If a processor is at its TCC (Thermal Control Circuit) activation temperature and then Thermal Monitor is disabled by a write to IA32_MISC_ENABLES MSR (1A0H) bit [3], a subsequent re-enable of Thermal Monitor will result in an artificial ceiling on the maximum core P-state. The ceiling is based on the core frequency at the time of Thermal Monitor disable. This condition will only correct itself once the processor reaches its TCC activation temperature again.  	 Since Intel requires that Intel Thermal Monitor be enabled in order to be operating within specification, this erratum should never be seen during normal operation. 	Software should not disable Thermal Monitor during processor operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing the Local Vector Table (LVT) When an Interrupt Is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  xAPIC Timer May Decrement Too Quickly Following an Automatic Reload While in Periodic Mode  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	 When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick. 	None identified. 	  28  For the steppings affected, see the Summary Tables of Changes.   
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	 Memory ordering may be violated. Intel has not observed this erratum with any commercially-available software. 	Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
  Infinite Stream of Interrupts May Occur If an ExtINT Delivery Mode Interrupt Is Received While All Cores Are in C6  	  If all logical processors in a core are in C6, an ExtINT delivery mode interrupt is pending in the xAPIC and interrupts are blocked with EFLAGS.IF=0, the interrupt will be processed after C6 wakeup and after interrupts are re-enabled (EFLAGS.IF=1). However, the pending interrupt event will not be cleared.  	 Due to this erratum, an infinite stream of interrupts will occur on the core servicing the external interrupt. Intel has not observed this erratum with any commercially-available software/system. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Two xAPIC Timer Event Interrupts May Unexpectedly Occur  	  If an xAPIC timer event is enabled and while counting down the current count reaches 1 at the same time that the processor thread begins a transition to a low power Cstate, the xAPIC may generate two interrupts instead of the expected one when the processor returns to C0.  	 Due to this erratum, two interrupts may unexpectedly be generated by an xAPIC timer event. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EOI Transaction May Not Be Sent If Software Enters Core C6 during an Interrupt Service Routine  	  If core C6 is entered after the start of an interrupt service routine but before a write to the APIC EOI register, the core may not send an EOI transaction (if needed) and further interrupts from the same priority level or lower may be blocked.  	 EOI transactions and interrupts may be blocked when core C6 is used during interrupt service routines. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29  
  FREEZE_WHILE_SMM Does Not Prevent Event from Pending PEBS during SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if 1. a performance counter overflowed before an SMI 2. a PEBS record has not yet been generated because another count of the event has not occurred 3. the monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM.  	 A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May Be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	 Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6 May Contain Incorrect Information When the First Instruction after a MOV SS,r/m or POP SS Is a Store  	  Normally, each instruction clears the changes in DR6 (Debug Status Register) caused by the previous instruction. However, the instruction following a MOV SS,r/m (MOV to the stack segment selector) or POP SS (POP stack segment selector) instruction will not clear the changes in DR6 because data breakpoints are not taken immediately after a MOV SS,r/m or POP SS instruction. Due to this erratum, any DR6 changes caused by a MOV SS,r/m or POP SS instruction may be cleared if the following instruction is a store.  	 When this erratum occurs, incorrect information may exist in DR6. This erratum will not be observed under normal usage of the MOV SS,r/m or POP SS instructions (i.e., following them with an instruction that writes [e/r]SP). When debugging or when developing debuggers, this behavior should be noted. 	None identified. 	  30  For the steppings affected, see the Summary Tables of Changes.   
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May Also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	 Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_PERF_GLOBAL_CTRL MSR May Be Incorrectly Initialized  	  The IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [34:32] may be incorrectly set to 7H after reset; the correct value should be 0H.  	 The IA32_PERF_GLOBAL_CTRL MSR bits [34:32] may be incorrect after reset (EN_FIXED_CTR{0, 1, 2} may be enabled). 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counter INST_RETIRED.STORES May Count Higher Than Expected  	  Performance Monitoring counter INST_RETIRED.STORES (Event: C0H) is used to track retired instructions which contain a store operation. Due to this erratum, the processor may also count other types of instructions including WRMSR and MFENCE.  	 Performance Monitoring counter INST_RETIRED.STORES may report counts higher than expected. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Sleeping Cores May Not Be Woken up on Logical Cluster Mode Broadcast IPI Using Destination Field Instead of Shorthand  	  If software sends a logical cluster broadcast IPI using a destination shorthand of 00B (No Shorthand) and writes the cluster portion of the Destination Field of the Interrupt Command Register to all ones while not using all 1s in the mask portion of the Destination Field, target cores in a sleep state that are identified by the mask portion of the Destination Field may not be woken up. This erratum does not occur if the destination shorthand is set to 10B (All Including Self) or 11B (All Excluding Self).  	 When this erratum occurs, cores which are in a sleep state may not wake up to handle the broadcast IPI. Intel has not observed this erratum with any commercially-available software. 	Use destination shorthand of 10B or 11B to send broadcast IPIs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting Executions of FXRSTOR May Update State Inconsistently  	  The state updated by a faulting FXRSTOR instruction may vary from one execution to another.  	 Software that relies on x87 state or SSE state following a faulting execution of FXRSTOR may behave inconsistently. 	Software handling a fault on an execution of FXRSTOR can compensate for execution variability by correcting the cause of the fault and executing FXRSTOR again. 	  For the steppings affected, see the Summary Tables of Changes.   31  
  Performance Monitor Event EPT.EPDPE_MISS May Be Counted While EPT Is Disabled  	  Performance monitor event EPT.EPDPE_MISS (Event: 4FH, Umask: 08H) is used to count Page Directory Pointer table misses while EPT (extended page tables) is enabled. Due to this erratum, the processor will count Page Directory Pointer table misses regardless of whether EPT is enabled or not.  	 Due to this erratum, performance monitor event EPT.EPDPE_MISS may report counts higher than expected. 	Software should ensure this event is only enabled while in EPT mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  Memory Aliasing of Code Pages May Cause Unpredictable System Behavior  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncachable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	 If this erratum occurs the system may have unpredictable behavior including a system hang. The aliasing of memory regions, a condition necessary for this erratum to occur, is documented as being unsupported in the Intel 64 and IA-32 Intel® Architecture Software Developer's Manual, Volume 3A, in the section titled Programming the PAT. Intel has not observed this erratum with any commercially-available software or system. 	Code pages should not be mapped with uncacheable and cacheable memory types at the same time. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counters May Count Incorrectly  	  Under certain circumstances, a general purpose performance counter, IA32_PMC0-4 (C1H - C4H), may count at core frequency or not count at all instead of counting the programmed event.  	 The Performance Monitor Counter IA32_PMCx may not properly count the programmed event. Due to the requirements of the workaround there may be an interruption in the counting of a previously programmed event during the programming of a new event. 	Before programming the performance event select registers, IA32_PERFEVTSELx MSR (186H - 189H), the internal monitoring hardware must be cleared. This is accomplished by first disabling, saving valid events and clearing from the select registers, then programming three event values 0x4300D2, 0x4300B1 and 0x4300B5 into the IA32_PERFEVTSELx MSRs, and finally continuing with new event programming and restoring previous programming if necessary. Each performance counter, IA32_PMCx, must have its corresponding IA32_PREFEVTSELx MSR programmed with at least one of the event values and must be enabled in IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [3:0]. All three values must be written to either the same or different IA32_PERFEVTSELx MSRs before programming the performance counters. Note that the performance counter will not increment when its IA32_PERFEVTSELx MSR has a value of 0x4300D2, 0x4300B1 or 0x4300B5 because those values have a zero UMASK field (bits [15:8]). 	  32  For the steppings affected, see the Summary Tables of Changes.   
  Performance Monitor Event Offcore_response_0 (B7H) Does Not Count NT Stores to Local DRAM Correctly  	  When a IA32_PERFEVTSELx MSR is programmed to count the Offcore_response_0 event (Event:B7H), selections in the OFFCORE_RSP_0 MSR (1A6H) determine what is counted. The following two selections do not provide accurate counts when counting NT (Non-Temporal) Stores: • OFFCORE_RSP_0 MSR bit [14] is set to 1 (LOCAL_DRAM) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are not counted when they should have been. • OFFCORE_RSP_0 MSR bit [9] is set to (OTHER_CORE_HIT_SNOOP) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are counted when they should not have been.  	 The counter for the Offcore_response_0 event may be incorrect for NT stores. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	 None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit. 	If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Back to Back Uncorrected Machine Check Errors May Overwrite IA32_MC3_STATUS.MSCOD  	  When back-to-back uncorrected machine check errors occur that would both be logged in the IA32_MC3_STATUS MSR (40CH), the IA32_MC3_STATUS.MSCOD (bits [31:16]) field may reflect the status of the most recent error and not the first error. The rest of the IA32_MC3_STATUS MSR contains the information from the first error.  	 Software should not rely on the value of IA32_MC3_STATUS.MSCOD if IA32_MC3_STATUS.OVER (bit [62]) is set. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   33  
  Corrected Errors with a Yellow Error Indication May Be Overwritten by Other Corrected Errors  	  A corrected cache hierarchy data or tag error that is reported with IA32_MCi_STATUS.MCACOD (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one) and a yellow threshold-based error status indication (bits [54:53] equal to 10B) may be overwritten by a corrected error with a no tracking indication (00B) or green indication (01B).  	 Corrected errors with a yellow threshold-based error status indication may be overwritten by a corrected error without a yellow indication. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events DCACHE_CACHE_LD and DCACHE_CACHE_ST May Overcount  	  The performance monitor events DCACHE_CACHE_LD (Event 40H) and DCACHE_CACHE_ST (Event 41H) count cacheable loads and stores that hit the L1 cache. Due to this erratum, in addition to counting the completed loads and stores, the counter will incorrectly count speculative loads and stores that were aborted prior to completion.  	 The performance monitor events DCACHE_CACHE_LD and DCACHE_CACHE_ST may reflect a count higher than the actual number of events. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Rapid Core C3/C6 Transitions May Cause Unpredictable System Behavior  	  Under a complex set of internal conditions, cores rapidly performing C3/C6 transitions in a system with Intel® Hyper-Threading Technology enabled may cause a machine check error (IA32_MCi_STATUS.MCACOD = 0x0106), system hang or unpredictable system behavior.  	 This erratum may cause a machine check error, system hang or unpredictable system behavior. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events INSTR_RETIRED and MEM_INST_RETIRED May Count Inaccurately  	  The performance monitor event INSTR_RETIRED (Event C0H) should count the number of instructions retired, and MEM_INST_ RETIRED (Event 0BH) should count the number of load or store instructions retired. However, due to this erratum, they may undercount.  	 The performance monitor event INSTR_RETIRED and MEM_INST_RETIRED may reflect a count lower than the actual number of events. 	None identified. 	  34  For the steppings affected, see the Summary Tables of Changes.   
  A Page Fault May Not Be Generated When the PS bit Is Set to "1" in a PML4E or PDPTE  	  On processors supporting Intel 64 architecture, the PS bit (Page Size, Bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	Software should not set Bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to "1". 	  For the steppings affected, see the Summary Tables of Changes. 
  BIST Results May Be Additionally Reported after a GETSEC[WAKEUP] or INIT-SIPI Sequence  	  BIST results should only be reported in EAX the first time a logical processor wakes up from the Wait-For-SIPI state. Due to this erratum, BIST results may be additionally reported after INIT-SIPI sequences and when waking up RLP's from the SENTER sleep state using the GETSEC[WAKEUP] command.  	 An INIT-SIPI sequence may show a non-zero value in EAX upon wakeup when a zero value is expected. RLP's waking up for the SENTER sleep state using the GETSEC[WAKEUP] command may show a different value in EAX upon wakeup than before going into the SENTER sleep state. 	If necessary software may save the value in EAX prior to launching into the secure environment and restore upon wakeup and/or clear EAX after the INIT-SIPI sequence. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) May Be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	 Software may observe #MF being signaled before pending interrupts are serviced. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   35  
  VM Exits Due to "NMI-Window Exiting" May Be Delayed by One Instruction  	  If VM entry is executed with the "NMI-window exiting" VM-execution control set to 1, a VM exit with exit reason "NMI window" should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	 VMM software using "NMI-window exiting" for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to EPT Violations Do Not Record Information about PreIRET NMI Blocking  	  With certain settings of the VM-execution controls VM exits due to EPT violations set bit 12 of the exit qualification if the EPT violation was a result of an execution of the IRET instruction that commenced with non-maskable interrupts (NMIs) blocked. Due to this erratum, such VM exits will instead clear this bit.  	 Due to this erratum, a virtual-machine monitor that relies on the proper setting of bit 12 of the exit qualification may deliver NMIs to guest software prematurely. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Multiple Performance Monitor Interrupts Are Possible on Overflow of IA32_FIXED_CTR2  	  When multiple performance counters are set to generate interrupts on an overflow and more than one counter overflows at the same time, only one interrupt should be generated. However, if one of the counters set to generate an interrupt on overflow is the IA32_FIXED_CTR2 (MSR 30BH) counter, multiple interrupts may be generated when the IA32_FIXED_CTR2 overflows at the same time as any of the other performance counters.  	 Multiple counter overflow interrupts may be unexpectedly generated. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBRs May Not Be Initialized during Power-On Reset of the Processor  	  If a second reset is initiated during the power-on processor reset cycle, the LBRs (Last Branch Records) may not be properly initialized.  	 Due to this erratum, debug software may not be able to rely on the LBRs out of poweron reset. 	Ensure that the processor has completed its power-on reset cycle prior to initiating a second reset. 	  36  For the steppings affected, see the Summary Tables of Changes.   
  LBR, BTM or BTS Records May Have Incorrect Branch from Information after an Enhanced Intel SpeedStep® Technology Transition, T-states, C1E, or Adaptive Thermal Throttling  	  The "From" address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after an Enhanced Intel SpeedStep Technology transition, T-states, C1E (C1 Enhanced), or Adaptive Thermal Throttling.  	 When the LBRs, BTM or BTS are enabled, some records may have incorrect branch "From" addresses for the first branch after an Enhanced Intel SpeedStep Technology transition, T-states, C1E, or Adaptive Thermal Throttling. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMX-Preemption Timer Does Not Count Down at the Rate Specified  	  The VMX-preemption timer should count down by 1 every time a specific bit in the TSC (Time Stamp Counter) changes. (This specific bit is indicated by IA32_VMX_MISC bits [4:0] (0x485h) and has a value of 5 on the affected processors.) Due to this erratum, the VMX-preemption timer may instead count down at a different rate and may do so only intermittently.  	 The VMX-preemption timer may cause VM exits at a rate different from that expected by software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Multiple Performance Monitor Interrupts Are Possible on Overflow of Fixed Counter 0  	  The processor can be configured to issue a PMI (performance monitor interrupt) upon overflow of the IA32_FIXED_CTR0 MSR (309H). A single PMI should be observed on overflow of IA32_FIXED_CTR0, however multiple PMIs are observed when this erratum occurs. This erratum only occurs when IA32_FIXED_CTR0 overflows and the processor and counter are configured as follows: • Intel® Hyper-Threading Technology is enabled • IA32_FIXED_CTR0 local and global controls are enabled • IA32_FIXED_CTR0 is set to count events only on its own thread (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] = ‘0) • PMIs are enabled on IA32_FIXED_CTR0 (IA32_FIXED_CTR_CTRL MSR bit [3] = ‘1) • Freeze_on_PMI feature is enabled (IA32_DEBUGCTL MSR (1D9H) bit [12] = ‘1)  	 When this erratum occurs there may be multiple PMIs observed when IA32_FIXED_CTR0 overflows. 	Disable the FREEZE_PERFMON_ON_PMI feature in IA32_DEBUGCTL MSR (1D9H) bit [12]. 	  For the steppings affected, see the Summary Tables of Changes.   37  
  VM Exits Due to LIDT/LGDT/SIDT/SGDT Do Not Report Correct Operand Size  	  When a VM exit occurs due to a LIDT, LGDT, SIDT, or SGDT instruction with a 32-bit operand, bit 11 of the VM-exit instruction information field should be set to 1. Due to this erratum, this bit is instead cleared to 0 (indicating a 16-bit operand).  	 Virtual-machine monitors cannot rely on bit 11 of the VM-exit instruction information field to determine the operand size of the instruction causing the VM exit. 	Virtual Machine Monitor software may decode the instruction to determine operand size. 	  For the steppings affected, see the Summary Tables of Changes. 
  DPRSLPVR Signal May Be Incorrectly Asserted on Transition between Low Power C-states  	  On entry to or exit from package C6 states, DPRSLPVR (Deeper Sleep Voltage Regulator) signal may be incorrectly asserted.  	 Due to this erratum, platform voltage regulator may shutdown 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA May Not Count Events Correctly  	  Performance Monitor Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA should only increment the count when a load is blocked by a store. Due to this erratum, the count will be incremented whenever a load hits a store, whether it is blocked or can forward. In addition this event does not count for specific threads correctly.  	 If Intel® Hyper-Threading Technology is disabled, the Performance Monitor events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA may indicate a higher occurrence of loads blocked by stores than have actually occurred. If Intel Hyper-Threading Technology is enabled, the counts of loads blocked by stores may be unpredictable and they could be higher or lower than the correct count. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	 When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay. 	None identified. 	  38  For the steppings affected, see the Summary Tables of Changes.   
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	 The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially-available software. 	None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Following INVEPT or INVVPID May Fail to Flush All Translations for a Large Page  	  This erratum applies if the address of the memory operand of an INVEPT or INVVPID instruction resides on a page larger than 4KBytes and either (1) that page includes the low 1 MBytes of physical memory; or (2) the physical address of the memory operand matches an MTRR that covers less than 4 MBytes. A subsequent execution of INVLPG that targets the large page and that occurs before the next VM-entry instruction may fail to flush all TLB entries for the page. Such entries may persist in the TLB until the next VM-entry instruction.  	 Accesses to the large page between INVLPG and the next VM-entry instruction may incorrectly use translations that are inconsistent with the in-memory page tables. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	 The values of the LER MSRs may be unreliable. 	None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	 Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   39  
  Debug Exception Flags DR6.B0-B3 Flags May Be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	 The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Erratum removed as it does not apply to the Intel® Core™ i7-600, i5500, i5-400 and i3-300 Mobile Processor Series  	  NA  	 NA 	NA 	  NA 
  Delivery of Certain Events Immediately Following a VM Exit May Push a Corrupted RIP onto the Stack  	  If any of the following events is delivered immediately following a VM exit to 64-bit mode from outside 64-bit mode, bits 63:32 of the RIP value pushed on the stack may be cleared to 0: • A non-maskable interrupt (NMI); • A machine-check exception (#MC); • A page fault (#PF) during instruction fetch; or • A general-protection exception (#GP) due to an attempt to decode an instruction whose length is greater than 15 bytes.  	 Unexpected behavior may occur due to the incorrect value of the RIP on the stack. Specifically, return from the event handler via IRET may encounter an unexpected page fault or may begin fetching from an unexpected code address. 	It is possible for the BIOS to contain a workaround for this erratum. 	  40  For the steppings affected, see the Summary Tables of Changes.   
  A String Instruction that Re-maps a Page May Encounter an Unexpected Page Fault  	  An unexpected page fault (#PF) may occur for a page under the following conditions:  	 Software may see an unexpected page fault that indicates that there is no translation for the page. Intel has not observed this erratum with any commercially-available software or system. • The paging structures initially specify a valid translation for the page. • Software modifies the paging structures so that there is no valid translation for the page (e.g., by clearing to 0 the present bit in one of the paging-structure entries used to translate the page). • An iteration of a string instruction modifies the paging structures so that the translation is again a valid translation for the page (e.g., by setting to 1 the bit that was cleared earlier). • A later iteration of the same string instruction loads from a linear address on the page. • Software did not invalidate TLB entries for the page between the first modification of the paging structures and the string instruction. In this case, the load in the later iteration may cause a page fault that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). 	Software should not update the paging structures with a string instruction that accesses pages mapped the modified paging structures. 	  For the steppings affected, see the Summary Tables of Changes. 
  Logical Processor May Use Incorrect VPID after VM Entry That Returns From SMM  	  A logical processor in VMX root operation should use VPID 0000H. Due to this erratum, a logical processor may instead use VPID 1FB3H if VMX root operation was entered using a VM entry that returns from SMM.  	 After a VM entry that sets the "enable VPID" VM-execution control and that establishes VPID 1FB3H, the logical processor may erroneously use TLB entries that were cached in VMX root operation. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  MSR_TURBO_RATIO_LIMIT MSR May Return Intel® Turbo Boost Technology Core Ratio Multipliers for Non-Existent Core Configurations  	  MSR_TURBO_RATIO_LIMIT MSR (1ADH) is designed to describe the maximum Intel Turbo Boost Technology potential of the processor. On some processors, a non-zero Intel Turbo Boost Technology value will be returned for non-existent core configurations.  	 Due to this erratum, software using the MSR_TURBO_RATIO_LIMIT MSR to report Intel Turbo Boost Technology processor capabilities may report erroneous results. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   41  
  PCI Express x16 Port Logs Bad TLP Correctable Error When Receiving a Duplicate TLP  	  In the PCI Express 2.0 Specification a receiver should schedule an ACK and discard a duplicate TLP (Transaction Layer Packet) before ending the transaction within the data link layer. In the processor, the PCI Express x16 root port will set the Bad TLP status bit in the Correctable Error Status Register (Bus 0; Device 1 and 6; Function 0; Offset 1D0h; bit 6) in addition to scheduling an ACK and discarding the duplicate TLP. Note: The duplicate packet can be received only as a result of a correctable error in the other end point (Transmitter).  	 The processor does not comply with the PCI Express 2.0 Specification. This does not impact functional compatibility or interoperability with other PCIe devices. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express x16 Root Port Incorrectly NAK's a Nullified TLP  	  In the processor, the PCI Express root port may NAK a nullified TLP (Transaction Layer Packet). This behavior is a result of an incorrect DW (Double Word) enable generation on the processors when packets end with EDB (End Bad Symbol). This also occurs only if total TLP length <= 8 DW in which CRC (Cyclic Redundancy Check) check/framing upstream checks will fail. This failure causes a NAK to be unexpectedly generated for TLP's which have packets with inverted CRC and EDB's. The PCI-e specification revision 2.0 states that such cycles should be dropped and no NAK should be generated. The processor should NAK a nullified TLP only when there is a CRC error or a sequence check fail.  	 The processor does not comply with the PCI Express 2.0 Specification. This does not impact functional compatibility or interoperability with other PCIe devices. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express Graphics x16 Receiver Error Reported When Receiver With L0s Enabled and Link Retrain Performed  	  If the Processor PCI Express root port is the receiver with L0s enabled and the root port itself initiates a transition to the recovery state via the retrain link configuration bit in the 'Link Control' register (Bus 0; Device 1 and 6; Function 0; Offset B0H; bit 5), then the root port may not mask the receiver or bad DLLP (Data Link Layer Packet) errors as expected. These correctable errors should only be considered valid during PCIe configuration and L0 but not L0s. This causes the processor to falsely report correctable errors in the 'Device Status' register (Bus 0; Device 1 and 6; Function 0; Offset AAH; bit 0) upon receiving the first FTS (Fast Training Sequence) when exiting Receiver L0s. Under normal conditions there is no reason for the Root Port to initiate a transition to Recovery. Note: This issue is only exposed when a recovery event is initiated by the processor.  	 The processor does not comply with the PCI Express 2.0 Specification. This does not impact functional compatibility or interoperability with other PCIe devices. 	None identified. 	  42  For the steppings affected, see the Summary Tables of Changes.   
  Internal Parity Error May Be Incorrectly Signaled during C6 Exit  	  In a complex set of internal conditions an internal parity error may occur during a Core C6 exit.  	 Due to this erratum, an uncorrected error may be reported and a machine check exception may be triggered. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMIs during Core C6 Transitions May Cause the System to Hang  	  If a performance monitoring counter overflows and causes a PMI (Performance Monitoring Interrupt) at the same time that the core enters C6, then this may cause the system to hang.  	 Due to this erratum, the processor may hang when a PMI coincides with core C6 entry. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  2-MB Page Split Lock Accesses Combined with Complex Internal Events May Cause Unpredictable System Behavior  	  A 2-MB Page Split Lock (a locked access that spans two 2-MB large pages) coincident with additional requests that have particular address relationships in combination with a timing sensitive sequence of complex internal conditions may cause unpredictable system behavior.  	 This erratum may cause unpredictable system behavior. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Extra APIC Timer Interrupt May Occur during a Write to the Divide Configuration Register  	  If the APIC timer Divide Configuration Register (Offset 03E0H) is written at the same time that the APIC timer Current Count Register (Offset 0390H) reads 1H, it is possible that the APIC timer will deliver two interrupts.  	 Due to this erratum, two interrupts may unexpectedly be generated by an APIC timer event. 	Software should reprogram the Divide Configuration Register only when the APIC timer interrupt is disarmed. 	  For the steppings affected, see the Summary Tables of Changes. 
  TXT.PUBLIC.KEY Is Not Reliable  	  Intel TXT (Intel Trusted Execution Technology) capable processors, the TXT.PUBLIC.KEY value (Intel TXT registers FED3_0400H to FED3_041FH) is not reliable.  	 Due to this erratum, the TXT.PUBLIC.KEY value should not be relied on or used for retrieving the hash of the Intel TXT public key for the platform. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes.   43  
  8259 Virtual Wire B Mode Interrupt May Be Dropped When It Collides with Interrupt Acknowledge Cycle from the Preceding Interrupt  	  If an un-serviced 8259 Virtual Wire B Mode (8259 connected to IOAPIC) External Interrupt is pending in the APIC and a second 8259 Virtual Wire B Mode External Interrupt arrives, the processor may incorrectly drop the second 8259 Virtual Wire B Mode External Interrupt request. This occurs when both the new External Interrupt and Interrupt Acknowledge for the previous External Interrupt arrive at the APIC at the same time.  	 Due to this erratum, any further 8259 Virtual Wire B Mode External Interrupts will subsequently be ignored. 	Do not use 8259 Virtual Wire B mode when using the 8259 to deliver interrupts. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Incorrectly Reports a C-State as Available When This State Is Unsupported  	  CPUID incorrectly reports a non-zero value in CPUID MONITOR/MWAIT leaf (5H) EDX [19:16] when the processor does not support an MWAIT with a target C-state EAX [7:4] > 3.  	 If an MWAIT instruction is executed with a target C-state EAX [7:4] > 3 then unpredictable system behavior may result. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Combination of a Page-Split Lock Access and Data Accesses That Are Split across Cacheline Boundaries May Lead to Processor Livelock  	  Under certain complex micro-architectural conditions, the simultaneous occurrence of a page-split lock and several data accesses that are split across cacheline boundaries may lead to processor livelock.  	 Due to this erratum, a livelock may occur that can only be terminated by a processor reset. Intel has not observed this erratum with any commercially-available software. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor Hangs on Package C6 State Exit  	  An internal timing condition in the processor power management logic will result in processor hangs upon a Package C6 state exit.  	 Due to this erratum, the processor will hang during Package C6 state exitNone identified. 	is possible for the BIOS to contain a workaround for this erratum 	  44  For the steppings affected, see the Summary Tables of Changes.   
  A Synchronous SMI May Be Delayed  	  A synchronous SMI (System Management Interrupt) occurs as a result of an SMI generating I/O Write instruction and should be handled prior to the next instruction executing. Due to this erratum, the processor may not observe the synchronous SMI prior to execution of the next instruction.  	 Due to this erratum, instructions after the I/O Write instruction, which triggered the SMI, may be allowed to execute before the SMI handler. Delayed delivery of the SMI may make it difficult for an SMI Handler to determine the source of the SMI. Software that relies on the IO_SMI bit in SMM save state or synchronous SMI behavior may not function as expected. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated after an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express Cards May Not Train to x16 Link Width  	  The Maximum Link Width field in the Link Capabilities register (LCAP; Bus 0; Device 1; Function 0; offset 0xAC; bits [9:4]) may limit the width of the PCI Express link to x8, even though the processor may actually be capable of supporting the full x16 width.  	 PCI Express x16 Graphics Cards used in normal operation and PCI Express CLB (Compliance Load Board) Cards used during PCI Express Compliance mode testing may only train to x8 link width. 	A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The APIC Timer Current Count Register May Prematurely Read 0x0 While the Timer Is Still Running  	  The APIC Timer Current Counter Register may prematurely read 0x00000000 while the timer is still running. This problem occurs when a core frequency or C-state transition occurs while the APIC timer countdown is in progress.  	 Due to this erratum, certain software may incorrectly assess that the APIC timer countdown is complete when it is actually still running. This erratum does not affect the delivery of the timer interrupt. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   45  
  IO_SMI Indication in SMRAM State Save Area May Be Lost  	  The IO_SMI bit (bit 0) in the IO state field at SMRAM offset 7FA4H is set to "1" by the processor to indicate a System Management Interrupt (SMI) is either taken immediately after a successful I/O instruction or is taken after a successful iteration of a REP I/O instruction. Due to this erratum, the setting of the IO_SMI bit may be lost. This may happen under a complex set of internal conditions with Intel® HyperThreading Technology enabled and has not been observed with commercially available software.  	 Due to this erratum, SMI handlers may not be able to identify the occurrence of I/O SMIs. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  FSW May Be Corrupted If an x87 Store Instruction Causes a Page Fault in VMX Non-Root Operation After a PD Exit  	  The X87 FSW (FPU Status Word) may be corrupted if execution of a floating-point store instruction (FST, FSTP, FIST, FISTP, FISTTP) causes a page fault in VMX non-root operation.  	 This erratum may result in unexpected behavior of software that uses x87 FPU instructions. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CKE May go Low Within tRFC(min) After a PD Exit  	  After a refresh command is issued, followed by an early PD(Power Down) Entry and Exit, the CKE (Clock Enable) signal may be asserted low prior to tRFC(min), the Minimum Refresh Cycle timing. This additional instance of CKE being low causes the processor not to meet the JEDEC DDR3 DRAM specification requirement (Section 4.17.4 Power-Down clarifications - Case 3).  	 Due to this erratum, the processor may not meet the JEDEC DDR3 DRAM specification requirement that states: “CKE cannot be registered low twice within a tRFC(min) window”. Intel has not observed any functional failure due to this erratum. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Under Certain Low Temperature Conditions, Some Uncore Performance Monitoring Events May Report Incorrect Results  	  Due to this erratum, under certain low operating temperatures, a small number of Last Level Cache and external bus performance monitoring events in the uncore report incorrect counts. This erratum may affect event codes in the ranges 00H to 0CH and 40H to 43H.  	 Due to this erratum, the count value for some uncore Performance Monitoring Events may be inaccurate. The degree of under or over counting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software. 	None identified. 	  46  For the steppings affected, see the Summary Tables of Changes.   
  VM Entry to 64-Bit Mode May Fail if Bits 48 And 47 of Guest RIP Are Different  	  VM entry to 64-bit mode should allow any value for bits [47:0] of the RIP field in the guest-state area as long as bits 63:48 are identical. Due to this erratum, such a VM entry may fail if bit 47 of the field has a value different from that of bit 48.  	 It is not possible to perform VM entry to a 64-bit guest that has made a transition to a non-canonical instruction pointer. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry Loading an Unusable SS Might Not Set SS.B to 1  	  If the unusable bit (bit 16) is 1 in the guest SS (Stack Segment) access-rights field, VM entry should set the B bit (default stack-pointer size) in the SS (stack segment) register to 1. Due to this erratum, VM entry may instead load SS.B from bit 14 of the guest SS access-rights field, potentially clearing SS.B to 0.  	 This erratum can affect software only if a far RET instruction is executed after a VM entry that erroneously clears the B bit and only if the following other three conditions are also true: (1) the SS register is not loaded between VM entry and far RET; (2) the far RET instruction is executed in 64-bit mode with an immediate operand; (3) the far RET instruction makes a transition to compatibility mode without changing CPL (Current Privilege Level). Due to the far RET being executed with an immediate operand, an adjustment is made to the stack pointer. Normally, when SS is unusable the SS.B bit is 1 and the adjustment will be to the 32-bit ESP register. Due to this erratum, the adjustment will incorrectly be made to the 16-bit SP register. Intel has not observed this erratum with any commercially available software. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Accesses to a VMCS May Not Operate Correctly If CR0.CD is Set on Any Logical Processor of a Core  	  The VMX (virtual-machine extensions) are controlled by the VMCS (virtual-machine control structure). If CR0.CD is set on any logical processor of a core, operations using the VMCS may not function correctly. Such operations include the VMREAD and VMWRITE instructions as well as VM entries and VM exits.  	 If CR0.CD is set on either logical processor in a core, the VMWRITE instruction may not correctly update the VMCS and the VMREAD instruction may not return correct data. VM entries may not load state properly and may not establish VMX controls properly. VM exits may not save or load state properly. 	VMMs (Virtual-machine monitors) should ensure that CR0.CD is clear on all logical processors of a core before entering VMX operation on any logical processor. Software should not set CR0.CD on a logical processor if any logical processor of the same core is in VMX operation. VMM software should prevent guest software from setting CR0.CD by setting bit 30 in the CR0 guest/host mask field in every VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events for Hardware Prefetches Which Miss The L1 Data Cache May be Over Counted  	  Hardware prefetches that miss the L1 data cache but cannot be processed immediately due to resource conflicts will count and then retry. This may lead to incorrectly incrementing the L1D_PREFETCH.MISS (event 4EH, umask 02H) event multiple times for a single miss.  	 The count reported by the L1D_PREFETCH.MISS event may be higher than expected.   47   	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Correctable and Uncorrectable Cache Errors May be Reported Until the First Core C6 Transition  	  On a subset of processors it is possible that correctable/uncorrectable cache errors may be logged and/or a machine check exception may occur prior to the first core C6 transition. The errors will be logged in IA32_MC5_STATUS MSR (415H) with the MCACOD (Machine Check Architecture Error Code) bits [15:0] indicating a Cache Hierarchy Error of the form 000F 0001 RRRR TTLL.  	 Due to this erratum, correctable/uncorrectable cache error may be logged or signaled. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]  	  If the “load IA32_PERF_GLOBAL_CTRL” VM-exit control is 1, a VM exit should load the IA32_PERF_GLOBAL_CTRL MSR (38FH) from the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS. Due to this erratum, such a VM exit may instead clear bits 34:32 of the MSR, loading only bits 31:0 from the VMCS.  	 All fixed-function performance counters will be disabled after an affected VM exit, even if the VM exit should have enabled them based on the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS. 	VM monitor that wants the fixed-function performance counters to be enabled after a VM exit may do one of two things: (1) clear the “load IA32_PERF_GLOBAL_CTRL” VMexit control; or (2) include an entry for the IA32_PERF_GLOBAL_CTRL MSR in the VMexit MSR-load list. 	  For the steppings affected, see the Summary Tables of Changes. 
  DTS Temperature Data May Be Incorrect On a Return From the Package C6 Low Power State  	  The DTS (Digital Thermal Sensor) temperature value may be incorrect for a small period of time (less than 2ms) after a return from the package C6 low power state.  	 The DTS temperature data (including temperatures read by Platform Environment Control Interface) may be reported lower than the actual temperature. Fan speed control or other system functions which are reliant on correct DTS temperature data may behave unpredictably. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  USB Devices May Not Function Properly With Integrated Graphics While Running Targeted Stress Graphics Workloads With NonMatching Memory Configurations  	  When the integrated graphics engine continuously generates a large stream of writes to system memory, and Intel Flex Memory Technology is enabled, with a different amount of memory in each channel, the memory arbiter may temporarily stop servicing other device-initiated traffic. In some cases this can cause certain USB devices, such as keyboard and mouse, to become unresponsive. Intel has only observed this erratum with targeted stress content. This erratum is not seen when the platform is configured with single channel or dual channel symmetric memory and is not dependent on the memory frequency.  	 Due to this erratum, certain USB devices may become unresponsive. 	None identified.  48    	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Omit Consistency Checks Related to Bit 14 (BS) of the Pending Debug Exception Field in Guest-State Area of the VMCS  	  Section “Checks on Guest Non-Register State” of Volume 3B specifies consistency checks that VM entry should perform for bit 14 (BS, indicating a pending single-step exception) of the pending debug exception field in guest-state area of the VMCS. These checks enforce the consistency of that bit with other fields in the guest-state area. Due to this erratum, VM entry may fail to perform these checks.  	 A logical processor may enter VMX non-root operation with a pending single-step debug exception that not consistent other register state; this may result in unexpected behavior. Intel has not observed this erratum with any commercially available software. 	When using VMWRITE to write to a field in the guest-state area, software should ensure that the value written is consistent with the state of other guest-state fields. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel Turbo Boost Technology Ratio Changes May Cause Unpredictable System Behavior  	  When Intel Turbo Boost Technology is enabled as determined by the TURBO_MODE_DISABLE bit being “0” in the IA32_MISC_ENABLES MSR (1A0H), the process of locking to new ratio may cause the processor to run with incorrect ratio settings. The result of this erratum may be unpredictable system behavior.  	 Due to this erratum, unpredictable system behavior may be observed. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  - 	NA	NA	NA	NA
  Execution of VMPTRLD May Corrupt Memory If Current-VMCS Pointer is Invalid  	  If the VMCLEAR instruction is executed with a pointer to the current-VMCS (virtualmachine control structure), the current-VMCS pointer becomes invalid as expected. A subsequent execution of the VMPTRLD (Load Pointer to Virtual-Machine Control Structure) instruction may erroneously overwrite the four bytes at physical address 0000008FH.  	 Due to this erratum, the four bytes in system memory at physical address 0000008FH may be corrupted. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PerfMon Overflow Status Can Not be Cleared After Certain Conditions Have Occurred  	  Under very specific timing conditions, if software tries to disable a PerfMon counter through MSR IA32_PERF_GLOBAL_CTRL (0x38F) or through the per-counter eventselect (e.g. MSR 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in MSR IA32_PERF_GLOBAL_STAT (0x38E) may be left set with no way for software to clear it.  	 Due to this erratum, software may be unable to clear the PerfMon counter overflow status indication. 	Software may avoid this erratum by clearing the PerfMon counter value prior to disabling it and then clearing the overflow status indication bit. 	  For the steppings affected, see the Summary Tables of Changes.   49  
  An Unexpected Page Fault or EPT Violation May Occur After Another Logical Processor Creates a Valid Translation for a Page  	  An unexpected page fault (#PF) or EPT violation may occur for a page under the following conditions: The paging structures initially specify no valid translation for the page. •Software on one logical processor modifies the paging structures so that there is a valid translation for the page (e.g., by setting to 1 the present bit in one of the paging-structure entries used to translate the page). •Software on another logical processor observes this modification (e.g., by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). •Shortly thereafter, software on that other logical processor performs a store to a linear address on the page. In this case, the store may cause a page fault or EPT violation that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). Intel has not observed this erratum with any commercially available software.  	 An unexpected page fault may be reported. There are no other side effects due to this erratum. 	System software can be constructed to tolerate these unexpected page faults. See Section “Propagation of Paging-Structure Changes to Multiple Processors” of Volume 3B of IA-32 Intel® Architecture Software Developer’s Manual, for recommendations for software treatment of asynchronous paging-structure updates. 	  For the steppings affected, see the Summary Tables of Changes. 
  L1 Data Cache Errors May be Logged With Level Set to 1 Instead of 0  	 When an L1 Data Cache error is logged in IA32_MCi_STATUS[15:0], which is the MCA Error Code Field, with a cache error type of the format 0000 0001 RRRR TTLL, the LL field may be incorrectly encoded as 01b instead of 00b.  	 An error in the L1 Data Cache may report the same LL value as the L2 Cache. Software should not assume that an LL value of 01b is the L2 Cache. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Executing The GETSEC Instruction While Throttling May Result in a Processor Hang  	  If the processor throttles due to either high temperature thermal conditions or due to an explicit operating system throttling request (TT1) while executing GETSEC[SENTER] or GETSEC[SEXIT] instructions, then under certain circumstances, the processor may hang. Intel has not been observed this erratum with any commercially available software.  	 Possible hang during execution of GETSEC instruction. 	None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PerfMon Event LOAD_HIT_PRE.SW_PREFETCH May Overcount  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH (event 4CH, umask 01H) should count load instructions hitting an ongoing software cache fill request initiated by a preceding  50    software prefetch instruction. Due to this erratum, this event may also count when there is a preceding ongoing cache fill request initiated by a locking instruction. 	 PerfMon event LOAD_HIT_PRE.SW_PREFETCH may overcount. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	 Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used. 	Software can avoid this by: 1. Avoid using Freeze PerfMon on PMI bit 2. Enable only one fixed counter at a time when using Freeze PerfMon on PMI 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions  	  When a 2-byte opcode of a conditional branch (opcodes 0F8xH, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid VEX prefix, it may sometimes signal a #GP fault (illegal instruction length > 15-bytes) instead of a #UD (illegal opcode) fault.  	 Due to this erratum, #GP fault instead of a #UD may be signaled on an illegal instruction. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Logical Processor May Wake From Shutdown State When BranchTrace Messages or Branch-Trace Stores Are Enabled  	  Normally, a logical processor that entered the shutdown state will remain in that state until a break event (NMI, SMI, INIT) occurs. Due to this erratum, if CR4.MCE (Machine Check Enable) is 0 and a branch-trace message or branch-trace store is pending at the time of a machine check, the processor may not remain in shutdown state. In addition, if the processor was in VMX non-root operation when it improperly woke from shutdown state, a subsequent VM exit may save a value of 2 into the activity-state field in the VMCS (indicating shutdown) even though the VM exit did not occur while in shutdown state.  	 This erratum may result in unexpected system behavior. If a VM exit saved a value of 2 into the activity-state field in the VMCS, the next VM entry will take the processor to shutdown state. 	Software should ensure that CR4.MCE is set whenever IA32_DEBUGCTL MSR (60EH) TR bit [6] is set. 	  For the steppings affected, see the Summary Tables of Changes.   51  
  Task Switch to a TSS With an Inaccessible LDTR Descriptor May Cause Unexpected Faults  	  A task switch may load the LDTR (Local Descriptor Table Register) with an incorrect segment descriptor if the LDT (Local Descriptor Table) segment selector in the new TSS specifies an inaccessible location in the GDT (Global Descriptor Table).  	 Future accesses to the LDT may result in unpredictable system behavior. 	Operating system code should ensure that segment selectors used during task switches to the GDT specify offsets within the limit of the GDT and that the GDT is fully paged into memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCIP Bit Not Checked on SENTER or ENTERACCS  	 When an ILP (Initiating Logical Processor) executes GETSEC with either the SENTER or ENTERACCS leaf function, the processor should check the MCIP (Machine Check In Progress) bit in the IA32_MCG_STATUS MSR (17AH) to determine if any machine check exception is being processed. If a machine check is in progress the ILP should generate a general protection exception. Due to this erratum, the general protection exception is not generated.  	 If GETSEC is executed with either the SENTER or ENTERACCS leaf function, and a machine check exception is being processed, ILP will enter an authenticated execution mode instead of generating a general protection exception. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EOI-Broadcast Suppression May Not Function Properly if Enabled or Disabled While an Interrupt is in Service  	  If a processor supports EOI-broadcast suppression, a write to the local APIC’s EOI register does not generate a broadcast EOI (even if the interrupt is level-triggered) if bit 12of the local APIC’s SVR (Spurious-Interrupt Vector Register) is set at the time of the write. Due to this erratum, the local APIC decides whether to generate a broadcast EOI based on the value that bit 12 of the SVR had at the time at which the most recent interrupt was delivered or the time of the most recent write to the EOI register (whichever is later).  	 If software modifies bit 12 of SVR while servicing an interrupt, the next write to the EOI register may not use the new bit value. 	Software should not modify bit 12 of SVR while servicing a level-triggered interrupt. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected Load May Occur on Execution of Certain Opcodes  	  If software executes an instruction with an opcode of the form 66 0F 38 8x (where x is in therange 0 to 6), the processor may unexpectedly perform a load operation (the data loaded is not used). The load occurs even if the instruction causes a VM exit or a fault (including an invalid-opcode exception). If the VMXON instruction has been executed successfully, the load is from the physical address in the VMXON pointer plus 408H;otherwise, it is from physical address 407H. The affected opcodes include the INVEPT and INVVPID instructions as well as five invalid opcodes.  	 This erratum may cause incorrect side effects if the load accesses a memory-mapped I/ O device. Intel has not observed this erratum with any commercially available system. 	It is possible for the BIOS to contain a workaround for this erratum. 	  52  For the steppings affected, see the Summary Tables of Changes.   
  VM Entry Loading an Unusable SS Might Not Clear Bits 3:0 of the SS Base Address  	  If the unusable bit (bit 16) is 1 in the guest SS access-rights field, VM entry should clear bits 3:0 of the base address of the SS register. Due to this erratum, VM entry may instead load these bits from the guest SS base-address field, leaving them with a nonzero value.  	 Following a VM entry affected by this erratum, the exception caused by an SSE access through SS outside 64-bit mode may use the wrong exception vector (#GP instead of #SS or vice versa, dependent on the linear address being aligned or misaligned). Intel has not observed this erratum with any commercially available software. 	It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A First Level Data Cache Parity Error May Result in Unexpected Behavior  	  A First Level Data Cache PWhen a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior. rity Error May Result in Unexpected Behavior  	 Due to this erratum unpredictable system behavior may occur. Intel has not observed this erratum with any commercially available system. 	None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1”. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Unexpected Page Fault or EPT Violation May Occur After Another Logical Processor Creates a Valid Translation for a Page  	  An unexpected page fault (#PF) or EPT violation may occur for a page under the following conditions: • The paging structures initially specify no valid translation for the page. • Software on one logical processor modifies the paging structures so that there is a valid translation for the page (e.g., by setting to 1 the present bit in one of the paging-structure entries used to translate the page). • Software on another logical processor observes this modification (e.g., by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). • Shortly thereafter, software on that other logical processor performs a store to a linear address on the page. In this case, the store may cause a page fault or EPT violation that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code,   53   indicating that the fault was caused by a not-present page). Intel has not observed this erratum with any commercially available software. 	 An unexpected page fault may be reported. There are no other side effects due to this erratum. 	System software can be constructed to tolerate these unexpected page faults. See Section “Propagation of Paging-Structure Changes to Multiple Processors” of Volume 3A of IA-32 Intel® Architecture Software Developer’s Manual, for recommendations for software treatment of asynchronous paging-structure updates. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® Trusted Execution Technology ACM Revocation  	  SINIT ACM i7_QUAD_SINIT_20.BIN or earlier are revoked and will not launch with new processor configuration information.  	 Due to this erratum, SINIT ACM i7_QUAD_SINIT_20.BIN and earlier will be revoked. 	It is possible for the BIOS to contain a workaround for this erratum. All Intel® TXT enabled software must use SINIT ACM i7_QUAD_SINIT_51.BIN or later. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® Processor Graphics VT-d IOTLB Invalidation Operation May Fail to Complete  	  Intel® Processor Graphics IOTLB (Input Output Translation Look-aside Buffer) invalidation operation submitted through IVT (Invalidate IOTLB) bit 63 of the IOTLB_REG (GFXVTBAR offset 0x108) register on the Intel VT-d (Intel Virtualization Technology for Directed I/O) engine may fail to complete if there are ongoing translations active in the graphics device command streamer. As a result of the failed operation the VT-d software could remain indefinitely in a polling loop waiting for the IVT bit to become clear.  	 Due to this erratum, the VT-d software may continuously execute code in a polling loop causing the system software to hang. 	This erratum can be avoided by software supporting VT-d ensuring that the graphics command streamer is idle as a precondition for IOTLB invalidations affecting Intel Processor Graphics. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	 The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged. 	None identified. 	NA
  EFLAGS Discrepancy on a Page Fault after a Multiprocessor TLB Shootdown  	  This erratum may occur when the processor executes one of the following readmodify-write arithmetic instructions and a page fault occurs during the store of the memory operand: ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD. In this case, the EFLAGS value pushed onto the stack of the page fault handler may reflect the status of the register after the instruction would have completed execution rather than before it. The following conditions are required for the store to generate a page fault and call the operating system page fault handler: 1.  The store address entry must be evicted from the DTLB by speculative loads from other instructions that hit the same way of the DTLB before the store has completed. DTLB eviction requires at least three-load operations that have linear address bits 15:12 equal to each other and address bits 31:16 different from each other in close physical proximity to the arithmetic operation.  2.  The page table entry for the store address must have its permissions tightened during the very small window of time between the DTLB eviction and execution of the store. Examples of page permission tightening include from Present to Not Present or from Read/Write to Read Only, etc.  3.  Another processor, without corresponding synchronization and TLB flush, must cause the permission change.  	 This scenario may only occur on a multiprocessor platform running an operating system that performs “lazy” TLB shootdowns. The memory image of the EFLAGS register on the page fault handler's stack prematurely contains the final arithmetic flag values although the instruction has not yet completed. Intel has not identified any operating systems that inspect the arithmetic portion of the EFLAGS register during a page fault nor observed this erratum in laboratory testing of software applications. 	 No workaround is needed upon normal restart of the instruction, since this erratum is transparent to the faulting code and results in correct instruction behavior. Operating systems may ensure that no processor is currently accessing a page that is scheduled to have its page permissions tightened or have a page fault handler that ignores any incorrect state. 	  For the steppings affected, see the Summary Tables of Changes.   17  
  INVLPG Operation for Large (2M/4M) Pages May Be Incomplete under Certain Conditions  	  The INVLPG instruction may not completely invalidate Translation Look-aside Buffer (TLB) entries for large pages (2M/4M) when both of the following conditions exist: “Address range of the page being invalidated spans several Memory Type Range Registers (MTRRs) with different memory types specified (INVLPG operation is preceded by a Page Assist Event (Page Fault (#PF) or an access that results in either A or D bits being set in a Page Table Entry (PTE))  	 Stale translations may remain valid in TLB after a PTE update resulting in unpredictable system behavior. Intel has not observed this erratum with any commercially-available software. 	 Software should ensure that the memory type specified in the MTRRs is the same for the entire address range of the large page. 	  For the steppings affected, see the Summary Tables of Changes. 
  Store to WT Memory Data May Be Seen in Wrong Order by Two, Subsequent Loads  	  When data of Store to WT memory is used by two, subsequent loads of one thread, and another thread performs cacheable write to the same address, the first load may get the data from external memory or L2 written by another core, while the second load will get the data straight from the WT Store.  	 Software that uses WB to WT memory aliasing may violate proper store ordering. 	 Do not use WB to WT aliasing. 	  For the steppings affected, see the Summary Tables of Changes. 
  Non-Temporal Data Store May Be Observed in Wrong Program Order  	  When non-temporal data is accessed by multiple read operations in one thread while another thread performs a cacheable write operation to the same address, the data stored may be observed in wrong program order (i.e., later load operations may read older data).  	 Software that uses non-temporal data without proper serialization before accessing the non-temporal data may observe data in wrong program order. 	 Software that conforms to the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, “Buffering of Write Combining Memory Locations” section will operate correctly. 	  18  For the steppings affected, see the Summary Tables of Changes.   
  Page Access Bit May Be Set Prior to Signaling a Code Segment Limit Fault  	  If code segment limit is set close to the end of a code page, then due to this erratum the memory page Access bit (A bit) may be set for the subsequent page prior to general protection fault on code segment limit.  	 When this erratum occurs, a non-accessed page which is present in memory and follows a page that contains the code segment limit may be tagged as accessed. 	 Erratum can be avoided by placing a guard page (non-present or non-executable page) as the last page of the segment or after the page that includes the code segment limit. 	  For the steppings affected, see the Summary Tables of Changes. 
  Updating Code Page Directory Attributes without TLB Invalidation May Result in Improper Handling of Code #PF  	  Code #PF (Page Fault exception) is normally handled in lower priority order relative to both code #DB (Debug Exception) and code Segment Limit Violation #GP (General Protection Fault). Due to this erratum, code #PF may be handled incorrectly, if all of the following conditions are met:  	 A PDE (Page Directory Entry) is modified without invalidating the corresponding TLB (Translation Look-aside Buffer) entry. 1.  Code execution transitions to a different code page such that both  2.  The target linear address corresponds to the modified PDE  3.  The PTE (Page Table Entry) for the target linear address has an A (Accessed) bit that is clear  4.  One of the following simultaneous exception conditions is present following the code transition  5.  Code #DB and code #PF  6.  Code Segment Limit Violation #GP and code #PF  7.  Software may observe either incorrect processing of code #PF before code Segment Limit Violation #GP or processing of code #PF in lieu of code #DB.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   19  
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	 When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ technology instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX technology transition may not be counted.  	 The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially-available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A REP STOS/MOVS to a MONITOR/MWAIT Address Range May Prevent Triggering of the Monitoring Hardware  	  The MONITOR instruction is used to arm the address monitoring hardware for the subsequent MWAIT instruction. The hardware is triggered on subsequent memory store operations to the monitored address range. Due to this erratum, REP STOS/MOVS fast string operations to the monitored address range may prevent the actual triggering store to be propagated to the monitoring hardware.  	 A logical processor executing an MWAIT instruction may not immediately continue program execution if a REP STOS/MOVS targets the monitored address range. 	 Software can avoid this erratum by not using REP STOS/MOVS store operations within the monitored address range. 	  20  For the steppings affected, see the Summary Tables of Changes.   
  Performance Monitoring Event MISALIGN_MEM_REF May Over Count  	  Performance monitoring event MISALIGN_MEM_REF (05H) is used to count the number of memory accesses that cross an 8-byte boundary and are blocked until retirement. Due to this erratum, the performance monitoring event MISALIGN_MEM_REF also counts other memory accesses.  	 The performance monitoring event MISALIGN_MEM_REF may over count. The extent of the over counting depends on the number of memory accesses retiring while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially-available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit Violation May Occur on 4-GB Limit Check  	  Code Segment limit violation may occur on 4-GB limit check when the code stream wraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0 x 0.  	 This is a rare condition that may result in a system hang. Intel has not observed this erratum with any commercially-available software, or system. 	 Avoid code that wraps around segment limit. 	  For the steppings affected, see the Summary Tables of Changes.   21  
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memorybased APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, e.g., CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Last Branch Records (LBR) Updates May Be Incorrect after a Task Switch  	  A Task-State Segment (TSS) task switch may incorrectly set the LBR_FROM value to the LBR_TO value.  	 The LBR_FROM will have the incorrect address of the Branch Instruction. 	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.   
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions, as described in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A section “Out-of-Order Stores for String Operations in Pentium 4, Intel Xeon, and P6 Family Processors,” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum, fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation. 	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Upper 32 bits of “From” Address Reported through BTMs or BTSs May Be Incorrect  	  When a far transfer switches the processor from 32-bit mode to IA-32e mode, the upper 32 bits of the “From” (source) addresses reported through the BTMs (Branch Trace Messages) or BTSs (Branch Trace Stores) may be incorrect.  	 The upper 32 bits of the 'From' address debug information reported through BTMs or BTSs may be incorrect during this transition. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23  
  Address Reported by Machine-Check Architecture (MCA) on Single-bit L2 ECC Errors May Be Incorrect  	  When correctable Single-bit ECC errors occur in the L2 cache, the address is logged in the MCA address register (MCi_ADDR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in MCi_ADDR, for single-bit L2 ECC errors. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May Be Serviced before Higher Priority Interrupts/Exceptions  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g., NMI (Non-Maskable Interrupt), Debug break (#DB), Machine Check (#MC), etc.)  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commerciallyavailable software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Store Ordering May Be Incorrect between WC and WP Memory Type  	  According to Intel® 64 and IA-32 Intel Architecture Software Developer's Manual, Volume 3A “Methods of Caching Available,” WP (Write Protected) stores should drain the WC (Write Combining) buffers in the same way as UC (Uncacheable) memory type stores do. Due to this erratum, WP stores may not drain the WC buffers.  	 Memory ordering may be violated between WC and WP stores. 	 None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.   
  EFLAGS, CR0, CR4 and the EXF4 Signal May Be Incorrect after Shutdown  	  When the processor is going into shutdown due to an RSM inconsistency failure, EFLAGS, CR0 and CR4 may be incorrect. In addition the EXF4 signal may still be asserted. This may be observed if the processor is taken out of shutdown by NMI#.  	 A processor that has been taken out of shutdown may have an incorrect EFLAGS, CR0 and CR4. In addition the EXF4 signal may still be asserted. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered: • If an instruction that performs a memory load causes a code segment limit violation. • If a waiting X87 floating-point (FP) instruction or MMX technology (MMX) instruction that performs a memory load has a floating-point exception pending. • If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Top-of-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	 In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side-effect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception. 	 Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes.   25  
  Performance Monitoring Events for Retired Instructions (C0H) May Not Be Accurate  	  The INST_RETIRED performance monitor may miscount retired instructions as follows: • Repeat string and repeat I/O operations are not counted when a hardware interrupt is received during or after the last iteration of the repeat flow. • VMLAUNCH and VMRESUME instructions are not counted. • HLT and MWAIT instructions are not counted. The following instructions, if executed during HLT or MWAIT events, are also not counted: a) RSM from a C-state SMI during an MWAIT instruction. b) RSM from an SMI during a HLT instruction.  	 There may be a smaller than expected value in the INST_RETIRED performance monitoring counter. The extent to which this value is smaller than expected is determined by the frequency of the above cases. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commerciallyavailable software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  For the steppings affected, see the Summary Tables of Changes. 
  CMPSB, LODSB, or SCASB in 64-bit Mode with Count Greater or Equal to 248 May Terminate Early  	  In 64-bit Mode CMPSB, LODSB, or SCASB executed with a repeat prefix and count greater than or equal to 248 may terminate early. Early termination may result in one of the following. • The last iteration not being executed • Signaling of a canonical limit fault (#GP) on the last iteration  	 While in 64-bit mode, with count greater or equal to 248, repeat string operations CMPSB, LODSB or SCASB may terminate without completing the last iteration. Intel has not observed this erratum with any commercially-available software. 	 Do not use repeated string operations with RCX greater than or equal to 248. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  Writing the Local Vector Table (LVT) When an Interrupt Is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are serviced immediately after the STI instruction is executed. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep® Technology transitions or Thermal Monitor 1 events occur, the pending #MF may be serviced before higher priority interrupts. Software may observe #MF being serviced before higher priority interrupts.  	NA	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VERW/VERR/LSL/LAR Instructions May Unexpectedly Update the Last Exception Record (LER) MSR  	  The LER MSR may be unexpectedly updated, if the resultant value of the Zero Flag (ZF) is zero after executing the following instructions: 1.  VERR (ZF=0 indicates unsuccessful segment read verification)  2.  VERW (ZF=0 indicates unsuccessful segment write verification)  3.  LAR (ZF=0 indicates unsuccessful access rights load)  4.  LSL (ZF=0 indicates unsuccessful segment limit load)  	 The value of the LER MSR may be inaccurate if VERW/VERR/LSL/LAR instructions are executed after the occurrence of an exception. 	 Software exception handlers that rely on the LER MSR value should read the LER MSR before executing VERW/VERR/LSL/LAR instructions. 	  For the steppings affected, see the Summary Tables of Changes.   27  
  INIT Does Not Clear Global Entries in the TLB  	  INIT may not flush a TLB entry when: • The processor is in protected mode with paging enabled and the page global enable flag is set (PGE bit of CR4 register). • G bit for the page table entry is set. • TLB entry is present in TLB when INIT occurs. • Software may encounter unexpected page fault or incorrect address translation due to a TLB entry erroneously left in TLB after INIT.  	NA	 Write to CR3, CR4 (setting bits PSE, PGE or PAE) or CR0 (setting bits PG or PE) registers before writing to memory early in BIOS code to clear all the global entries from TLB. 	  For the steppings affected, see the Summary Tables of Changes. 
  Split Locked Stores May Not Trigger the Monitoring Hardware  	  Logical processors normally resume program execution following the MWAIT, when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation. Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store that spans across cache lines within the monitored address range.  	 The logical processor that executed the MWAIT instruction may not resume execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is split across cache lines. 	 Do not use locked stores that span cache lines in the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  28  For the steppings affected, see the Summary Tables of Changes.   
  Writing Shared Unaligned Data that Crosses a Cache Line without Proper Semaphores or Barriers May Expose a Memory Ordering Issue  	  Software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory ordering issue if multiple loads access this shared data shortly thereafter. Exposure to this problem requires the use of a data write which spans a cache line boundary.  	 This erratum may cause loads to be observed out of order. Intel has not observed this erratum with any commercially-available software or system. 	 Software should ensure at least one of the following is true when modifying shared data by multiple agents: • The shared data is aligned • Proper semaphores or barriers are used in order to prevent concurrent data accesses. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4-G limit (0ffffffffh) may not signal a #GP fault.  	 When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault. 	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4-G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  An Asynchronous MCE during a Far Transfer May Corrupt ESP  	  If an asynchronous machine check occurs during an interrupt, call through gate, FAR RET or IRET and in the presence of certain internal conditions, ESP may be corrupted.  	 If the MCE (Machine Check Exception) handler is called without a stack switch, then a triple fault will occur due to the corrupted stack pointer, resulting in a processor shutdown. If the MCE is called with a stack switch, e.g., when the CPL (Current Privilege Level) was changed or when going through an interrupt task gate, then the corrupted ESP will be saved on the new stack or in the TSS (Task State Segment), and will not be used. 	 Use an interrupt task gate for the machine check handler. 	  For the steppings affected, see the Summary Tables of Changes.   29  
  CPUID Reports Architectural Performance Monitoring Version 2 Is Supported, When Only Version 1 Capabilities Are Available  	  CPUID leaf 0Ah reports the architectural performance monitoring version that is available in EAX[7:0]. Due to this erratum CPUID reports the supported version as 2 instead of 1.  	 Software will observe an incorrect version number in CPUID.0Ah.EAX [7:0] in comparison to which features are actually supported. 	 Software should use the recommended enumeration mechanism described in the Architectural Performance Monitoring section of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3: System Programming Guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 May Not Be Properly Cleared after Code Breakpoint  	  B0-B3 bits (breakpoint conditions detect flags, Bits [3:0]) in DR6 may not be properly cleared when the following sequence happens: 1.  POP instruction to SS (Stack Segment) selector;  2.  Next instruction is FP (Floating Point) that gets FP assist followed by code breakpoint.  	 B0-B3 bits in DR6 may not be properly cleared. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An xTPR Update Transaction Cycle, If Enabled, May Be Issued to the FSB after the Processor Has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	 BIOS must leave the xTPR update transactions disabled (default). 	  30  For the steppings affected, see the Summary Tables of Changes.   
  Performance Monitoring Event IA32_FIXED_CTR2 May Not Function Properly When Max Ratio Is a Non-Integer Core-to-Bus Ratio  	  Performance Counter IA32_FIXED_CTR2 (MSR 30BH) event counts CPU reference clocks when the core is not in a halt state. This event is not affected by core frequency changes (e.g., P states, TM2 transitions) but counts at the same frequency as the Time-Stamp Counter IA32_TIME_STAMP_COUNTER (MSR 10H). Due to this erratum, the IA32_FIXED_CTR2 will not function properly when the non-integer core-to-bus ratio multiplier feature is used and when a non-zero value is written to IA32_ FIXED_CTR2. Non-integer core-to-bus ratio enables additional operating frequencies. This feature can be detected by IA32_PLATFORM_ID (MSR 17H) bit [23].  	 The Performance Monitoring Event IA32_FIXED_CTR2 may result in an inaccurate count when the non-integer core-to-bus multiplier feature is used. 	 If writing to IA32_FIXED_CTR2 and using a non-integer core-to-bus ratio multiplier, always write a zero. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause a Livelock during Snoops of the L1 Data Cache  	  A livelock may be observed in rare conditions when instruction fetch causes multiple level one data cache snoops.  	 Due to this erratum, a livelock may occur. Intel has not observed this erratum with any commercially-available software. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   31  
  Use of Memory Aliasing with Inconsistent Memory Type May Cause a System Hang or a Machine Check Exception  	  Software that implements memory aliasing by having more than one, linear address mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (MCE). This would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. If the cacheable address finds its way into the instruction cache, and the non-cacheable address is fetched in the IFU, the processor may invalidate the noncacheable address from the fetch unit. Any micro-architectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and lack of it will cause a system hang or an MCE.  	 This erratum has not been observed with commercially-available software. 	 Although it is possible to have a single physical page mapped by two different linear addresses with different memory types, Intel has strongly discouraged this practice as it may lead to undefined results. Software that needs to implement memory aliasing should manage the memory type consistency. 	  For the steppings affected, see the Summary Tables of Changes. 
  A WB Store Following a REP STOS/MOVS or FXSAVE May Lead to Memory-Ordering Violations  	  Under certain conditions, as described in the section titled section “Out-of-Order Stores for String Operations in Pentium 4, Intel Xeon, and P6 Family Processors,” from the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A: System Programming Guide, the processor may perform REP MOVS or REP STOS as write combining stores (referred to as “fast strings”) for optimal performance. FXSAVE may also be internally implemented using write combining stores. Due to this erratum, stores of a WB (write back) memory type to a cache line previously written by a preceding fast string/FXSAVE instruction may be observed before string/FXSAVE stores.  	 A write-back store may be observed before a previous string or FXSAVE related store. Intel has not observed this erratum with any commercially-available software. 	 Software desiring strict ordering of string/FXSAVE operations relative to subsequent write-back stores should add an MFENCE or SFENCE instruction between the string/ FXSAVE operation and following store-order sensitive code such as that used for synchronization. 	  32  For the steppings affected, see the Summary Tables of Changes.   
  VM Exit with Exit Reason “TPR below Threshold” Can Cause the Blocking by MOV/POP SS and Blocking by STI Bits to Be Cleared in the Guest Interruptibility-State Field  	  As specified in Section, “VM Exits Induced by the TPR Shadow”, in the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3B, a VM exit occurs immediately after any VM entry performed with the “use TPR shadow”, “activate secondary controls”, and “virtualize APIC accesses” VM-execution controls all set to 1 and with the value of the TPR shadow (bits 7:4 in byte 80H of the virtual-APIC page) less than the TPR-threshold VM-execution control field. Due to this erratum, such a VM exit will clear bit 0 (blocking by STI) and bit 1 (blocking by MOV/POP SS) of the interruptibility-state field of the guest-state area of the VMCS (Bit 0 - blocking by STI and bit 1 - blocking by MOV/POP SS should be left unmodified).  	 Since the STI, MOV SS, and POP SS instructions cannot modify the TPR shadow, bits 1:0 of the interruptibility-state field will usually be zero before any VM entry meeting the preconditions of this erratum; behavior is correct in this case. However, if VMM software raises the value of the TPR-threshold VM-execution control field above that of the TPR shadow while either of those bits is 1, incorrect behavior may result. This may lead to VMM software prematurely injecting an interrupt into a guest. Intel has not observed this erratum with any commercially-available software. 	 VMM software raising the value of the TPR-threshold VM-execution control field should compare it to the TPR shadow. If the threshold value is higher, software should not perform a VM entry; instead, it could perform the actions that it would normally take in response to a VM exit with exit reason “TPR below threshold”. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using Memory Type Aliasing with Cacheable and WC Memory Types May Lead to Memory Ordering Violations  	  Memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory types. Memory type aliasing with a cacheable memory type and WC (write combining) may cause the processor to perform incorrect operations leading to memory ordering violations for WC operations.  	 Software that uses aliasing between cacheable and WC memory types may observe memory ordering errors within WC memory operations. Intel has not observed this erratum with any commercially-available software. 	 None identified. Intel does not support the use of cacheable and WC memory type aliasing, and WC operations are defined as weakly ordered. 	  For the steppings affected, see the Summary Tables of Changes.   33  
  VM Exit Caused by a SIPI Results in Zero Being Saved to the Guest RIP Field in the VMCS  	  If a logical processor is in VMX non-root operation and in the wait-for-SIPI state, an occurrence of a start-up IPI (SIPI) causes a VM exit. Due to this erratum, such VM exits always save zero into the RIP field of the guest-state area of the virtual-machine control structure (VMCS) instead of the value of RIP before the SIPI was received.  	 In the absence of virtualization, a SIPI received by a logical processor in the wait-forSIPI state results in the logical processor starting execution from the vector sent in the SIPI regardless of the value of RIP before the SIPI was received. A virtualmachine monitor (VMM) responding to a SIPI-induced VM exit can emulate this behavior because the SIPI vector is saved in the lower 8 bits of the exit qualification field in the VMCS. Such a VMM should be unaffected by this erratum. A VMM that does not emulate this behavior may need to recover the old value of RIP through alternative means. Intel has not observed this erratum with any commerciallyavailable software. 	 VMM software that may respond to SIPI-induced VM exits by resuming the interrupt guest context without emulating the non-virtualized SIPI response should: 1.  Save from the VMCS (using VMREAD) the value of RIP before any VM entry to the wait-for SIPI state.  2.  Restore to the VMCS (using VMWRITE) that value before the next VM entry that resumes the guest in any state other than wait-for-SIPI.  	  For the steppings affected, see the Summary Tables of Changes. 
  NMIs May Not Be Blocked by a VM-Entry Failure  	  The Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3B: System Programming Guide, Part 2 specifies that, following a VM-entry failure during or after loading guest state, “the state of blocking by NMI is what it was before VM entry.” If non-maskable interrupts (NMIs) are blocked and the “virtual NMIs” VMexecution control set to 1, this erratum may result in NMIs not being blocked after a VM-entry failure during or after loading guest state.  	 VM-entry failures that cause NMIs to become unblocked may cause the processor to deliver an NMI to software that is not prepared for it. 	 VMM software should configure the virtual-machine control structure (VMCS) so that VM-entry failures do not occur. 	  34  For the steppings affected, see the Summary Tables of Changes.   
  Partial Streaming Load Instruction Sequence May Cause the Processor to Hang  	  Under some rare conditions, when multiple streaming load instructions (MOVNTDQA) are mixed with non-streaming loads that split across cache lines, the processor may hang.  	 Under the scenario described above, the processor may hang. Intel has not observed this erratum with any commercially-available software. 	 It is possible for the BIOS to contain a workaround for this erratum. However, streaming behavior may be re-enabled by setting Bit 5 to Bit 1 of the MSR at address 0 x 21 for software development or testing purposes. If this bit is changed, then a read-modify-write should be performed to preserve other bits of this MSR. When the streaming behavior is enabled and using streaming load instructions, always consume a full cache line worth of data and/or avoid mixing them with non-streaming memory references. If streaming loads are used to read partial cache lines, and mixed with non-streaming memory references, use fences to isolate the streaming load operations from non-streaming memory operations. 	  For the steppings affected, see the Summary Tables of Changes. 
  Self/Cross Modifying Code May Not Be Detected or May Cause a Machine Check Exception  	  If instructions from at least three different ways in the same instruction cache set exist in the pipeline combined with some rare internal state, self-modifying code (SMC) or cross-modifying code may not be detected and/or handled.  	 An instruction that should be overwritten by another instruction while in the processor pipeline may not be detected/modified, and could retire without detection. Alternatively the instruction may cause a Machine Check Exception. Intel has not observed this erratum with any commercially-available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Data TLB Eviction Condition in the Middle of a Cacheline Split Load Operation May Cause the Processor to Hang  	  If the TLB translation gets evicted while completing a cacheline split load operation, under rare scenarios the processor may hang.  	 The cacheline split load operation may not be able to complete normally, and the machine may hang and generate Machine Check Exception. Intel has not observed this erratum with any commercially-available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   35  
  Update of Read/Write (R/W) or User/Supervisor (U/S) or Present (P) Bits without TLB Shootdown May Cause Unexpected Processor Behavior  	  Updating a page table entry by changing R/W, U/S or P bits, even when transitioning these bits from 0 to 1, without keeping the affected linear address range coherent with all TLB (Translation Lookaside Buffers) and paging-structures caches in the processor, in conjunction with a complex sequence of internal processor microarchitectural events and store operations, may lead to unexpected processor behavior.  	 This erratum may lead to livelock, shutdown or other unexpected processor behavior. Intel has not observed this erratum with any commercially-available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  RSM Instruction Execution under Certain Conditions May Cause Processor Hang or Unexpected Instruction Execution Results  	  RSM instruction execution, under certain conditions triggered by a complex sequence of internal processor micro-architectural events, may lead to processor hang, or unexpected instruction execution results.  	 In the above sequence, the processor may live lock or hang, or RSM instruction may restart the interrupted processor context through a nondeterministic EIP offset in the code segment, resulting in unexpected instruction execution, unexpected exceptions or system hang. Intel has not observed this erratum with any commercially-available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, “Exception and Interrupt Reference,” if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However, Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially-available software. 	 None identified. 	  36  For the steppings affected, see the Summary Tables of Changes.   
  LER MSRs May Be Incorrectly Updated  	  The LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH) may contain incorrect values after any of the following: • Either STPCLK#, NMI (NonMaskable Interrupt) or external interrupts • CMP or TEST instructions with an uncacheable memory operand followed by a conditional jump • STI/POP SS/MOV SS instructions followed by CMP or TEST instructions and then by a conditional jump  	 When the conditions for this erratum occur, the value of the LER MSRs may be incorrectly updated. 	 None identified 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Unexpectedly Assert False THERMTRIP# after Receiving a Warm Reset  	  Some processors may unexpectedly assert a false THERMTRIP# after a warm reset under certain environmental and operating conditions. Intel has observed this on a limited number of parts when they are operating at a core-to-bus ratio different from the ratio used at power-on. The issue is due to a thermal sensor circuit timing marginality event that causes the sensor to initiate a thermal shutdown. Under these conditions, upon RESET# assertion, some processors may assert a false THERMTRIP# even though their temperature is below normal THERMTRIP# activation temperature. A warm reset is different from a cold/power-on reset in that PWRGOOD remains active throughout the assertion of RESET#.  	 This issue may be observed during warm reset cycle testing or during the process of repeatedly entering and exiting the S3/S4/S5 sleep states. When this issue occurs, the processor may proceed with a thermal shutdown signaled by the assertion of processor THERMTRIP# and the platform will remove power from the CPU or the entire platform. 	 A BIOS update can be implemented to address this erratum. Note: This workaround does not cover all system configurations where warm resets are initiated by Intel® AMT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Short Nested Loops That Span Multiple 16-Byte Boundaries May Cause a Machine Check Exception or a System Hang  	  Under a rare set of timing conditions and address alignment of instructions in a short nested loop sequence, software that contains multiple conditional jump instructions and spans multiple 16-byte boundaries, may cause a machine check exception or a system hang.  	 Due to this erratum, a machine check exception or a system hang may occur.   37   	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  38  For the steppings affected, see the Summary Tables of Changes.   
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None identified. 	NA
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit-23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	 BIOS must leave the xTPR update transactions disabled (default). 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Report a #TS Instead of a #GP Fault  	  During system reset, there is insufficient time for handshake between ICH and GMCH LVDS logic. As a result, timing from panel backlight enable going low to LVDS data going low (TX) and timing from LVDS data going low to panel VCC enable going low (T3) do not match the programmed values. Panel backlight enable (LBKLT_EN), panel Vcc enable (LVDD_EN) and LVDS data lines go low at the same time.  	 A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception). 	 None. 	  14  For the steppings affected, see the Summary Tables of Changes.   
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector is left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI; therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception is generated instead of the expected general-protection fault. 	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes.   15  
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, for example CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit-20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit-20 may not be masked. • paging is enabled • a linear address has bit-20 set • the address references a large page • A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system. 	 Operating systems should not allow A20M# to be enabled if the masking of address bit-20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  16  For the steppings affected, see the Summary Tables of Changes.   
  Value for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. 	 None. 	  For the steppings affected, see the Summary Tables of Changes.   17  
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  For the steppings affected, see the Summary Tables of Changes. 
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the value of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Value on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected value (i.e. residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software. 	 None. 	  18  For the steppings affected, see the Summary Tables of Changes.   
  With TF (Trap Flag) Asserted, FP Instruction That Triggers an Unmasked FP Exception May Take Single Step Trap before Retirement of Instruction  	  If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  	 A Single Step trap is taken when not expected. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   19  
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (for example NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  BTS(Branch Trace Store) and PEBS(Precise Event Based Sampling) May Update Memory outside the BTS/PEBS Buffer  	  If the BTS/PEBS buffer is defined such that: • The difference between BTS/PEBS buffer base and BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes • BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space • The record that would cross BTS/PEBS absolute maximum will also continue past the end of the virtual address space A BTS/PEBS record can be written that will wrap at the 4G boundary (IA32) or 264 boundary (EM64T mode), and write memory outside of the BTS/PEBS buffer. 64  	 Software that uses BTS/PEBS near the 4G boundary (IA32) or 2 boundary (EM64T mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the BTS/PEBS buffer. 	 Define BTS/PEBS buffer such that BTS/PEBS absolute maximum minus BTS/PEBS buffer base is integer multiple of the corresponding record sizes as recommended in the IA-32 Intel® Architecture Software Developer’s Manual, Volume 3. 	  20  For the steppings affected, see the Summary Tables of Changes.   
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB is incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel Architecture Software Developer's Manual Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel Architecture Software Developer's Manual Volume 3A: System Programming Guide, Section: Handling Self- and Cross-Modifying Code. 	  For the steppings affected, see the Summary Tables of Changes.   21  
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1”. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: • A SMI that is pending while a lower priority event is executing • A REP I/O read • A I/O read that redirects to MWAIT  	 SMM handlers may get false IO_SMI indication. 	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software. 	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  22  For the steppings affected, see the Summary Tables of Changes.   
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May be Incorrect  	  When an L2 Cache error occurs (Error code 0x010A or 0x110A reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event for Outstanding Bus Requests Ignores AnyThread Bit  	  The Performance Monitoring Event of Outstanding Bus Requests will ignore the AnyThread bit (IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) and will instead always count all transactions across all logical processors, even when AnyThread is clear.  	 The performance monitor count may be incorrect when counting only the current logical processor’s outstanding bus requests on a processor supporting HyperThreading Technology. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23  
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL_MSR (38DH) bit[2] for IA32_FIXED_CTR0, bit[6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring>0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMI Request is Not Generated on a Counter Overflow if its OVF Bit is Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh) then future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	 If software does not clear the OVF bit corresponding to a performance counter then future counter overflows may not cause PMI requests. 	 Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Use an Incorrect Translation if the TLBs Contain Two Different Translations For a Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4-KByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	 Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE. 	 Software can avoid this problem by ensuring that the TLBs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type. 	  24  For the steppings affected, see the Summary Tables of Changes.   
  PEBS Record not Updated When in Probe Mode  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflows of the counter can result in storage of a PEBS record in the PEBS buffer. Due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new PEBS record may not be added to the PEBS buffer.  	 Due to this erratum, the PEBS buffer may not be updated by overflows that occur during probe mode. 	 None. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR/BTM/BTS Information Immediately After a Transition From Legacy/Compatibility Mode to 64-bit Mode May be Incorrect  	  If a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any FROM address recorded by LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) on that second event may incorrectly report the upper 32-bits as zero.  	 Due to this erratum, bits 63:32 of the ‘FROM’ value for LBR/BTM/BTS may be improperly zeroed after a transition to 64 bite mode when the RIP (Instruction Pointer Register) is greater than 4 Gigabyte. 	 None identified. This erratum may be detected by a ‘FROM’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘TO’ address recorded. 	  For the steppings affected, see the Summary Tables of Changes. 
  During a C-state Exit due to a Pending External Interrupt the System May Hang  	  Under a precise set of conditions, a processor waking from a C-state due to a pending external interrupt may not complete the exiting process and the system may hang.  	 Due to this erratum, the system may hang. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   25  
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  LINT0 Assertion and De-assertion During an Inactive State May Cause Unexpected Operation When APIC is Disabled  	  An interrupt delivered via LINT0 pins when the APIC is hardware disabled	NA	NA	NA
 until after the interrupt is acknowledged. However, if LINT0 is asserted and then deasserted before the interrupt is acknowledged and both of the following are true: • The APIC is hardware disabled (IA32_APIC_BASE MSR bit [11] is clear) and • The processor is in an inactive state that was requested by MWAIT, I/O redirection, VM-entry or RSM, then the processor may operate incorrectly  	NA	 Due to this erratum, the processor may run unexpected code and/or generate an unexpected exception. Intel has not observed this erratum with any commercially available software. 	 If LINT0 is used, it is recommended to either leave the APIC enabled (IA32_APIC_BASE MSR bit [11] set to 1) or do not use MWAIT, I/O redirection, VMentry or RSM to enter an inactive state. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes.   27  
  HSYNC/VSYNC Buffer Does Not Meet VESA Rise & Undershoot Specification  	  Both HSYNC (horizontal Sync) and VSYNC (vertical sync) signals are violating VESA (Video Electronics Standards Association) specification due to non-monotonic slow rise time on both signals.  	 HSYNC and VSYNC signals may not meet VESA specification. 	 Insert a buffer in the HSYNC/VSYNC signal path before the video connector. Refer to Platform Design Guide and Customer Reference Board (CRB) schematic for reference. 	  For the steppings affected, see the Summary Tables of Changes. 
  Glitch on LVDS Display Interface Clocks and Data Lines May be Observed during Power-Up Sequences  	  During power up sequence (transition to S0 state from G3, S3, S4 or S5 states) when LVDS (Low Voltage Differential Signal) power supply (1.8V source) ramps up, a glitch on LVDS clocks (LVD_A_CLKP, LVD_A_CLKN) and data lines (LVD_A_DAPAP[2:0], LVD_A_DATAN[2:0]) may be observed.  	 Due to this erratum, a glitch may be seen during power up sequence. The glitch is not seen once the LVDS power supply is stable. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. Due to this erratum, IA32_MPERF may not be reset when IA32_APERF overflows. Instead, IA32_MPERF may continue to increment without being reset.  	 Due to this erratum, software cannot rely on synchronous reset of the IA32_MPERF register. The typical usage of IA32_MPERF/IA32_APERF is to initialize them with a value of 0; in this case the overflow of the counter wouldn’t happen for over 10 years. 	 None identified. 	  28  For the steppings affected, see the Summary Tables of Changes.   
  Writes to Set IA32_MCG_STATUS.MCIP Will Fail  	  An MSR write that attempts to set the IA32_MCG_STATUS MSR (17AH) MCIP (machine check in progress) bit [2] will fail (e.g. #GP fault on WRMSR) instead of setting the bit. An MSR write that specifies 0 for the MCIP bit will function correctly.  	 Due to this erratum, software writes to set this bit will not succeed and may cause an unexpected General Protection fault. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC2_STATUS [OVERFLOW] Bit is Not Set When Single-Bit Correctable ECC Error Occurs  	  The OVERFLOW bit should be set if the VAL bit (IA32_MC2_STATUS (409H) bit [63]) is set when a new error occurs. Due to this erratum, the OVERFLOW bit (IA32_MC2_STATUS (409H) bit [62]) is only set when a prior uncorrected error (as indicated by the UC bit (IA32_MC2_STATUS (409H) bit [61])) is present at the time the second error occurs.  	 Any L2 correctable error will not set the IA32_MC2_STATUS.OVERFLOW bit when overwriting a prior L2 correctable error. 	 The frequency of occurrence of this problem is reduced greatly if an operating system regularly polls and clears the machine check banks as this reduces the likelihood of an overflow condition. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	 If the FP Data Operand Pointer is used in an operating system which may run 16-bit FP code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes.   29  
  High Temperature Circuit Marginality Issue May Cause the System to Hang or Auto  	  A subset of processors may experience circuit marginality issues when operating at high temperature. Due to this erratum a system hang may occur or the processor may proceed to reboot.  	 Due to this erratum, the system may hang or auto reboot. 	 A BIOS workaround has been identified. Please refer to memory reference code version 1.12 or later. 	 
 	  For the steppings affected, see the Summary Tables of Changes.  A 64-bit Register IP-relative Instruction May Return Unexpected Results Under an unlikely and complex sequence of conditions in 64-bit mode, a register IPrelative instruction result may be incorrect.  	 A register IP-relative instruction result may be incorrect and could cause software to read from or write to an incorrect memory location. This may result in an unexpected page fault or unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	 
  	  For the steppings affected, see the Summary Tables of Changes.  Complex Conditions Associated With Instruction Page Remapping or Self/Cross-Modifying Code Execution May Lead to Unpredictable System Behavior Under a complex set of internal conditions, instruction page remapping, or self/cross modifying code events may lead to unpredictable system behavior.  	 Due to this Erratum, unpredictable system behavior may be observed. 	 None identified. 	  30  For the steppings affected, see the Summary Tables of Changes.   
  	  REP MOVS/STOS Executing With Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations Under the conditions described in the Software Developers Manual section “Fast String Operation,” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum, fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary, the following may occur, dependent on the new page memory type: • UC: The data size of each read and write may be different than the original data size. • WP: The data size of each read and write may be different than the original data size and there may be a memory ordering violation. • WT: There may be a memory ordering violation. 	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Paging Structure Entry May be Used Before Accessed And Dirty Flags Are Updated  	  If software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a TLB (or an entry in a paging structure cache) and then update the entry’s new value to set the accessed flag or dirty flag. This will occur only if both the old and new values of the entry result in valid translations.  	 Incorrect behavior may occur with algorithms that atomically check that the accessed flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation. 	 Affected algorithms must ensure that appropriate TLB invalidation is done before assuming that future accesses do not use translations based on the old value of the paging structure entry. 	NA
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4H is set to “1” by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: • A SMI that is pending while a lower priority event is executing • A REP I/O read • A I/O read that redirects to MWAIT  	 SMM handlers may get false IO_SMI indication. 	The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software. 	Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May be Incorrect  	  When an L2 Cache error occurs (Error code 0x010A or 0x110A reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors. 	None identified 	    13 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep® Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	None identified. 	  
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, Exception and Interrupt Reference, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However Contributory Exceptions and Page Faults will continue to cause a triple-fault shutdown.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	None identified 	  
  IA32_MC1_STATUS MSR Bit [60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit [60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	None identified 	  14   
  Performance Monitoring Event for Outstanding Bus Requests Ignores AnyThread Bit  	  The Performance Monitoring Event of Outstanding Bus Requests will ignore the AnyThread bit (IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) and will instead always count all transactions across all logical processors, even when AnyThread is clear.  	 The performance monitor count may be incorrect when counting only the current logical processor’s outstanding bus requests on a processor supporting HyperThreading Technology. 	None identified. 	  
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET.This erratum can only be observed with a software generated stack frame. 	Software should not generate misaligned stack frames for use with IRET. 	  
  Thermal Interrupts are Dropped During and While Exiting Intel® Deep Power Down State  	  Thermal interrupts are ignored while the processor is in Intel® Deep Power Down State as well as during a small window of time while exiting from Intel® Deep Power Down State. During this window, if the PROCHOT signal is driven or the internal value of the sensor reaches the programmed thermal trip point, then the associated thermal interrupt may be lost.  	 In the event of a thermal event while a processor is waking up from Intel® Deep Power Down State, the processor will initiate an appropriate throttle response. However, the associated thermal interrupt generated may be lost. 	None identified. 	    15 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled “Switching to Protected Mode” recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	None identified. 	  
  Performance Monitoring Counter with AnyThread Bit set May Not Count on a Non-Active Thread  	  A performance counter with the AnyThread bit (IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21], IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2) set should count that event on all logical processors on that core. Due to this erratum, a performance counter on a logical processor which has requested to be placed in the Intel® Deep Power Down State may not count events that occur on another logical processor.  	 The performance monitor count may be incorrect when the logical processor is asleep but still attempting to count another logical processor’s events. This will only occur on processors supporting Hyper-Threading Technology (HT Technology). 	None identified. 	  
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring >0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core. 	None identified. 	  16   
  PMI Request is Not Generated on a Counter Overflow if Its OVF Bit is Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh) then future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	 If software does not clear the OVF bit corresponding to a performance counter then future counter overflows may not cause PMI requests. 	Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler. 	  
  Processor May Use an Incorrect Translation if the TLBs Contain Two Different Translations For a Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4-KByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	 Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE. 	Software can avoid this problem by ensuring that the TLBs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type. 	  
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, e.g. CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	    17 
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	The IA32 firmware must leave the xTPR update transactions disabled (default). 	  
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operating systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software. 	None identified. 	  
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  18   
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault. 	In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address Bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address Bit 20 may not be masked. • Paging is enabled • Linear address has bit-20 set • Address references a large page • A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially-available operating system. 	Operating systems should not allow A20M# to be enabled if the masking of address Bit 20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  
  Values for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect.  Note:  This issue would only occur when one of the three above-mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	None identified. 	    19 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64-KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. 	None identified. 	  
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	SMM software should not change the value of EFLAGS.VM in SMRAM. 	  20   
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (that is, residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to “Procedure Calls For Block-Structured Languages” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual-Vol.1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in Ring-3. Faults are usually processed in Ring-0 and stack switch occurs when transferring to Ring-0. Intel has not observed this erratum on any commercially available software. 	None identified. 	  
  With TF (Trap Flag) Asserted, FP Instruction That Triggers an Unmasked FP Exception May Take Single Step Trap before Retirement of Instruction  	  If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  	 A single step trap will be taken when not expected. 	None identified. 	    21 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	As recommended in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP and [r/e]BP will avoid the failure since the MOV [r/e]SP and [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (for example NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher-priority interrupts and exceptions. Intel has not observed this erratum on any commerciallyavailable software. 	None identified. 	  22   
  BTS (Branch Trace Store) and PEBS (Precise Event Based Sampling) May Update Memory outside the BTS/PEBS Buffer  	  If the BTS/PEBS buffer is defined such that: • The difference between BTS/PEBS buffer base and BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes • BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space • The record that would cross BTS/PEBS absolute maximum will also continue past the end of the virtual address space A BTS/PEBS record can be written that will wrap at the 4-G boundary (IA32) or 2^64 boundary (EM64T mode), and write memory outside of the BTS/PEBS buffer.  	 Software that uses BTS/PEBS near the 4G boundary (IA32) or 2^64 boundary (EM64T mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the BTS/PEBS buffer. 	Define BTS/PEBS buffer such that BTS/PEBS absolute maximum minus BTS/PEBS buffer base is integer multiple of the corresponding record sizes as recommended in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3. 	  
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	None identified. 	    23 
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor (that is, executing the modified code).  	 In this case, the phrase “unexpected or unpredictable execution behavior” encompasses the generation of most of the exceptions listed in the Intel® 64 and IA32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors. 	In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Section: Handling Self- and CrossModifying Code. 	  
  The erratum not applicable therefore removed 	NA	NA	NA	NA
  Processor Throttling at 87.5% May Cause System Hang  	  At certain processor core ratios, a request for 87.5% throttling (on-demand clock modulation duty cycle) may cause the processor to hang.  	 Due to this erratum, the system may hang. 	A Power Management Unit firmware code change has been identified and may be implemented as a workaround for this erratum. Throttling at 87.5% will not be supported and any requests for 87.5% will be re-directed to 75%. 	  
  THERMTRIP# Will Not Assert Prior to RESET# De-assertion  	  Potentially catastrophic temperature should be detected and signaled using the THERMTRIP# mechanism after PWRGD assertion. Due to this erratum, THERMTRIP# functionality is not supported during the period from PWRGD assertion to RESET# deassertion. After RESET# de-assertion, THERMTRIP# functions correctly.  	 Due to this erratum, THERMTRIP# will not function until after RESET# de-assertion. 	None identified. 	  24   
  External STPCLK# Throttling May cause System Hang During Thermal Event  	  During a TM1 thermal event when external STPCLK# throttling is enabled through software, the time between STPCLK# assertion and STOP GRANT may not be enough for the processor to de-assert STPCLK# and execute instructions.  	 When this erratum occurs, the system will hang. 	Software should not enable software-controlled STPCLK# throttling. 	  
  C6 Request May Cause a Machine Check if the Other Logical Processor is in C4 or C6  	  A machine check may be generated if a logical processor requests the C6 C-state and the other logical processor is in either C4 or C6 C-states.  	 This erratum may result in unexpected machine-check exceptions. 	It is possible for the BIOS to contain a workaround for this erratum. 	  
  EOI Transaction May Not be Sent if Software Enters Core C6 During an Interrupt Service Routine  	  If core C6 is entered after the start of an interrupt service routine but before a write to the APIC EOI (End of Interrupt) register, and the core is woken up by an event other than a fixed interrupt source the core may drop the EOI transaction the next time APIC EOI register is written and further interrupts from the same or lower priority level will be blocked.  	 EOI transactions may be lost and interrupts may be blocked when core C6 is used during interrupt service routines. 	Software should check the ISR register and enter CD1 only if any interrupt is in service 	  
  Integrated Graphic Unit Does Not Automatically Disable Legacy PCI Interrupts When MSI Are Enabled  	  The integrated graphic unit fails to disable legacy PCI interrupts when MSI (Message Signaled Interrupts) are enabled.  	 Due to this erratum, the processor will fail to be compliant with the PCI specification. This erratum does not apply to operating systems that cannot enable MSI or explicitly disable legacy PCI interrupts when MSI are enabled. 	None identified. 	    25 
  Outbound MSI from The PMU May Result in Live Lock And /or System Hang When Simultaneously Occurring With an Inbound I/O Read  	  The Power Management Unit (PMU) is capable of generating Message Signaled Interrupts (MSI) to the processor. In specific corner cases, an outbound MSI from the PMU may occur simultaneously with an inbound I/O read and may result in live lock and/or a system hang.  	 When this erratum occurs, the processor may live lock and/or result in a system hang. The PMU will not be able to support MSI for display power up and therm trip events. 	It is possible for the firmware and graphics driver to contain a workaround for this erratum. With this workaround, the PMU MSIs will be disabled and hence PMU supported therm trip feature will not be available. 	  
  Complex Conditions Associated With Instruction Page Remapping or Self/Cross-Modifying Code Execution May Lead to Unpredictable System Behavior  	  Under a Complex set of internal conditions, instruction page remapping, or self/cross modifying code events may lead to unpredictable system behavior.  	 Due to this Erratum, unpredictable system behavior may be observed. Intel has not observed this erratum with any commercially available software. 	None identified. 	  
  Paging Structure Entry May be Used Before Accessed And Dirty Flags Are Updated  	  If software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a TLB (or an entry in a paging structure cache). It then updates the entry’s new value to set the accessed flag or dirty flag. This occurs only if both the old and new values of the entry result in valid translation.  	 Incorrect behavior may occur with algorithms that atomically check that the accessed flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation. 	Affected algorithms must ensure that appropriate TLB invalidation is done before assuming that future accesses do not use translations based on the old value of the paging structure entry 	NA
  Writing the Local Vector Table (LVT) When an Interrupt Is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if  that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  LOCK# Asserted During a Special Cycle Shutdown Transaction May Unexpectedly Deassert  	  During a processor shutdown transaction, when LOCK# is asserted and if a DEFER# is received during a snoop phase and the Locked transaction is pipelined on the front side bus (FSB), LOCK# may unexpectedly deassert.  	 When this erratum occurs, the system may hang during shutdown. Intel has not observed this erratum with any commercially available systems or software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Address Reported by Machine-Check Architecture (MCA) on Single-bit L2 ECC Errors May Be Incorrect  	  When correctable Single-bit ECC errors occur in the L2 cache, the address is logged in the MCA address register (MCi_ADDR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in MCi_ADDR, for Single-bit L2 ECC errors. 	 None identified. 	  40  For the steppings affected, see the Summary Tables of Changes.   
  Exception Record (LER) MSRVERW/VERR/LSL/LAR Instructions May Unexpectedly Update the Last Exception Record (LER) MSR  	  The LER MSR may be unexpectedly updated, if the resultant value of the Zero Flag (ZF) is zero after executing the following instructions. 1. VERR (ZF=0 indicates unsuccessful segment read verification) 2. VERW (ZF=0 indicates unsuccessful segment write verification) 3. LAR (ZF=0 indicates unsuccessful access rights load) 4. LSL (ZF=0 indicates unsuccessful segment limit load)  	 The value of the LER MSR may be inaccurate if VERW/VERR/LSL/LAR instructions are executed after the occurrence of an exception. 	 Software exception handlers that rely on the LER MSR value should read the LER MSR  before executing VERW/VERR/LSL/LAR instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR3 Address Match on MOVD/MOVQ/MOVNTQ Memory Store Instruction May Incorrectly Increment Performance Monitoring Count for Saturating SIMD Instructions Retired (Event CFH)  	  Performance monitoring for Event CFH normally increments on saturating SIMD instruction retired. Regardless of DR7 programming, if the linear address of a retiring memory store MOVD/MOVQ/MOVNTQ instruction executed matches the address in DR3, the CFH counter may be incorrectly incremented.  	 The value observed for performance monitoring count for saturating SIMD instructions retired may be too high. The size of the error is dependent on the number of occurrences of the conditions described above, while the counter is active. None Identified. 	NA	  For the steppings affected, see the Summary Tables of Changes. 
  SYSRET May Incorrectly Clear RF (Resume Flag) in the RFLAGS Register  	  In normal operation, SYSRET will restore the value of RFLAGS from R11 (the value previously saved upon execution of the SYSCALL instruction). Due to this erratum, the RFLAGS.RF bit will be unconditionally cleared after execution of the SYSRET instruction.  	 The SYSRET instruction can not be used if the RF flag needs to be set after returning from a system call. Intel has not observed this erratum with any commercially available software. 	 Use the IRET instruction to return from a system call, if RF flag has to be set after the  return. 	  For the steppings affected, see the Summary Tables of Changes   41  
  General Protection Fault (#GP) for Instructions Greater Than 15 Bytes May Be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (for example, Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	 Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU exceptions (#MF) following STI may be serviced before higher priority interrupts.  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are serviced immediately after the STI instruction is executed. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep® Technology transitions or Thermal Monitor 1 events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Removed Erratum  42   	NA	NA	NA	NA
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memorybased APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, for example. CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, that is. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC  register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This generates an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold  interrupt before updating the DTS threshold value. 	  For the steppings affected, see the Summary Tables of Changes. 
  Count Value for Performance-Monitoring Counter PMH_PAGE_WALK May Be Incorrect  	  Performance-Monitoring Counter PMH_PAGE_WALK is used to count the number of page walks resulting from Data Translation Look-Aside Buffer (DTLB) and Instruction Translation Look-Aside (ITLB) misses. Under certain conditions, this counter may be incorrect.  	 There may be small errors in the accuracy of the counter. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   43  
  LER MSRs May Be Incorrectly Updated  	  The LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH) may contain incorrect values after any of the following: • Either STPCLK#, NMI (Non-Maskable Interrupt), or external interrupts • CMP or TEST instructions with an uncacheable memory operand followed by a conditional jump. • STI/POP SS/MOV SS instructions followed by CMP or TEST instructions and then by a conditional jump.  	 When the conditions for this erratum occur, the value of the LER MSRs may be incorrectly updated. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Retired Instructions (C0H) May Not Be Accurate  	  The INST_RETIRED performance monitor may miscount retired instructions as follows: • Repeat string and repeat I/O operations are not counted when a hardware interrupt is received during or after the last iteration of the repeat flow. • VMLAUNCH and VMRESUME instructions are not counted. • HLT and MWAIT instructions are not counted. The following instructions, if executed during HLT or MWAIT events, are also not counted: 5. RSM from a C-state SMI during an MWAIT instruction. 6. RSM from an SMI during a HLT instruction.  	 There may be a smaller than expected value in the INST_RETIRED performance monitoring counter. The extent to which this value is smaller than expected is determined by the frequency of the above cases. 	 None Identified. 	  44  For the steppings affected, see the Summary Tables of Changes.   
  Performance Monitoring Event for Number of Reference Cycles When the Processor Is Not Halted (3CH) Does Not Count According to the Specification  	  The CPU_CLK_UNHALTED performance monitor with mask 1 counts bus clock cycles instead of counting the core clock cycles at the maximum possible ratio. The maximum possible ratio is computed by dividing the maximum possible core frequency by the bus frequency.  	 The CPU_CLK_UNHALTED performance monitor with mask 1 counts a value lower than expected. The value is lower by exactly one multiple of the maximum possible ratio. 	 Multiply the performance monitor value by the maximum possible ratio. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit 20 may not be masked: • Paging is enabled • A linear address has bit 20 set • The address references a large page • A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system. 	 Operating systems should not allow A20M# to be enabled if the masking of address bit 20  could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  For the steppings affected, see the Summary Tables of Changes.   45  
  Writing Shared Unaligned Data that Crosses a Cache Line without Proper Semaphores or Barriers May Expose a Memory Ordering Issue  	  Software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory ordering issue if multiple loads access this shared data shortly thereafter. Exposure to this problem requires the use of a data write which spans a cache line boundary.  	 This erratum may cause loads to be observed out of order. Intel has not observed this erratum with any commercially available software or system. 	 Software should ensure at least one of the following is true when modifying shared data  by multiple agents: • The shared data is aligned. • Proper semaphores or barriers are used in order to prevent concurrent data accesses. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit Violation May Occur On 4-Gigabyte Limit Check  	  Code Segment limit violation may occur on 4-Gigabyte limit check when the code stream wraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.  	 This is a rare condition that may result in a system hang. Intel has not observed this erratum with any commercially available software, or system. 	 Avoid code that wraps around segment limit. 	  46  For the steppings affected, see the Summary Tables of Changes.   
  FP Inexact-Result Exception Flag May Not Be Set  	  When the result of a floating-point operation is not exactly representable in the destination format (1/3 in binary form, for example), an inexact-result (precision) exception occurs. When this occurs, the PE bit (bit 5 of the FPU status word) is normally set by the processor. Under certain rare conditions, this bit may not be set when this rounding occurs. However, other actions taken by the processor (invoking the software exception handler if the exception is unmasked) are not affected. This erratum can only occur if one of the following FST instructions is one or two instructions after the floating-point operation which causes the precision exception: •  FST m32real  •  FST m64real  •  FSTP m32real  •  FSTP m64real  •  FSTP m80real  •  FIST m16int  •  FIST m32int  •  FISTP m16int  •  FISTP m32int  •  FISTP m64int  •  FISTTP m16int  •  FISTTP m32int  •  FISTTP m64int  Note: Even if this combination of instructions is encountered, there is also a dependency on the internal pipelining and execution state of both instructions in the processor. 	 Inexact-result exceptions are commonly masked or ignored by applications, as it happens frequently, and produces a rounded result acceptable to most applications. The PE bit of the FPU status word may not always be set upon receiving an inexactresult exception. Thus, if these exceptions are unmasked, a floating-point error exception handler may not recognize that a precision exception occurred. Note that this is a "sticky" bit, i.e., once set by an inexact-result condition, it remains set until cleared by software. 	 This condition can be avoided by inserting either three NOPs or three non-floating-point  non-Jcc instructions between the two floating-point instructions. 	  For the steppings affected, see the Summary Tables of Changes.   47  
  Global Pages in the Data Translation Look-Aside Buffer (DTLB) May Not Be Flushed by RSM instruction before Restoring the Architectural State from SMRAM  	  The Resume from System Management Mode (RSM) instruction does not flush global pages from the Data Translation Look-Aside Buffer (DTLB) prior to reloading the saved architectural state.  	 If SMM turns on paging with global paging enabled and then maps any of linear addresses of SMRAM using global pages, RSM load may load data from the wrong location. 	 Do not use global pages in system management mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  Sequential Code Fetch to Non-canonical Address May Have Nondeterministic Results  	  If code sequentially executes off the end of the positive canonical address space (falling through from address 00007fffffffffff to non- canonical address 0000800000000000), under some circumstances the code fetch will be converted to a canonical fetch at address ffff800000000000.  	 Due to this erratum, the processor may transfer control to an unintended address. The result of fetching code at that address is unpredictable and may include an unexpected trap or fault, or execution of the instructions found there. 	 If the last page of the positive canonical address space is not allocated for code (4K page  at 00007ffffffff000 or 2M page at 00007fffffe00000) then the problem cannot occur. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMCALL to Activate Dual-monitor Treatment of SMIs and SMM Ignores Reserved Bit Settings in VM-exit Control Field  	  Processors supporting Intel® Virtualization Technology can execute VMCALL from within the Virtual Machine Monitor (VMM) to activate dual-monitor treatment of SMIs and SMM. Due to this erratum, if reserved bits are set to values inconsistent with VMX Capability MSRs, VMCALL may not VMFail.  	 VMCALL executed to activate dual-monitor treatment of SMIs and SMM may not VMFail due to incorrect reserved bit settings in VM-Exit control field. 	 Software should ensure that all VMCS reserved bits are set to values consistent with  VMX Capability MSRs. 	  48  For the steppings affected, see the Summary Tables of Changes.   
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types May Use an Incorrect Data Size or Lead to Memory-Ordering Violations.  	  Under certain conditions as described in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, section Out-of-Order Stores For string operations in Pentium 4, Intel Xeon, and P6 Family Processors, the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary the following may occur, dependent on the new page memory type: 1. UC the data size of each write will now always be 8 bytes, as opposed to the original data size. 2. WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. 3. WT there may be a memory ordering violation. 	 Software should avoid crossing page boundaries from WB or WC memory type to UC,  WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Some Bus Performance Monitoring Events May Not Count Local Events under Certain Conditions  	  The following Bus Transaction Performance Monitor events are supposed to count all local transactions: • BUS_TRANS_ IO (Event: 6CH) – Will not count I/O level reads resulting from package resolved C-state • BUS_TRANS_ANY (Event: 70H) – Will not count Stop-Grants  	 The count values for the affected events may be lower than expected. The degree of under count depends on the occurrence of erratum conditions while the affected events are active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   49  
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur it is possible that the load portion of the instruction is executed before the exception handler is entered. 1. If an instruction that performs a memory load causes a code segment limit violation. 2. If a waiting X87 floating-point (FP) instruction or MMX™ technology instruction that performs a memory load has a floating-point exception pending. 3. If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Top-of-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	 In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception. 	 Code which performs loads from memory that has side-effects can effectively  workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4-G limit (0ffffffffh) may not signal a #GP fault.  	 When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault. 	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4-  G limit (0ffffffffh). 	  50  For the steppings affected, see the Summary Tables of Changes.   
  EIP May Be Incorrect after Shutdown in IA-32e Mode  	  When the processor is going into shutdown state the upper 32 bits of the instruction pointer may be incorrect. This may be observed if the processor is taken out of shutdown state by NMI#.  	 A processor that has been taken out of the shutdown state may have an incorrect EIP. The only software which would be affected is diagnostic software that relies on a valid EIP. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP Fault Is Not Generated on Writing IA32_MISC_ENABLE [34] When Execute Disable Is Not Supported  	  A #GP fault is not generated on writing to IA32_MISC_ENABLE [34] bit in a processor which does not support Execute Disable functionality.  	 Writing to IA32_MISC_ENABLE [34] bit is silently ignored without generating a fault. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  (E)CX May Get Incorrectly Updated When Performing Fast String REP MOVS or Fast String REP STOS with Large Data Structures  	  When performing Fast String REP MOVS or REP STOS commands with data structures [(E)CX*Data Size] larger than the supported address size structure (64 kB for 16-bit address size and 4 GB for 32-bit address size) some addresses may be processed more than once. After an amount of data greater than or equal to the address size structure has been processed, external events (such as interrupts) will cause the (E)CX registers to be increment by a value that corresponds to 64 kB for 16-bit address size and 4 GB for 32-bit address size.  	 (E)CX may contain an incorrect count which may cause some of the MOVS or STOS operations to re-execute. Intel has not observed this erratum with any commercially available software. 	 Do not use values in (E)CX that when multiplied by the data size, give values larger than  the address space size (64 kB for 16-bit address size and 4 GB for 32-bit address size). 	  For the steppings affected, see the Summary Tables of Changes.   51  
  Performance Monitoring Events for Retired Loads (CBH) and Instructions Retired (C0H) May Not Be Accurate  	  The following events may be counted as instructions that contain a load by the MEM_LOAD_RETIRED performance monitor events and may be counted as loads by the INST_RETIRED (mask 01H) performance monitor event: • Prefetch instructions • x87 exceptions on FST* and FBSTP instructions • Breakpoint matches on loads, stores, and I/O instructions • Stores which update the A and D bits • Stores that split across a cache line • VMX transitions • Any instruction fetch that misses in the ITLB  	 The MEM_LOAD_RETIRED and INST_RETIRED (mask 01H) performance monitor events may count a value higher than expected. The extent to which the values are higher than expected is determined by the frequency of the above events. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Upper 32 Bits of 'From' Address Reported through BTMs or BTSs May Be Incorrect  	  When a far transfer switches the processor from 32-bit mode to IA-32e mode, the upper 32 bits of the 'From' (source) addresses reported through the BTMs (Branch Trace Messages) or BTSs (Branch Trace Stores) may be incorrect.  	 The upper 32 bits of the 'From' address debug information reported through BTMs or BTSs may be incorrect during this transition. 	 None identified. 	  52  For the steppings affected, see the Summary Tables of Changes.   
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel® 64 and IA32 Architectures Software Developer’s Manual Volume 3: System Programming Guide, including a General Protection Fault (GPF) or other unexpected behaviors. In the event that unpredictable execution causes a GPF the application executing the unsynchronized XMC operation would be terminated by the operating system. 	 In order to avoid this erratum, programmers should use the XMC synchronization ®  algorithm as detailed in the Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 3: System Programming Guide, Section: Handling Self- and CrossModifying Code. 	  Fixed. For the steppings affected, see the Summary Tables of Changes. 
  MSRs Actual Frequency Clock Count (IA32_APERF) or Maximum Frequency Clock Count (IA32_MPERF) May Contain Incorrect Data after a Machine Check Exception (MCE)  	  When an MCE occurs during execution of a RDMSR instruction for MSRs Actual Frequency Clock Count (IA32_APERF) or Maximum Frequency Clock Count (IA32_MPERF), the current and subsequent RDMSR instructions for these MSRs may contain incorrect data.  	 After an MCE event, accesses to the IA32_APERF and IA32_MPERF MSRs may return incorrect data. A subsequent reset will clear this condition. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   53  
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-  bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Split Locked Stores May Not Trigger the Monitoring Hardware  	  Logical processors normally resume program execution following the MWAIT, when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation. Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store that spans across cache lines within the monitored address range.  	 The logical processor that executed the MWAIT instruction may not resume execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is split across cache lines. 	 Do not use locked stores that span cache lines in the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP CMPS/SCAS Operations May Terminate Early in 64-bit Mode When RCX >= 0X100000000  	  REP CMPS (Compare String) and SCAS (Scan String) instructions in 64-bit mode may terminate before the count in RCX reaches zero if the initial value of RCX is greater than or equal to 0X100000000.  	 Early termination of REP CMPS/SCAS operation may be observed and RFLAGS may be incorrectly updated. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  54  For the steppings affected, see the Summary Tables of Changes.   
  FXSAVE/FXRSTOR Instructions which Store to the End of the Segment and Cause a Wrap to a Misaligned Base Address (Alignment <= 0x10h) May Cause FPU Instruction or Operand Pointer Corruption  	  If a FXSAVE/FXRSTOR instruction stores to the end of the segment causing a wrap to a misaligned base address (alignment <= 0x10h), and one of the following conditions is satisfied: 1. 32-bit addressing, obtained by using address-size override, when in 64-bit mode 2. 16-bit addressing in legacy or compatibility mode. Then, depending on the wrap-around point, one of the below saved values may be corrupted: • FPU Instruction Pointer Offset • FPU Instruction Pointer Selector • FPU Operand Pointer Selector • FPU Operand Pointer Offset  	 This erratum could cause FPU Instruction or Operand pointer corruption and may lead to unexpected operations in the floating point exception handler. 	 Avoid segment base misalignment and address wrap-around at the segment boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  Cache Data Access Request from One Core Hitting a Modified Line in the L1 Data Cache of the Other Core May Cause Unpredictable System Behavior  	  When request for data from Core 1 results in a L1 cache miss, the request is sent to the L2 cache. If this request hits a modified line in the L1 data cache of Core 2, certain internal conditions may cause incorrect data to be returned to the Core 1.  	 This erratum may cause unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PREFETCHh Instruction Execution under Some Conditions May Lead to Processor Livelock  	  PREFETCHh instruction execution after a split load and dependent upon ongoing store operations may lead to processor livelock.  	 Due to this erratum, the processor may livelock. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   55  
  PREFETCHh Instructions May Not Be Executed When Alignment Check (AC) Is Enabled  	  PREFETCHT0, PREFETCHT1, PREFETCHT2 and PREFETCHNTA instructions may not be executed when Alignment Check is enabled.  	 PREFETCHh instructions may not perform the data prefetch if Alignment Check is enabled. 	 Clear the AC flag (bit 18) in the EFLAGS register and/or the AM bit (bit 18) of Control  Register CR0 to disable alignment checking. 	  For the steppings affected, see the Summary Tables of Changes. 
  Upper 32 Bits of the FPU Data (Operand) Pointer in the FXSAVE Memory Image May Be Unexpectedly All 1's after FXSAVE  	  The upper 32 bits of the FPU Data (Operand) Pointer may incorrectly be set to all 1's instead of the expected value of all 0's in the FXSAVE memory image if all of the following conditions are true: • The processor is in 64-bit mode. • The last floating point operation was in compatibility mode • Bit 31 of the FPU Data (Operand) Pointer is set. • An FXSAVE instruction is executed  	 Software depending on the full FPU Data (Operand) Pointer may behave unpredictably. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Concurrent Multi-processor Writes to Non-dirty Page May Result in Unpredictable Behavior  	  When a logical processor writes to a non-dirty page, and another logical-processor either writes to the same non-dirty page or explicitly sets the dirty bit in the corresponding page table entry, complex interaction with internal processor activity may cause unpredictable system behavior.  	 This erratum may result in unpredictable system behavior and hang. 	 It is possible for BIOS to contain a workaround for this erratum. 	  56  For the steppings affected, see the Summary Tables of Changes.   
  Performance Monitor IDLE_DURING_DIV (18h) Count May Not Be Accurate  	  Performance monitoring events that count the number of cycles the divider is busy and no other execution unit operation or load operation is in progress may not be accurate.  	 The counter may reflect a value higher or lower than the actual number of events. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM Will Be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect.  Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used. 	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Shutdown Condition May Disable Non-Bootstrap Processors  	  When a logical processor encounters an error resulting in shutdown, non-bootstrap processors in the package may be unexpectedly disabled.  	 Non-bootstrap logical processors in the package that have not observed the error condition may be disabled and may not respond to INIT#, SMI#, NMI#, SIPI or other events. 	 When this erratum occurs, RESET# must be asserted to restore multi-core functionality. 	  For the steppings affected, see the Summary Tables of Changes.   57  
  SYSCALL Immediately after Changing EFLAGS.TF May Not Behave According to the New EFLAGS.TF  	  If a SYSCALL instruction follows immediately after EFLAGS.TF was updated and IA32_FMASK.TF (bit 8) is cleared, then under certain circumstances SYSCALL may behave according to the previous EFLAGS.TF.  	 When the problem occurs, SYSCALL may generate an unexpected debug exception, or may skip an expected debug exception. 	 Mask EFLAGS.TF by setting IA32_FMASK.TF (bit 8). 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May Be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Bit Is Cleared on Second Fault Handled by Task Switch from Virtual- 8086 (VM86)  	  Following a task switch to any fault handler that was initiated while the processor was in VM86 mode, if there is an additional fault while servicing the original task switch then the VM bit will be incorrectly cleared in EFLAGS, data segments will not be pushed and the processor will not return to the correct mode upon completion of the second fault handler via IRET.  	 When the OS recovers from the second fault handler, the processor will no longer be in VM86 mode. Normally, operating systems should prevent interrupt task switches from faulting, thus the scenario should not occur under normal circumstances. 	 None Identified. 	  58  For the steppings affected, see the Summary Tables of Changes.   
  IA32_FMASK Is Reset during an INIT  	  IA32_FMASK MSR (0xC0000084) is reset during INIT.  	 If an INIT takes place after IA32_FMASK is programmed, the processor will overwrite the value back to the default value. 	 Operating system software should initialize IA32_FMASK after INIT. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. ®  	 As recommended in the Intel 64 and IA-32 Architectures Software Developer's Manual,  the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Last Branch Records (LBR) Updates May Be Incorrect after a Task Switch  	  A Task-State Segment (TSS) task switch may incorrectly set the LBR_FROM value to the LBR_TO value.  	 The LBR_FROM will have the incorrect address of the Branch Instruction. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes.   59  
  IO_SMI Indication in SMRAM State Save Area May Be Set Incorrectly  	  The IO_SMI bit in SMRAM's location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: •  A non-I/O instruction.  •  SMI is pending while a lower priority event interrupts.  •  A REP I/O read.  •  An I/O read that redirects to MWAIT.  •  In systems supporting Intel® Virtualization Technology a fault in the middle of an IO operation that causes a VM Exit  	 SMM handlers may get false IO_SMI indication. 	 The SMM handler has to evaluate the saved context to determine if the SMI was  triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  INIT Does Not Clear Global Entries in the TLB  	  INIT may not flush a TLB entry when: • The processor is in protected mode with paging enabled and the page global enable flag is set (PGE bit of CR4 register). • G bit for the page table entry is set. • TLB entry is present in TLB when INIT occurs.  	 Software may encounter unexpected page fault or incorrect address translation due to a TLB entry erroneously left in TLB after INIT. 	 Write to CR3, CR4 (setting bits PSE, PGE or PAE) or CR0 (setting bits PG or PE)  registers before writing to memory early in BIOS code to clear all the global entries from TLB. 	  60  For the steppings affected, see the Summary Tables of Changes.   
  Using Memory Type Aliasing with Memory Types WB/WT May Lead to Unpredictable Behavior  	  Memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory type. Memory type aliasing with the memory types WB and WT may cause the processor to perform incorrect operations leading to unpredictable behavior.  	 Software that uses aliasing of WB and WT memory types may observe unpredictable behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Update of Read/Write (R/W) or User/Supervisor (U/S) or Present (P) Bits without TLB Shootdown May Cause Unexpected Processor Behavior  	  Updating a page table entry by changing R/W, U/S or P bits without TLB shootdown (as defined by the 4 step procedure in "Propagation of Page Table and Page Directory Entry Changes to Multiple Processors" In volume 3A of the Intel® 64 and IA-32 Architectures Software Developer’s Manual), in conjunction with a complex sequence of internal processor micro-architectural events, may lead to unexpected processor behavior.  	 This erratum may lead to livelock, shutdown or other unexpected processor behavior. Intel has not observed this erratum with any commercially available system. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  BTS Message May Be Lost When the STPCLK# Signal Is Active  	  STPCLK# is asserted to enable the processor to enter a low-power state. Under some circumstances, when STPCLK# becomes active, the BTS (Branch Trace Store) message may be either lost and not written or written with corrupted branch address to the Debug Store area.  	 BTS messages may be lost or be corrupted in the presence of STPCLK# assertions. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes.   61  
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug register, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (that is, the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault. 	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD  bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  62  For the steppings affected, see the Summary Tables of Changes.   
  EFLAGS Discrepancy on a Page Fault after a Multiprocessor TLB Shootdown  	  This erratum may occur when the processor executes one of the following readmodify-write arithmetic instructions and a page fault occurs during the store of the memory operand: ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD. In this case, the EFLAGS value pushed onto the stack of the page fault handler may reflect the status of the register after the instruction would have completed execution rather than before it. The following conditions are required for the store to generate a page fault and call the operating system page fault handler: 1. The store address entry must be evicted from the DTLB by speculative loads from other instructions that hit the same way of the DTLB before the store has completed. DTLB eviction requires at least three-load operations that have linear address bits 15:12 equal to each other and address bits 31:16 different from each other in close physical proximity to the arithmetic operation. 2. The page table entry for the store address must have its permissions tightened during the very small window of time between the DTLB eviction and execution of the store. Examples of page permission tightening include from Present to Not Present or from Read/Write to Read Only, etc. 3. Another processor, without corresponding synchronization and TLB flush, must cause the permission change.  	 This scenario may only occur on a multiprocessor platform running an operating system that performs “lazy” TLB shootdowns. The memory image of the EFLAGS register on the page fault handler’s stack prematurely contains the final arithmetic flag values although the instruction has not yet completed. Intel has not identified any operating systems that inspect the arithmetic portion of the EFLAGS register during a page fault nor observed this erratum in laboratory testing of software applications. 	 No workaround is needed upon normal restart of the instruction, since this erratum is  transparent to the faulting code and results in correct instruction behavior. Operating systems may ensure that no processor is currently accessing a page that is scheduled to have its page permissions tightened or have a page fault handler that ignores any incorrect state. 	  For the steppings affected, see the Summary Tables of Changes.   63  
  LBR, BTS, BTM May Report a Wrong Address When an Exception/Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	 LBR, BTS and BTM may report incorrect information in the event of an exception/interrupt. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Thermal Interrupt Is Not Generated When the Current Temperature Is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9, 7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CMPSB, LODSB, or SCASB in 64-bit Mode with Count Greater or Equal to 248 May Terminate Early  	  In 64-bit Mode CMPSB, LODSB, or SCASB executed with a repeat prefix and count 48 greater than or equal to 2 may terminate early. Early termination may result in one of the following. • The last iteration not being executed • Signaling of a canonical limit fault (#GP) on the last iteration  	 While in 64-bit mode, with count greater or equal to 248, repeat string operations CMPSB, LODSB or SCASB may terminate without completing the last iteration. Intel has not observed this erratum with any commercially available software. 48  	 Do not use repeated string operations with RCX greater than or equal to 2 . 	  64  For the steppings affected, see the Summary Tables of Changes.   
  Removed Erratum 	NA	NA	NA	NA
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMLAUNCH/VMRESUME May Not Fail when VMCS Is Programmed to Cause VM Exit to Return to a Different Mode  	  VMLAUNCH/VMRESUME instructions may not fail if the value of the “host addressspace size” VM-exit control differs from the setting of IA32_EFER.LMA.  	 Programming the VMCS to allow the monitor to be in different modes prior to VMLAUNCH/VMRESUME and after VM-exit may result in undefined behavior 	 Software should ensure that "host address-space size" VM-exit control has the same  value as IA32_EFER.LMA at the time of VMLAUNCH/VMRESUME. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes.   65  
  Performance Monitoring Event FP_ASSIST May Not Be Accurate  	  In addition, an assist event may be counted when DAZ (Denormals-Are-Zeros) and FTZ (Flush-To-Zero) flags are turned on even though no actual assist occurs.  	 The counter value for the performance monitoring event FP_ASSIST (11H) may be larger than expected. The size of the error is dependent on the number of occurrences of the above conditions while the event is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPL-Qualified BTS May Report Incorrect Branch-From Instruction Address  	  CPL (Current Privilege Level)-qualified BTS (Branch Trace Store) may report incorrect branch-from instruction address under the following conditions: • Either BTS_OFF_OS [9] or BTS_OFF_USR [10] is selected in IA32_DEBUGCTLC MSR (1D9H). • Privilege-level transitions occur between CPL > 0 and CPL 0 or vice versa.  	 Due to this erratum, the From address reported by BTS may be incorrect for the described conditions. 	 None Identified 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS Does Not Always Differentiate Between CPL-Qualified Events  	  Performance monitoring counter configured to sample PEBS (Precise Event Based Sampling) events at a certain privilege level may count samples at the wrong privilege level.  	 Performance monitoring counter may be higher than expected for CPL-qualified events. 	 Do not use performance monitoring counters for precise event sampling when the precise  event is dependent on the CPL value. 	  66  For the steppings affected, see the Summary Tables of Changes.   
  PMI May Be Delayed to Next PEBS Event  	  After a PEBS (Precise Event-Based Sampling) event, the PEBS index is compared with the PEBS threshold, and the index is incremented with every event. If PEBS index is equal to the PEBS threshold, a PMI (Performance Monitoring Interrupt) should be issued. Due to this erratum, the PMI may be delayed by one PEBS event.  	 Debug Store Interrupt Service Routines may observe delay of PMI occurrence by one PEBS event. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS Buffer Overflow Status Will Not Be Indicated Unless IA32_DEBUGCTL[12] Is Set  	  IA32_PERF_GLOBAL_STATUS MSR (38EH) bit [62] when set, indicates that a PEBS (Precise Event-Based Sampling) overflow has occurred and a PMI (Performance Monitor Interrupt) has been sent. Due to this erratum, this bit is not set unless IA32_DEBUGCTL MSR (1D9H) bit [12] (which stops all performance monitor counters upon a PMI) is also set.  	 Due to this erratum, IA32_PERF_GLOBAL_STATUS [62] will not signal that a PMI was generated due to a PEBS Overflow unless IA32_DEBUGCTL [12] is set. 	 It is possible for the software to set IA32_DEBUGCTL [12] to avoid this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The BS Flag in DR6 May Be Set for Non-Single-Step #DB Exception  	  DR6 BS (Single Step, bit 14) flag may be incorrectly set when the TF (Trap Flag, bit 8) of the EFLAGS Register is set, and a #DB (Debug Exception) occurs due to one of the following: • DR7 GD (General Detect, bit 13) being bit set • INT1 instruction; • Code breakpoint  	 The BS flag may be incorrectly set for non-single-step #DB exception. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   67  
  An Asynchronous MCE During a Far Transfer May Corrupt ESP  	  If an asynchronous machine check occurs during an interrupt, call through gate, FAR RET or IRET and in the presence of certain internal conditions, ESP may be corrupted.  	 If the MCE (Machine Check Exception) handler is called without a stack switch, then a triple fault will occur due to the corrupted stack pointer, resulting in a processor shutdown. If the MCE is called with a stack switch, for example when the CPL (Current Privilege Level) was changed or when going through an interrupt task gate, then the corrupted ESP will be saved on the stack or in the TSS (Task State Segment), and will not be used. 	 Use an interrupt task gate for the machine check handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  In Single-Stepping on Branches Mode, the BS Bit in the PendingDebug-Exceptions Field of the Guest State Area Will Be Incorrectly Set by VM-Exit on a MOV to CR8 Instruction  	  In a system supporting Intel Virtualization Technology, the BS bit (bit 14 of the Pending-Debug-Exceptions field) in the guest state area will be incorrectly set when all of the following conditions occur: The processor is running in VMX non-root as a 64 bit mode guest; • The “CR8-load existing” VM-execution control is 0 and the “use TPR shadow” VMexecution is 1. • Both BTF (Single-Step On Branches, bit 1) of the IA32_DEBUGCTL MSR (1D9H) Register and the TF (Trap Flag, bit 8) of the RFLAGS Register are set. • “MOV CR8, reg” attempts to program a TPR (Task Priority Register) value that is below the TPR threshold and causes a VM-exit.  	 A Virtual-Machine will sample the BS bit and will incorrectly inject a Single-Step trap to the guest. 	 A Virtual-Machine Monitor must manually disregard the BS bit in the Guest State Area in  case of a VM-exit due to a TPR value below the TPR threshold. 	  68  For the steppings affected, see the Summary Tables of Changes.   
  B0-B3 Bits in DR6 May Not Be Properly Cleared after Code Breakpoint  	  B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may not be properly cleared when the following sequence happens: 1. POP instruction to SS (Stack Segment) selector. 2. Next instruction is FP (Floating Point) that gets FP assist followed by code breakpoint.  	 B0-B3 bits in DR6 may not be properly cleared. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  BTM/BTS Branch-From Instruction Address May Be Incorrect for Software Interrupts  	  When BTM (Branch Trace Message) or BTS (Branch Trace Store) is enabled, a software interrupt may result in the overwriting of BTM/BTS branch-from instruction address by the LBR (Last Branch Record) branch-from instruction address.  	 A BTM/BTS branch-from instruction address may get corrupted for software interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP Store Instructions in a Specific Situation May Cause the Processor to Hang  	  During a series of REP (repeat) store instructions a store may try to dispatch to memory prior to the actual completion of the instruction. This behavior depends on the execution order of the instructions, the timing of a speculative jump and the timing of an uncacheable memory store. All types of REP store instructions are affected by this erratum.  	 When this erratum occurs, the processor may live lock and/or result in a system hang. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   69  
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  The SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in values higher than the number of actual retired SSE instructions.  	 The event monitor instruction SIMD_INST_RETIRED may report count higher than expected. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for L1 and L2 Miss May Not Be Accurate  	  Performance monitoring events 0CBh with an event mask value of 02h or 08h (MEM_LOAD_RETIRED.L1_LINE_MISS or MEM_LOAD_RETIRED.L2_LINE_MISS) may under count the cache miss events.  	 These performance monitoring events may show a count which is lower than expected; the amount by which the count is lower is dependent on other conditions occurring on the same load that missed the cache. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Store to WT Memory Data May Be Seen in Wrong Order by Two Subsequent Loads  	  When data of Store to WT memory is used by two subsequent loads of one thread and another thread performs cacheable write to the same address the first load may get the data from external memory or L2 written by another core, while the second load will get the data straight from the WT Store.  	 Software that uses WB to WT memory aliasing may violate proper store ordering. 	 Do not use WB to WT aliasing. 	  70  For the steppings affected, see the Summary Tables of Changes.   
  A MOV Instruction from CR8 Register with 16-Bit Operand Size Will Leave Bits 63:16 of the Destination Register Unmodified  	  Moves to/from control registers are supposed to ignore REW.W and the 66H (operand size) prefix. In systems supporting Intel Virtualization Technology, when the processor is operating in VMX non-root operation and “use TPR shadow” VM-execution control is set to 1, a MOV instruction from CR8 with a 16 bit operand size (REX.W =0 and 66H prefix) will only store 16 bits and leave bits 63:16 at the destination register unmodified, instead of storing zeros in them.  	 Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Debug Register May Contain Incorrect Information on a MOVSS or POPSS Instruction Followed by SYSRET  	  In IA-32e mode, if a MOVSS or POPSS instruction with a debug breakpoint is followed by the SYSRET instruction; incorrect information may exist in the Debug Status Register (DR6).  	 When debugging or when developing debuggers, this behavior should be noted. This erratum does not occur under normal usage of the MOVSS or POPSS instructions (that is, following them with a MOV ESP instruction). 	 Do not attempt to put a breakpoint on MOVSS and POPSS instructions that are followed  by a SYSRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	 None Identified 	  For the steppings affected, see the Summary Tables of Changes.   71  
  Non-Temporal Data Store May Be Observed in Wrong Program Order  	  When non-temporal data is accessed by multiple read operations in one thread while another thread performs a cacheable write operation to the same address, the data stored may be observed in wrong program order (i.e., later load operations may read older data).  	 Software that uses non-temporal data without proper serialization before accessing the non-temporal data may observe data in wrong program order. ®  	 Software that conforms to the Intel 64 and IA-32 Architecture Software Developer's  Manual, Volume 3A, section “Buffering of Write Combining Memory Locations” will operate correctly. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e., residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially-available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Reports Architectural Performance Monitoring Version 2 Is Supported, When Only Version 1 Capabilities Are Available  	  CPUID leaf 0Ah reports the architectural performance monitoring version that is available in EAX[7:0]. Due to this erratum CPUID reports the supported version as 2 instead of 1.  	 Software will observe an incorrect version number in CPUID.0Ah.EAX [7:0] in comparison to which features are actually supported. 	 Software should use the recommended enumeration mechanism described in the ®  Architectural Performance Monitoring section of the Intel 64 and IA-32 Architecture Software Developer's Manual, Volume 3: System Programming Guide. 	  72  For the steppings affected, see the Summary Tables of Changes.   
  Unaligned Accesses to Paging Structures May Cause the Processor to Hang  	  When an unaligned access is performed on paging structure entries, accessing a portion of two different entries simultaneously, the processor may live lock.  	 When this erratum occurs, the processor may live lock causing a system hang. 	 Do not perform unaligned accesses on paging structure entries. 	  For the steppings affected, see the Summary Tables of Changes. 
  Microcode Updates Performed During VMX Non-root Operation Could Result in Unexpected Behavior  	  When Intel® Virtualization Technology is enabled, microcode updates are allowed only during VMX root operations. Attempts to apply microcode updates while in VMX nonroot operation should be silently ignored. Due to this erratum, the processor may allow microcode updates during VMX non-root operations if not explicitly prevented by the host software.  	 Microcode updates performed in non-root operation may result in unexpected system behavior. 	 Host software should intercept and prevent loads to IA32_BIOS_UPDT_TRIG MSR (79H)  during VMX non-root operations. There are two mechanism that can be used (1) Enabling MSR access protection in the VM-execution controls or (2) Enabling selective MSR protection of IA32_BIOS_UPDT_TRIG MSR. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Operation for Large (2M/4M) Pages May Be Incomplete under Certain Conditions  	  The INVLPG instruction may not completely invalidate Translation Look-aside Buffer (TLB) entries for large pages (2-M/4-M) when both of the following conditions exist: • Address range of the page being invalidated spans several Memory Type Range Registers (MTRRs) with different memory types specified. • INVLPG operation is preceded by a Page Assist Event (Page Fault (#PF) or an access that results in either A or D bits being set in a Page Table Entry (PTE)  	 Stale translations may remain valid in TLB after a PTE update resulting in unpredictable system behavior. Intel has not observed this erratum with any commercially available software 	 Software should ensure that the memory type specified in the MTRRs is the same for the  entire address range of the large page. 	  For the steppings affected, see the Summary Tables of Changes.   73  
  Page Access Bit May Be Set Prior to Signaling a Code Segment Limit Fault  	  If code segment limit is set close to the end of a code page, then due to this erratum the memory page Access bit (A bit) may be set for the subsequent page prior to general protection fault on code segment limit.  	 When this erratum occurs, a non-accessed page present in memory following a page that contains the code segment limit may be tagged as accessed 	 Non-present or non-executable page can be placed after the limit of the code segment to  prevent this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Update of Attribute Bits on Page Directories without Immediate TLB Shootdown May Cause Unexpected Processor Behavior  	  Updating a page directory entry (or page map level 4 table entry or page directory pointer table entry in IA-32e mode) by changing R/W, U/S or P bits without immediate TLB shootdown (as described by the 4 step procedure in "Propagation of Page Table and Page Directory Entry Changes to Multiple Processors" In Volume 3A of the Intel® 64 and IA-32 Architectures Software Developer’s Manual), in conjunction with a complex sequence of internal processor micro-architectural events, may lead to unexpected processor behavior.  	 This erratum may lead to livelock, shutdown or other unexpected processor behavior. Intel has not observed this erratum with any commercially available system. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Invalid Instructions May Lead to Unexpected Behavior  	  Invalid instructions due to undefined opcodes or instructions exceeding the maximum instruction length (due to redundant prefixes placed before the instruction) may lead, under complex circumstances, to unexpected behavior.  	 The processor may behave unexpectedly due to invalid instructions. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  74  For the steppings affected, see the Summary Tables of Changes.   
  EFLAGS, CR0, CR4 and the EXF4 Signal May Be Incorrect after Shutdown  	  When the processor is going into shutdown due to an RSM inconsistency failure, EFLAGS, CR0 and CR4 may be incorrect. In addition the EXF4 signal may still be asserted. This may be observed if the processor is taken out of shutdown by NMI#.  	 A processor that has been taken out of shutdown may have an incorrect EFLAGS, CR0 and CR4. In addition the EXF4 signal may still be asserted. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Counter MACRO_INSTS.DECODED May Not Count Some Decoded Instructions  	 	NA	NA	NA
 counts the number of macro instructions decoded, but not necessarily retired. The event is undercounted when the decoded instructions are a complete loop iteration that is decoded in one cycle and the loop is streamed by the LSD (Loop Stream Detector), as described in the Optimizing the Front End section of the Intel® 64 and IA-32 Architectures Optimization Reference Manual.  	NA	 The count value returned by the performance monitoring counter MACRO_INST.DECODED may be lower than expected. The degree of undercounting is dependent on the occurrence of loop iterations that are decoded in one cycle and whether the loop is streamed by the LSD while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Stack May Be Incorrect as a Result of VIP/VIF Check on SYSEXIT and SYSRET  	  3. Both the VIF (Virtual Interrupt Flag) and VIP (Virtual Interrupt Pending) flags of the EFLAGS register are set  	 If this erratum occurs the stack size may be incorrect, consequently this may result in unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   75  
  Performance Monitoring Event SIMD_UOP_TYPE_EXEC.MUL Is Counted Incorrectly for PMULUDQ Instruction  	  Performance Monitoring Event SIMD_UOP_TYPE_EXEC.MUL (Event select 0B3H, Umask 01H) counts the number of SIMD packed multiply micro-ops executed. The count for PMULUDQ micro-ops might be lower than expected. No other instruction is affected.  	 The count value returned by the performance monitoring event SIMD_UOP_TYPE_EXEC.MUL may be lower than expected. The degree of undercount depends on actual occurrences of PMULUDQ instructions, while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	 When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay. 	 None identified. 	  76  For the steppings affected, see the Summary Tables of Changes.   
  Updating Code Page Directory Attributes without TLB Invalidation May Result in Improper Handling of Code #PF  	  One of the following simultaneous exception conditions is present following the code transition  Code #DB and code #PF  Code Segment Limit Violation #GP and code #PF  	 Software may observe either incorrect processing of code #PF before code Segment Limit Violation #GP or processing of code #PF in lieu of code #DB. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   77  
  Performance Monitoring Event CPU_CLK_UNHALTED.REF May Not Count Clock Cycles According to the Processors Operating Frequency  	  Performance Counter MSR_PERF_FIXED_CTR2 (MSR 30BH) that counts CPU_CLK_UNHALTED.REF clocks should count these clock cycles at a constant rate that is determined by the maximum resolved boot frequency, as programmed by BIOS. Due to this erratum, the rate is instead set by the maximum core-clock to busclock ratio of the processor, as indicated by hardware.  	 No functional impact as a result of this erratum. If the maximum resolved boot frequency as programmed by BIOS is different from the frequency implied by the maximum core-clock to bus-clock ratio of the processor as indicated by hardware, then the following effects may be observed: 	 Performance Monitoring Event CPU_CLK_UNHALTED.REF will count at a rate different  than the TSC (Time Stamp Counter) • When running a system with several processors that have different maximum core-clock to bus-clock ratios, CPU_CLK_UNHALTED.REF monitoring events at each processor will be counted at different rates and therefore will not be comparable. • Calculate the ratio of the rates at which the TSC and the CPU_CLK_UNHALTED.REF performance monitoring event count (this can be done by measuring simultaneously their counted value while executing code) and adjust the CPU_CLK_UNHALTED.REF event count to the maximum resolved boot frequency using this ratio. 	  For the steppings affected, see the Summary Tables of Changes. 
  Store Ordering May Be Incorrect between WC and WP Memory Types  	  According to Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, Methods of Caching Available, WP (Write Protected) stores should drain the WC (Write Combining) buffers in the same way as UC (Uncacheable) memory type stores do. Due to this erratum, WP stores may not drain the WC buffers.  	 Memory ordering may be violated between WC and WP stores. 	 None Identified 	  78  For the steppings affected, see the Summary Tables of Changes.   
  (E)CX May Get Incorrectly Updated When Performing Fast String REP STOS with Large Data Structures  	  When performing Fast String REP STOS commands with data structures [(E)CX*Data Size] larger than the supported address size structure (64K for 16-bit address size and 4G for 32-bit address size) some addresses may be processed more than once. After an amount of data greater than or equal to the address size structure has been processed, external events (such as interrupts) will cause the (E)CX registers to be incremented by a value that corresponds to 64K bytes for 16 bit address size and 4G bytes for 32 bit address size.  	 (E)CX may contain an incorrect count which may cause some of the STOS operations to re-execute. Intel has not observed this erratum with any commercially available software. 	 Do not use values in (E)CX that when multiplied by the data size, give values larger than  the address space size (64K for 16-bit address size and 4G for 32-bit address size). 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event BR_INST_RETIRED May Count CPUID Instructions as Branches  	  Performance monitoring event BR_INST_RETIRED (C4H) counts retired branch instructions. Due to this erratum, two of its sub-events mistakenly count for CPUID instructions as well. Those sub events are: BR_INST_RETIRED.PRED_NOT_TAKEN (Umask 01H) and BR_INST_RETIRED.ANY (Umask 00H).  	 The count value returned by the performance monitoring event BR_INST_RETIRED.PRED_NOT_TAKEN or BR_INST_RETIRED.ANY may be higher than expected. The extent of over counting depends on the occurrence of CPUID instructions, while the counter is active. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes.   79  
  Performance Monitoring Event MISALIGN_MEM_REF May Over Count  	  Performance monitoring event MISALIGN_MEM_REF (05H) is used to count the number of memory accesses that cross an 8-byte boundary and are blocked until retirement. Due to this erratum, the performance monitoring event MISALIGN_MEM_REF also counts other memory accesses.  	 The performance monitoring event MISALIGN_MEM_REF may over count. The extent of the over counting depends on the number of memory accesses retiring while the counter is active. 	 None Identified 	  For the steppings affected, see the Summary Tables of Changes. 
  A REP STOS/MOVS to a MONITOR/MWAIT Address Range May Prevent Triggering of the Monitoring Hardware  	  The MONITOR instruction is used to arm the address monitoring hardware for the subsequent MWAIT instruction. The hardware is triggered on subsequent memory store operations to the monitored address range. Due to this erratum, REP STOS/MOVS fast string operations to the monitored address range may prevent the actual triggering store to be propagated to the monitoring hardware.  	 A logical processor executing an MWAIT instruction may not immediately continue program execution if a REP STOS/MOVS targets the monitored address range. 	 Software can avoid this erratum by not using REP STOS/MOVS store operations within  the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  False Level One Data Cache Parity Machine-Check Exceptions May Be Signaled  	  Executing an instruction stream containing invalid instructions/data may generate a false Level One Data Cache parity machine-check exception.  	 The false Level One Data Cache parity machine-check exception is reported as an uncorrected machine-check error. An uncorrected machine-check error is treated as a fatal exception by the operating system and may cause a shutdown and/or reboot. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  80  For the steppings affected, see the Summary Tables of Changes.   
  A Memory Access May Get a Wrong Memory Type Following a #GP due to WRMSR to an MTRR Mask  	  The TLB (Translation Lookaside Buffer) may indicate a wrong memory type on a memory access to a large page (2M/4M Byte) following the recovery from a #GP (General Protection Fault) due to a WRMSR to one of the IA32_MTRR_PHYSMASKn MSRs with reserved bits set.  	 When this erratum occurs, a memory access may get an incorrect memory type leading to unexpected system operation. As an example, an access to a memory mapped I/O device may be incorrectly marked as cacheable, become cached, and never make it to the I/O device. Intel has not observed this erratum with any commercially available software. 	 Software should not attempt to set reserved bits of IA32_MTRR_PHYSMASKn MSRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMI While LBR Freeze Enabled May Result in Old/Out-of-Date LBR Information  	  When Precise Event-Based Sampling (PEBS) is configured with Performance Monitoring Interrupt (PMI) on PEBS buffer overflow enabled and Last Branch Record (LBR) Freeze on PMI enabled by setting FREEZE_LBRS_ON_PMI flag (bit 11) to 1 in IA32_DEBUGCTL (MSR 1D9H), the LBR stack is frozen upon the occurrence of a hardware PMI request. Due to this erratum, the LBR freeze may occur too soon (i.e. before the hardware PMI request).  	 Following a PMI occurrence, the PMI handler may observe old/out-of-date LBR information that does not describe the last few branches before the PEBS sample that triggered the PMI. 	 None identified 	  For the steppings affected, see the Summary Tables of Changes.   81  
  Overlap of an Intel® VT APIC Access Page in a Guest with the DS Save Area May Lead to Unpredictable Behavior  	  Logging of a branch record or a PEBS (precise-event-based-sampling) record to the DS (debug store) save area that overlaps with the APIC access page may lead to unpredictable behavior.  	 Guest software configured to log branch records or PEBS records cannot specify the DS (debug store) save area within the APIC-access page. Under any expected usage model this type of overlap is not expected to exist. One should be aware of the fact that the specified DS address is of linear form while the APIC access page is of a physical form. Any solution that wishes to avoid this condition will need to comprehend the linear-to-physical translation of the DS related address pointers with respect to the mapping of the physical APIC access page to avoid such an overlap. Under normal circumstances for correctly written software, such an overlap is not expected to exist. Intel has not observed this erratum with any commercially available software. 	 For a fully comprehensive workaround, the VMM should not allow the logging of branch or  PEBS records while guest software is running if the "virtualize APIC accesses" VMexecution control is 1. 	  For the steppings affected, see the Summary Tables of Changes. 
  VTPR Write Access during Event Delivery May Cause an APIC-Access VM Exit  	  VTPR write accesses should not cause APIC-access VM exits but instead should cause data to be written to the virtual-APIC page. Due to this erratum, a VTPR write access during event delivery may cause an APIC-access VM exit with no data being written to the virtual-APIC page.  	 VTPR accesses are accesses to offset 80H on the APIC-access page. VTPR write accesses can occur during event delivery when pushing data on the stack. Because event delivery performs multiple stack pushes, an event delivery that includes a VTPR write access will also include at least one other write to the APIC-access page. That other write will cause an APIC-access VM exit. Thus, even in the presence of this erratum, any event delivery that includes a VTPR write access will cause an APICaccess VM exit. The only difference with respect to correct behavior will be with regard to page offset saved in the exit qualification by the APIC-access VM exit. A VMM should be able to emulate the event delivery correctly even with the incorrect offset. 	 The VMM should emulate any event delivery that causes an APIC-access VM exit in the  same way regardless of the offset saved in the exit qualification. 	  82  For the steppings affected, see the Summary Tables of Changes.   
  BIST Failure after Reset  	  The processor may show an erroneous BIST (built-in self test) result in bit [17] of EAX register when coming out of reset.  	 When this erratum occurs, an erroneous BIST failure will be reported in EAX bit [17]. This failure can be ignored since it is not accurate. 	 It is possible for BIOS to workaround this erratum by masking off bit [17] of the EAX  register after coming out of reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	 The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause a Livelock During Snoops of the L1 Data Cache  	  A livelock may be observed in rare conditions when instruction fetch causes multiple level one data cache snoops.  	 Due to this erratum, a livelock may occur. Intel has not observed this erratum with any commercially available software. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   83  
  Use of Memory Aliasing with Inconsistent Memory Type may Cause a System Hang or a Machine Check Exception  	  Software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (MCE). This would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. If the cacheable address finds its way into the instruction cache, and the non-cacheable address is fetched in the IFU, the processor may invalidate the noncacheable address from the fetch unit. Any micro-architectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and lack of it will cause a system hang or an MCE.  	 This erratum has not been observed with commercially available software. 	 Although it is possible to have a single physical page mapped by two different linear  addresses with different memory types, Intel has strongly discouraged this practice as it may lead to undefined results. Software that needs to implement memory aliasing should manage the memory type consistency 	  For the steppings affected, see the Summary Tables of Changes. 
  A WB Store Following a REP STOS/MOVS or FXSAVE May Lead to Memory-Ordering Violations  	  Under certain conditions, as described in the Software Developers Manual section "Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors", the processor may perform REP MOVS or REP STOS as write combining stores (referred to as “fast strings”) for optimal performance. FXSAVE may also be internally implemented using write combining stores. Due to this erratum, stores of a WB (write back) memory type to a cache line previously written by a preceding fast string/FXSAVE instruction may be observed before string/FXSAVE stores.  	 A write-back store may be observed before a previous string or FXSAVE related store. Intel has not observed this erratum with any commercially available software. 	 Software desiring strict ordering of string/FXSAVE operations relative to subsequent  write-back stores should add an MFENCE or SFENCE instruction between the string/FXSAVE operation and following store-order sensitive code such as that used for synchronization. 	  84  For the steppings affected, see the Summary Tables of Changes.   
  VM Exit with Exit Reason “TPR Below Threshold” Can Cause the Blocking by MOV/POP SS and Blocking by STI Bits to Be Cleared in the Guest Interruptibility-State Field  	  As specified in Section, “VM Exits Induced by the TPR Shadow”, in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, a VM exit occurs immediately after any VM entry performed with the “use TPR shadow", "activate secondary controls”, and “virtualize APIC accesses” VM-execution controls all set to 1 and with the value of the TPR shadow (bits 7:4 in byte 80H of the virtual-APIC page) less than the TPR-threshold VM-execution control field. Due to this erratum, such a VM exit will clear bit 0 (blocking by STI) and bit 1 (blocking by MOV/POP SS) of the interruptibility-state field of the guest-state area of the VMCS (bit 0 - blocking by STI and bit 1 - blocking by MOV/POP SS should be left unmodified).  	 Since the STI, MOV SS, and POP SS instructions cannot modify the TPR shadow, bits 1:0 of the interruptibility-state field will usually be zero before any VM entry meeting the preconditions of this erratum; behavior is correct in this case. However, if VMM software raises the value of the TPR-threshold VM-execution control field above that of the TPR shadow while either of those bits is 1, incorrect behavior may result. This may lead to VMM software prematurely injecting an interrupt into a guest. Intel has not observed this erratum with any commercially available software. 	 VMM software raising the value of the TPR-threshold VM-execution control field should  compare it to the TPR shadow. If the threshold value is higher, software should not perform a VM entry; instead, it could perform the actions that it would normally take in response to a VM exit with exit reason “TPR below threshold”. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using Memory Type Aliasing with Cacheable and WC Memory Types May Lead to Memory Ordering Violations  	  Memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory types. Memory type aliasing with a cacheable memory type and WC (write combining) may cause the processor to perform incorrect operations leading to memory ordering violations for WC operations.  	 Software that uses aliasing between cacheable and WC memory types may observe memory ordering errors within WC memory operations. Intel has not observed this erratum with any commercially available software. 	 None identified. Intel does not support the use of cacheable and WC memory type  aliasing, and WC operations are defined as weakly ordered. 	  For the steppings affected, see the Summary Tables of Changes.   85  
  RSM Instruction Execution under Certain Conditions May Cause Processor Hang or Unexpected Instruction Execution Results  	  RSM instruction execution, under certain conditions triggered by a complex sequence of internal processor micro-architectural events, may lead to processor hang, or unexpected instruction execution results.  	 In the above sequence, the processor may live lock or hang, or RSM instruction may restart the interrupted processor context through a nondeterministic EIP offset in the code segment, resulting in unexpected instruction execution, unexpected exceptions or system hang. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. Please contact your  Intel sales representative for availability. 	  For the steppings affected, see the Summary Tables of Changes. 
  NMIs May Not Be Blocked by a VM-Entry Failure  	  The Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2 specifies that, following a VM-entry failure during or after loading guest state, “the state of blocking by NMI is what it was before VM entry.” If non-maskable interrupts (NMIs) are blocked and the “virtual NMIs” VMexecution control set to 1, this erratum may result in NMIs not being blocked after a VM-entry failure during or after loading guest state.  	 VM-entry failures that cause NMIs to become unblocked may cause the processor to deliver an NMI to software that is not prepared for it. 	 VMM software should configure the virtual-machine control structure (VMCS) so that VM-  entry failures do not occur. 	  For the steppings affected, see the Summary Tables of Changes. 
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, Exception and Interrupt Reference, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. However due to this erratum, only Contributory Exceptions and Page Faults will cause a triple fault shutdown, whereas a benign exception may not.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  86  For the steppings affected, see the Summary Table of Changes.   
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code  accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary.   87   	  For the steppings affected, see the Summary Table of Changes. 
  Under an unlikely and complex sequence of conditions in 64-bit mode, a register IP-relative instruction result may be incorrect.  	  Under an unlikely and complex sequence of conditions in 64-bit mode, a register IPrelative instruction result may be incorrect.  	 A register IP-relative instruction result may be incorrect and could cause software to read from or write to an incorrect memory location. This may result in an unexpected page fault or unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  88  For the steppings affected, see the Summary Table of Changes.    Erratum Affecting Only Intel® Core™2 Duo Mobile Processors on Mobile Intel® 965 Express Chipset Family
  VM Exit Due to Virtual APIC-Access May Clear RF  	  RF (Resume Flag), bit 16 of the EFLAGS/RFLAGS register, is used to restart instruction execution without getting an instruction breakpoint on the instruction following a debug breakpoint exception. Due to this erratum, in a system supporting Intel® Virtualization Technology, when a VM Exit occurs due to Virtual APIC-Access (Advanced Programmable Interrupt Controller-Access) the EFLAGS/RFLAGS saved in the VMCS (Virtual-Machine Control Structure) may contain an RF value of 0.  	 When this erratum occurs, following a VM Exit due to a Virtual APIC-access, the processor may unintentionally break on the subsequent instruction after VM entry. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMCALL Failure Due to Corrupt MSEG Location May Cause VM Exit to Load the Machine State Incorrectly  	  In systems supporting Intel Virtualization Technology, if a VMCALL failure occurs due to a corrupt Monitor Segment (MSEG), subsequent VM Exits may load machine state incorrectly.  	 Occurrence of this erratum may result in a VMX abort. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
 and MSR_PERF_FIXED_CTR2(30BH) are Note Cleared When the Processor Is Reset  	  The Fixed Function Performance Counters that count the number of core cycles and reference cycles when the core is not in a halt state are not cleared when the processor is reset.  	 The MSR_PERF_FIXED_CTR1 and MSR_PERF_FIXED_CTR2 counters may contain unexpected values after reset. 	 BIOS can workaround this erratum by clearing the counters at processor initialization  time. 	  For the steppings affected, see the Summary Tables of Changes.   89  
  Multi-Core Processors Configured for Single Core Operation May Not Be Able to Enter Intel® Enhanced Deeper Sleep  	  BIOS may contain the option to disable CMP (Core Multiple Processing). Disabling CMP configures a processor for single core operation. Due to this erratum, a multi-core processor operating with CMP disabled may not be able to enter Intel® Enhanced Deeper Sleep if a SIPI (Start-up Inter-Processor Interrupt) is sent to the disabled processor.  	 When this erratum occurs, the processor may not be able to enter the Intel® Enhanced Deeper Sleep and therefore may consume more power than expected. Intel has not observed this erratum with any commercially available system or software. 	 None Identified 	  For the affected steppings, see the Summary Tables of Changes 
  VTPR Access May Lead to System Hang  	  The logical processor may hang if an instruction performs a VTPR access and the next instruction to be executed is located on a different code page.  	 Software running VMX non-root operation may cause a logical processor to hang if the virtual-machine monitor (VMM) sets both the “use TPR shadow” and “virtualize APIC accesses” VM-execution controls. 	 It is possible for the BIOS to contain a workaround for this erratum 	  90  For the affected steppings, see the Summary Tables of Changes   
  Activation of Intel® Adaptive Thermal Monitor While Intel® Dynamic Front Side Bus Frequency Switching Is Active May Lead to an Incorrect Operating Point Frequency  	  Intel Adaptive Thermal Monitor has the ability to use multiple frequency/voltage operating points to cool the processor while maintaining a high level of performance. If Intel Dynamic Front Side Bus Frequency Switching is active, activation of the Intel Adaptive Thermal Monitor may transition the processor to the correct operating point voltage, but not frequency. This may occur if: 1.) The software/OS requests to go to a higher performance Enhanced Intel SpeedStep® Technology operating point during the thermal monitor activation period. 2.) An entry into C4 state or Intel Enhanced Deeper Sleep interrupts the transition between the Intel Dynamic Front Side Bus Frequency Switching frequency and the targeted thermal monitor operating point frequency.  	 If this erratum occurs, the Intel Dynamic Front Side Bus Frequency Switching operating point frequency will be observed along with the Intel Adaptive Thermal Monitor operating point voltage. The performance state status register (IA32_PERF_STS) will reflect this intermediate performance state. There is no functional impact; the eventual voltage/frequency selection is a valid operating point. De-activation of the Intel Adaptive Thermal Monitor will result in the processor transitioning to the expected Enhanced Intel SpeedStep Technology operating point. 	 None Identified 	NA
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary, since the MOV SS/POP SS and the following instruction should be executed atomically.  	  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software or system.  	 As recommended in the IA32 Intel® Architecture Software Developer's Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   19 
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1.  MOV or POP instruction to SS (Stack Segment) selector.  2.  Next instruction is FP (Floating Point) that gets FP assist.  3.  Another instruction after the FP instruction completes successfully.  4. A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4. 	  Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints.  	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes. 
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a non-canonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  20  For the steppings affected, see the Summary Tables of Changes.  
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	  The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A: System Programming Guide, Part 1, in the section titled “Switching to Protected Mode” recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	  The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6.B0-B3 May Not Report All Breakpoints Matched When a MOV/POP SS is Followed by a Store or an MMX Instruction  	  Normally, data breakpoints matches that occur on a MOV SS, r/m or POP SS will not cause a debug exception immediately after MOV/POP SS but will be delayed until the instruction boundary following the next instruction is reached. After the debug exception occurs, DR6.B0-B3 bits will contain information about data breakpoints matched during the MOV/POP SS as well as breakpoints detected by the following instruction. Due to this erratum, DR6.B0-B3 bits may not contain information about data breakpoints matched during the MOV/POP SS when the following instruction is either an MMX instruction that uses a memory addressing mode with an index or a store instruction.  	  When this erratum occurs, DR6 may not contain information about all breakpoints matched. This erratum will not be observed under the recommended usage of the MOV SS,r/m or POP SS instructions (i.e., following them only with an instruction that writes (E/R)SP).  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   21 
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  	  Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to “Procedure Calls For Block-Structured Languages” in IA-32 Intel® Architecture Software Developer's Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.  
  Faulting MMX Instruction May Incorrectly Update x87 FPU Tag Word  	  Under a specific set of conditions, MMX stores (MOVD, MOVQ, MOVNTQ, MASKMOVQ) which cause memory access faults (#GP, #SS, #PF, or #AC), may incorrectly update the x87 FPU tag word register. This erratum will occur when the following additional conditions are also met: •The MMX store instruction must be the first MMX instruction to operate on x87 FPU state (i.e. the x87 FP tag word is not already set to 0x0000). •For MOVD, MOVQ, MOVNTQ stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to MASKMOVQ).  	  If the erratum conditions are met, the x87 FPU tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.  	 None identified 	  For the steppings affected, see the Summary Tables of Changes. 
  FREEZE_WHILE_SMM Does Not Prevent Event From Pending PEBS During SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if: 1.  A performance counter overflowed before an SMI.  2. A PEBS record has not yet been generated because another count of the event has not occurred. 3. The monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM. 	  A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g. Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	  Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler's stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	  An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM's location 7FA4H is set to “1” by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: •A non-I/O instruction •SMI is pending while a lower priority event interrupts •A REP I/O read •A I/O read that redirects to MWAIT  	  SMM handlers may get false IO_SMI indication.  	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	  In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame.  	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	  The values of the LER MSRs may be unreliable.  	 None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.  
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1's. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes.   25 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	  With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS Record not Updated when in Probe Mode  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflows of the counter can result in storage of a PEBS record in the PEBS buffer. Due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new PEBS record may not be added to the PEBS buffer.  	  Due to this erratum, the PEBS buffer may not be updated by overflows that occur during probe mode.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	  The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.  
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions as described in the Software Developers Manual section “Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	  Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	  Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type.  	 Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	  When this erratum occurs, #DB will be incorrectly handled as follows: •#DB is signaled before the pending higher priority #MF (Interrupt 16). •#DB is generated twice on the same instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   27 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	  When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to “NMI-Window Exiting” May Be Delayed by One Instruction  	  If VM entry is executed with the “NMI-window exiting” VM-execution control set to 1, a VM exit with exit reason “NMI window” should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	  VMM software using “NMI-window exiting” for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	  Software may observe #MF being signaled before pending interrupts are serviced.  	 None identified. 	  28  For the steppings affected, see the Summary Tables of Changes.  
  Values for LBR/BTS/BTM Will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unsupported PCIe* Upstream Access May Complete with an Incorrect Byte Count  	  PCIe* Upstream IO and Configuration accesses are not supported. If an IO or Configuration request is received upstream, the integrated PCIe controller will treat it as an unsupported request, the request will be dropped, and a completion will be sent with the UR (Unsupported Request) completion status. This completion, according to the PCIe specification, should indicate a byte count of 4. Due to this erratum, the byte count is set to the same byte count as the offending request.  	  The processor response to an unsupported PCIe access may not fully comply to the PCIe specification.  	 PCIe agents should not issue unsupported accesses. 	  For the steppings affected, see the Summary Tables of Changes. 
  Malformed PCIe* Transactions May be Treated as Unsupported Requests Instead of as Critical Errors  	  PCIe MSG/MSG_D TLPs (Transaction Layer Packets) with incorrect Routing Code as well as the deprecated TCfgRD and TCfgWr types should be treated as malformed transactions leading to a critical error. Due to this erratum, the integrated PCIe controller's root ports may treat such messages as UR (Unsupported Requests).  	  Legacy malformed PCIe transactions may be treated as UR instead of as critical errors.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29 
  PCIe* Root Port May Not Initiate Link Speed Change  	  PCIe specification rev 2.0 requires the upstream component to maintain the PCIe link at the target link speed or the highest speed supported by both components on the link, whichever is lower. PCIe root port will not initiate the link speed change without being triggered by the software. System BIOS will trigger the link speed change under normal boot scenarios. However, BIOS is not involved in some scenarios such as link disable/re-enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. This erratum does not affect the ability of the downstream component to initiate a link speed change. All known 5.0Gb/ s-capable PCIe downstream components have been observed to initiate the link speed change without relying on the root port to do so.  	  Due to this erratum, the PCIe root port may not initiate a link speed change during some hardware scenarios causing the PCIe link to operate at a lower than expected speed. Intel has not observed this erratum with any commercially available platform.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR or XSAVE/XRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the FXSAVE or XSAVE image or a partial memory state restore of the FXRSTOR or XRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR or XSAVE/XRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	  Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected.  	 None identified. 	  30  For the steppings affected, see the Summary Tables of Changes.  
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in an operating system which may run 16-bit FP code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  Spurious Interrupts May be Generated From the Intel® VT-d Remap Engine  	  If software clears the F (Fault) bit 127 of the Fault Recording Register (FRCD_REG at offset 0x208 in Remap Engine BAR) by writing 1b through RW1C command (Read Write 1 to Clear) when the F bit is already clear then a spurious interrupt from Intel® VT-d (Intel® Virtualization Technology for Directed I/O) Remap Engine may be observed.  	  Due to this erratum, spurious interrupts will occur from the Intel VT-d Remap Engine following RW1C clearing F bit.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   31 
  Fault Not Reported When Setting Reserved Bits of Intel® VT-d Queued Invalidation Descriptors  	  Reserved bits in the Queued Invalidation descriptors of Intel VT-d (Virtualization Technology for Directed I/O) are expected to be zero, meaning that software must program them as zero while the processor checks if they are not zero. Upon detection of a non-zero bit in a reserved field, an Intel VT-d fault should be recorded. Due to this erratum, the processor does not check reserved bit values for Queued Invalidation descriptors.  	  Due to this erratum, faults will not be reported when writing to reserved bits of Intel VT-d Queued Invalidation Descriptors.  	 None identified 	  For the steppings affected, see the Summary Tables of Changes. 
  VPHMINPOSUW Instruction in Vex Format Does Not Signal #UD When vex.vvvv !=1111b  	  Processor does not signal #UD fault when executing the reserved instruction VPHMINPOSUW with vex.vvvv !=1111b.  	  Executing VPHMINPOSUW with vex.vvvv !=1111b results in the same behavior as executing with vex.vvvv=1111b.  	 Software should not use VPHMINPOSUW with vex.vvvv !=1111b, in order to ensure future compatibility. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTM or BTS Records May have Incorrect Branch From Information After an EIST/T-state/S-state/C1E Transition or Adaptive Thermal Throttling  	  The “From” address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after a transition of: • EIST (Enhanced Intel® SpeedStep Technology). • T-state (Thermal Monitor states). • S1-state (ACPI package sleep state). • C1E (Enhanced C1 Low Power state). • Adaptive Thermal Throttling.  	  When the LBRs, BTM or BTS are enabled, some records may have incorrect branch “From” addresses for the first branch after a transition of EIST, T-states, S-states, C1E, or Adaptive Thermal Throttling.  	 None identified. 	  32  For the steppings affected, see the Summary Tables of Changes.  
  VMREAD/VMWRITE Instruction May Not Fail When Accessing an Unsupported Field in VMCS  	  The Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 2B states that execution of VMREAD or VMWRITE should fail if the value of the instruction's register source operand corresponds to an unsupported field in the VMCS (Virtual Machine Control Structure). The correct operation is that the logical processor will set the ZF (Zero Flag), write 0CH into the VM-instruction error field and for VMREAD leave the instruction's destination operand unmodified. Due to this erratum, the instruction may instead clear the ZF, leave the VM-instruction error field unmodified and for VMREAD modify the contents of its destination operand.  	  Accessing an unsupported field in VMCS will fail to properly report an error. In addition, VMREAD from an unsupported VMCS field may unexpectedly change its destination operand. Intel has not observed this erratum with any commercially available software.  	 Software should avoid accessing unsupported fields in a VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  Clock Modulation Duty Cycle Cannot be Programmed to 6.25%  	  When programming field T_STATE_REQ of the IA32_CLOCK_MODULATION MSR (19AH) bits [3:0] to '0001, the actual clock modulation duty cycle will be 12.5% instead of the expected 6.25% ratio.  	  Due to this erratum, it is not possible to program the clock modulation to a 6.25% duty cycle.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for VEX.vvvv May Produce a #NM Exception  	  The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (InvalidOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to this erratum, if CR0.TS is “1”, the processor may instead produce a #NM (Device-NotAvailable) exception.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should always set the vvvv field of the VEX prefix to 1111b for instances of the VAESIMC and VAESKEYGENASSIST instructions. 	  For the steppings affected, see the Summary Tables of Changes.   33 
  Memory Aliasing of Code Pages May Cause Unpredictable System Behavior  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncachable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	  If this erratum occurs, the system may have unpredictable behavior, including a system hang. The aliasing of memory regions, a condition necessary for this erratum to occur, is documented as being unsupported in the Intel 64 and IA-32 Intel® Architecture Software Developer's Manual, Volume 3A, in the section titled Programming the PAT. Intel has not observed this erratum with any commercially available software or system.  	 Code pages should not be mapped with uncacheable and cacheable memory types at the same time. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express* Graphics Receiver Error Reported When Receiver With L0s Enabled and Link Retrain Performed  	  If the Processor PCI Express* root port is the receiver with L0s enabled and the root port itself initiates a transition to the recovery state via the retrain link configuration bit in the 'Link Control' register (Bus 0; Device 1; Functions 0, 1, 2 and Device 6; Function 0; Offset B0H; bit 5), then the root port may not mask the receiver or bad DLLP (Data Link Layer Packet) errors as expected. These correctable errors should only be considered valid during PCIe configuration and L0 but not L0s. This causes the processor to falsely report correctable errors in the 'Device Status' register (Bus 0; Device 1; Functions 0, 1, 2 and Device 6; Function 0; Offset AAH; bit 0) upon receiving the first FTS (Fast Training Sequence) when exiting Receiver L0s. Under normal conditions there is no reason for the Root Port to initiate a transition to Recovery. Note: This issue is only exposed when a recovery event is initiated by the processor.  	  The processor does not comply with the PCI Express 2.0 Specification. This does not impact functional compatibility or interoperability with other PCIe devices.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VZEROALL/VZEROUPPER  	  Execution of the VZEROALL or VZEROUPPER instructions in 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.  	 Compilers should encode VEX.W = 0 for executions of the VZEROALL and VZEROUPPER instructions in 64-bit mode to ensure future compatibility. 	  34  For the steppings affected, see the Summary Tables of Changes.  
  Perfmon Event LD_BLOCKS.STORE_FORWARD May Overcount  	  Perfmon LD_BLOCKS.STORE_FORWARD (event 3H, umask 01H) may overcount in the cases of 4KB address aliasing and in some cases of blocked 32-byte AVX load operations. 4KB address aliasing happens when unrelated load and store that have different physical addresses appear to overlap due to partial address check done on the lower 12 bits of the address. In some cases, such memory aliasing can cause load execution to be significantly delayed. Blocked AVX load operations refer to 32-byte AVX loads that are blocked due to address conflict with an older store.  	  The perfmon event LD_BLOCKS.STORE_FORWARD may overcount for these cases.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Conflict Between Processor Graphics Internal Message Cycles And Graphics Reads From Certain Physical Memory Ranges May Cause a System Hang  	  Processor Graphics internal message cycles occurring concurrently with a physical memory read by graphics from certain memory ranges may cause memory reads to be stalled resulting in a system hang. The following physical page (4K) addresses cannot be assigned to Processor Graphics: 00_2005_0xxx, 00_2013_0xxx, 00_2013_8xxx and 00_4000_4xxx.  	  Due to this erratum, accesses by the graphics engine to the defined memory ranges may cause memory reads to be stalled, resulting in a system hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of Opcode 9BH with the VEX Opcode Extension May Produce a #NM Exception  	  Attempt to use opcode 9BH with a VEX opcode extension should produce a #UD (Invalid-Opcode) exception. Due to this erratum, if CR0.MP and CR0.TS are both 1, the processor may produce a #NM (Device-Not-Available) exception if one of the following conditions exists: •66H, F2H, F3H or REX as a preceding prefix. •An illegal map specified in the VEX.mmmmm field.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should not use opcode 9BH with the VEX opcode extension. 	  For the steppings affected, see the Summary Tables of Changes.   35 
  Executing The GETSEC Instruction While Throttling May Result in a Processor Hang  	  If the processor throttles, due to either high temperature thermal conditions or due to an explicit operating system throttling request (TT1), while executing GETSEC[SENTER] or GETSEC[SEXIT] instructions, then under certain circumstances, the processor may hang. Intel has not been observed this erratum with any commercially available software.  	  Possible hang during execution of GETSEC instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to the IA32_FIXED_CTR1 MSR May Result in Incorrect Value in Certain Conditions  	  Under specific internal conditions, if software tries to write the IA32_FIXED_CTR1 MSR (30AH) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (i.e. its value was 0xFFFF FFFF FFFF), then due to this erratum the new value in the MSR may be corrupted.  	  Due to this erratum, IA32_FIXED_CTR1 MSR may be written with a corrupted value.  	 Software may avoid this erratum by writing zeros to the IA32_FIXED_CTR1 MSR, before the desired write operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause Machine Check if Page Size and Memory Type Was Changed Without Invalidation  	  This erratum may cause a machine-check error (IA32_MCi_STATUS.MCACOD=0150H) on the fetch of an instruction that crosses a 4-KByte address boundary. It applies only if (1) the 4-KByte linear region on which the instruction begins is originally translated using a 4-KByte page with the WB memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-MByte, 4-MByte, or 1GByte) with the UC memory type; and (3) the instruction fetch occurs after the pagingstructure modification but before software invalidates any TLB entries for the linear region.  	  Due to this erratum, an unexpected machine check with error code 0150H may occur, possibly resulting in a shutdown. Intel has not observed this erratum with any commercially available software.  	 Software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. It can instead use the following algorithm: first clear the P flag in the relevant paging-structure entry (e.g., PDE); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the P flag and establish the new page size and memory type. 	  36  For the steppings affected, see the Summary Tables of Changes.  
  Reception of Certain Malformed Transactions May Cause PCIe* Port to Hang Rather Than Reporting an Error  	  If the processor receives an upstream malformed non posted packet for which the type field is IO, Configuration or the deprecated TCfgRd and the format is 4 DW header, then due to this erratum the integrated PCIe controller may hang instead of reporting the malformed packet error or issuing an unsupported request completion transaction.  	  Due to this erratum, the processor may hang without reporting errors when receiving a malformed PCIe transaction. Intel has not observed this erratum with any commercially available device.  	 None identified. Upstream transaction initiators should avoid issuing unsupported requests with 4 DW header formats. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* LTR Incorrectly Reported as Being Supported  	  LTR (Latency Tolerance Reporting) is a new optional feature specified in PCIe rev. 2.1. The processor reports LTR as supported in LTRS bit in DCAP2 register (bus 0; Device 1; Function 0; offset 0xc4), but this feature is not supported.  	  Due to this erratum, LTR is always reported as supported by the LTRS bit in the DCAP2 register.  	 None the identified. 	  For steppings affected, see the Summary Tables of Changes. 
  Performance-Counter Overflow Indication May Cause Undesired Behavior  	  Under certain conditions (listed below) when a performance counter overflows, its overflow indication may remain set indefinitely. This erratum affects the generalpurpose performance counters IA32_PMC{0-7} and the fixed-function performance counters IA32_FIXED_CTR{0-2}. The erratum may occur if any of the following conditions are applied concurrent to when an actual counter overflow condition is reached: 1. Software disables the counter either globally through the IA32_PERF_GLOBAL_CTRL MSR (38FH), or locally through the IA32_PERFEVTSEL{0-7} MSRs (186H-18DH), or the IA32_FIXED_CTR_CTRL MSR (38DH). 2. Software sets the IA32_DEBUGCTL MSR (1D9H) FREEZE_PERFMON_ON_PMI bit [12]. 3. The processor attempts to disable the counters by updating the state of the IA32_PERF_GLOBAL_CTRL MSR (38FH) as part of transitions such as VM exit, VM entry, SMI, RSM, or processor C-state.  	  Due to this erratum, the corresponding overflow status bit in IA32_PERF_GLOBAL_STATUS MSR (38DH) for an affected counter may not get cleared when expected. If a corresponding counter is configured to issue a PMI (performance monitor interrupt), multiple PMIs may be signaled from the same overflow condition. Likewise, if a corresponding counter is configured in PEBS mode (applies to only the general purpose counters), multiple PEBS events may be signaled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   37 
  XSAVE Executed During Paging-Structure Modification May Cause Unexpected Processor Behavior  	  Execution of XSAVE may result in unexpected behavior if the XSAVE instruction writes to a page while another logical processor clears the dirty flag or the accessed flag in any paging-structure entry that maps that page.  	  This erratum may cause unpredictable system behavior. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  C-state Exit Latencies May be Higher Than Expected  	  Core C-state exit can be delayed if a P-state transition is requested before the pending C-state exit request is completed. Under certain internal conditions the core C-state exit latencies may be over twice the value specified in the Intel® 64 and IA-32 Architectures Optimization Reference Manual.  	  While typical exit latencies are not impacted, the worst case core C-state exit latency may be over twice the value specified in the Intel® 64 and IA-32 Architectures Optimization Reference Manual and may lead to a delay in servicing interrupts. Intel has not observed any system failures due to this erratum.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  MSR_Temperature_Target May Have an Incorrect Value in the Temperature Control Offset Field  	  Under certain conditions the value in MSR_Temperature_Target (1A2H) bits [15:8] (Temperature Control Offset) may indicate a temperature up to 25 degrees higher than intended.  	  Due to this erratum, fan speed control algorithms that rely on this value may not function as expected  	 It is possible for the BIOS to contain a workaround for this erratum. 	  38  For the steppings affected, see the Summary Tables of Changes.  
  Intel® VT-d Interrupt Remapping Will Not Report a Fault if Interrupt Index Exceeds FFFFH  	  With Intel VT-d (Virtualization Technology for Directed I/O) interrupt remapping, if subhandle valid (bit 3) is set in the address of an interrupt request, the interrupt index is computed as the sum of the interrupt request’s handle and subhandle. If the sum is greater than FFFFH (the maximum possible interrupt-remapping table size), a remapping fault with fault reason 21H should be reported. Due to this erratum, this condition is not reported as a fault. Instead, the low 16 bits of the sum are erroneously used as an interrupt index to access the interrupt-remapping table.  	  If the interrupt index of an interrupt request exceeds FFFFH, a remapping fault with fault reason 21H is not reported and, instead, the request uses the IRTE (interruptremapping table entry) indexed by the low 16 bits of the interrupt index.  	 Software can use requestor-id verification to block the interrupts that would be delivered due to this erratum. Interrupts blocked in this way produce a remapping fault with fault reason 26H. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Link Speed May Not Change From 5.0 GT/s to 2.5 GT/s  	  If a PCI Express device changes its supported PCIe link speed from 5.0 GT/s to 2.5 GT/ s without initiating a speed change request and subsequently the L1 power management mode is entered, further retrains initiated by software will not change speed to 2.5 GT/s.  	  Intel has not observed any PCI Express device that changes supported link speed without actually initiating a speed change.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  L1 Data Cache Errors May be Logged With Level Set to 1 Instead of 0  	  When an L1 Data Cache error is logged in IA32_MCi_STATUS[15:0], which is the MCA Error Code Field, with a cache error type of the format 0000 0001 RRRR TTLL, the LL field may be incorrectly encoded as 01 instead of 00.  	  An error in the L1 Data Cache may report the same LL value as the L2 Cache. Software should not assume that an LL value of 01 is the L2 Cache.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   39 
  An Unexpected Page Fault or EPT Violation May Occur After Another Logical Processor Creates a Valid Translation for a Page  	  An unexpected page fault (#PF) or EPT violation may occur for a page under the following conditions: •The paging structures initially specify no valid translation for the page. •Software on one logical processor modifies the paging structures so that there is a valid translation for the page (e.g., by setting to 1 the present bit in one of the pagingstructure entries used to translate the page). •Software on another logical processor observes this modification (e.g., by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). •Shortly thereafter, software on that other logical processor performs a store to a linear address on the page. In this case, the store may cause a page fault or EPT violation that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). Intel has not observed this erratum with any commercially available software.  	  An unexpected page fault may be reported. There are no other side effects due to this erratum.  	 System software can be constructed to tolerate these unexpected page faults. See Section “Propagation of Paging-Structure Changes to Multiple Processors” of Volume 3A of IA-32 Intel® Architecture Software Developer’s Manual, for recommendations for software treatment of asynchronous paging-structure updates. 	  For the steppings affected, see the Summary Tables of Changes. 
  TSC Deadline Not Armed While in APIC Legacy Mode  	  Under specific timing conditions, when in Legacy APIC Mode, writing to IA32_TSC_DEADLINE MSR (6E0H) may fail to arm the TSC Deadline (Time Stamp Counter Deadline) event as expected. Exposure to this erratum is dependent on the proximity of TSC_Deadline MSR Write to a Timer CCR register read or to a write to the Timer LVT that enabled the TSC Deadline mode (writing 10 to bits [18:17] of Timer LVT).  	  Due to this erratum the expected timer event will either not be generated or will be generated at a wrong time. The TSC Deadline may fail until an LVT write to transition from “TSC Deadline mode” back to “Timer mode” occurs or until the next reset.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Upstream TCfgWr May Cause Unpredictable System Behavior  	  TCfgWr (Trusted Configuration Writes) is a PCIe Base spec deprecated transaction type which should be treated as a malformed packet. If a PCIe upstream TCfgWr request is received, then due to this erratum the request may not be managed as a Malformed Packet.  	  Upstream memory writes subsequent to a TCfgWr transaction may cause unpredictable system behavior. Intel has not observed any PCIe Device that sends such a TCfgWr request.  	 PCIe end points should not initiate upstream TCfgWr requests. 	  40  For the steppings affected, see the Summary Tables of Changes.  
  Processor May Fail to Acknowledge a TLP Request  	  When a PCIe root port’s receiver is in Receiver L0s power state and the port initiates a Recovery event, it will issue Training Sets to the link partner. The link partner will respond by initiating an L0s exit sequence. Prior to transmitting its own Training Sets, the link partner may transmit a TLP (Transaction Layer Packet). Due to this erratum, the root port may not acknowledge the TLP request.  	  After completing the Recovery event, the PCIe link partner will replay the TLP request. The link partner may set a Correctable Error status bit, which has no functional effect.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Executing The GETSEC Instruction While Throttling May Result in a Processor Hang  	  If the processor throttles, due to either high temperature thermal conditions or due to an explicit operating system throttling request (TT1), while executing GETSEC[SENTER] or GETSEC[SEXIT] instructions, then under certain circumstances, the processor may hang.  	  Possible hang during execution of GETSEC instruction. Intel has not been observed this erratum with any commercially available software.  	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PerfMon Event LOAD_HIT_PRE.SW_PREFETCH May Overcount  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH (event 4CH, umask 01H) should count load instructions hitting an ongoing software cache fill request initiated by a preceding software prefetch instruction. Due to this erratum, this event may also count when there is a preceding ongoing cache fill request initiated by a locking instruction.  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH may overcount.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of FXSAVE or FXRSTOR With the VEX Prefix May Produce a #NM Exception  	  Attempt to use FXSAVE or FXRSTOR with a VEX prefix should produce a #UD (InvalidOpcode) exception. If either the TS or EM flag bits in CR0 are set, a #NM (device-notavailable) exception will be raised instead of #UD exception.  	  Due to this erratum a #NM exception may be signaled instead of a #UD exception on an FXSAVE or an FXRSTOR with a VEX prefix.  	 Software should not use FXSAVE or FXRSTOR with the VEX prefix. 	  For the steppings affected, see the Summary Tables of Changes.   41 
  Unexpected #UD on VPEXTRD/VPINSRD  	  Execution of the VPEXTRD or VPINSRD instructions outside of 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions outside 64-bit mode.  	 Software should encode VEX.W = 0 for executions of the VPEXTRD and VPINSRD instructions outside 64-bit mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  Erratum Removed 	NA	NA	NA	NA
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	  Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used.  	 Software can avoid this by: •Avoid using Freeze PerfMon on PMI bit. •Enable only one fixed counter at a time when using Freeze PerfMon on PMI. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions  	  When a 2-byte opcode of a conditional branch (opcodes 0F8xH, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid VEX prefix, it may sometimes signal a #GP fault (illegal instruction length > 15-bytes) instead of a #UD (illegal opcode) fault.  	  Due to this erratum, #GP fault instead of a #UD may be signaled on an illegal instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Read from The APIC-Timer CCR May Disarm The TSC_Deadline Counter  	  When in TSC Deadline mode with TSC_Deadline timer armed (IA32_TSC_DEADLINE<>0, MSR 6E0H), a read from the local APIC’s CCR (current count register) using RDMSR 0839H may disarm the TSC Deadline timer without generating an interrupt as specified in the APIC Timer LVT (Local Vector Table) entry.  	  Due to this erratum, unexpected disarming of the TSC_Deadline counter and possible loss of an interrupt may occur.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  42  For the steppings affected, see the Summary Tables of Changes.  
  An Unexpected PMI May Occur After Writing a Large Value to IA32_FIXED_CTR2  	  If the fixed-function performance counter IA32_FIXED_CTR2 MSR (30BH) is configured to generate a performance-monitor interrupt (PMI) on overflow and the counter’s value is greater than FFFFFFFFFFC0H, then this erratum may incorrectly cause a PMI if software performs a write to this counter.  	  A PMI may be generated unexpectedly when programming IA32_FIXED_CTR2. Other than the PMI, the counter programming is not affected by this erratum as the attempted write operation does succeed.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  RDMSR From The APIC-Timer CCR May Disarm The APIC Timer in TSC Deadline Mode  	  When in TSC Deadline mode with TSC_Deadline timer armed (IA32_TSC_DEADLINE<>0, MSR 6E0H), a read from the local APIC’s CCR (current count register) in APIC MMIO space may disarm the TSC Deadline timer without generating an interrupt as specified in the APIC Timer LVT (Local Vector Table) entry.  	  Due to this erratum, unexpected disarming of the APIC timer and possible loss of an interrupt may occur.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes 
  RC6 Entry Can be Blocked by Asynchronous Intel® VT-d Flows  	  The graphics Command Streamer can get into a state that will effectively inhibit graphic RC6 (Render C6) power management state entry until render reset occurs. Any asynchronous Intel VT-d (Virtualization Technology for Directed I/O) access to IOTLB can potentially cause graphics Command Streamer to get into this RC6 inhibited state.  	  Average power will increase until RC6 is activated with a render reset.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Repeated PCIe* and/or DMI L1 Transitions During Package Power States May Cause a System Hang  	  Under a complex set of internal conditions when the processor is in a deep power state (package C3, C6 or C7) and the PCIe and/or DMI links are toggling in and out of L1 state, internal states of the processor may become inaccessible resulting in a system hang.  	  Due to this erratum, the system may hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   43 
  Execution of BIST During Cold RESET Will Result in a Machine Check Shutdown  	  If BIST (Built In Self-Test) is enabled and a Cold RESET follows, an unrecoverable machine check shutdown will occur.  	  Due to this erratum, BIST cannot be enabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express* Differential Peak-Peak Tx Voltage Swing May Violate the Specification  	  Under certain conditions, including extreme voltage and temperature, the peak-peak voltage may be higher than the specification.  	  Violation of PCI Express Base Specification of the VTX--DIFF-PP voltage. No failures have been observed due to this erratum.  	 None identified. Sugar Bay and Bromolow-WS 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Presence Detect State May Not be Accurate After a Warm Reset  	  Under certain conditions, when there is no PCIe device present, the status of Presence Detect State bit (SLOTSTS Device 1; Function 0,1,2; Offset BAH; bit [6] and/or Device 6; Function 0; Offset BAH; bit [6]) may not be accurate after a warm reset.  	  The Presence Detect State bit may incorrectly report a PCIe device is present even though no device is actually present, which may result in a system hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Display Corruption May be Seen After Graphics Voltage Rail (VCC_AXG) Power Up  	  Powering up the processor graphics logic in the cases of initial poweron or Sx resume state power up may cause a nondeterministic state in the processor graphics logic.  	  This erratum may cause improper 3D rendering and may result in display corruption.  	 A graphics driver workaround has been identified and may be implemented as a workaround for this erratum. 	  44  For the steppings affected, see the Summary Tables of Changes.  
  PCMPESTRI, PCMPESTRM, VPCMPESTRI and VPCMPESTRM Always Operate with 32-bit Length Registers  	  In 64-bit mode, using REX.W=1 with PCMPESTRI and PCMPESTRM or VEX.W=1 with VPCMPESTRI and VPCMPESTRM should support a 64-bit length operation with RAX/ RDX. Due to this erratum, the length registers are incorrectly interpreted as 32-bit values.  	  Due to this erratum, using REX.W=1 with PCMPESTRI and PCMPESTRM as well as VEX.W=1 with VPCMPESTRI and VPCMPESTRM do not result in promotion to 64-bit length registers.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entries That Return From SMM Using VMLAUNCH May Not Update The Launch State of the VMCS  	  Successful VM entries using the VMLAUNCH instruction should set the launch state of the VMCS to “launched”. Due to this erratum, such a VM entry may not update the launch state of the current VMCS if the VM entry is returning from SMM.  	  Subsequent VM entries using the VMRESUME instruction with this VMCS will fail. RFLAGS.ZF is set to 1 and the value 5 (indicating VMRESUME with non-launched VMCS) is stored in the VM-instruction error field. This erratum applies only if dual monitor treatment of SMI and SMM is active.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Interrupt From Local APIC Timer May Not Be Detectable While Being Delivered  	  If the local-APIC timer’s CCR (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the LVT timer register and then reading the bit in the IRR (interrupt-request register) corresponding to the vector in the LVT timer register. If both values are read as 0, no timer interrupt should be in the process of being delivered. Due to this erratum, a timer interrupt may be delivered even if the CCR is 0 and the LVT and IRR bits are read as 0. This can occur only if the DCR (Divide Configuration Register) is greater than or equal to 4. The erratum does not occur if software writes zero to the Initial Count Register before reading the LVT and IRR bits.  	  Software that relies on reads of the LVT and IRR bits to determine whether a timer interrupt is being delivered may not operate properly.  	 Software that uses the local-APIC timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading CCR and the LVT and IRR bits; alternatively, software can avoid the problem by writing zero to the Initial Count Register before reading the LVT and IRR bits. 	  For the steppings affected, see the Summary Tables of Changes.   45 
  An Unexpected Page Fault May Occur Following the Unmapping and Re-mapping of a Page  	  An unexpected page fault (#PF) may occur for a page under the following conditions: •The paging structures initially specify a valid translation for the page. •Software modifies the paging structures so that there is no valid translation for the page (e.g., by clearing to 0 the present bit in one of the paging-structure entries used to translate the page). •Software later modifies the paging structures so that the translation is again a valid translation for the page (e.g., by setting to 1 the bit that was cleared earlier). •A subsequent instruction loads from a linear address on the page. •Software did not invalidate TLB entries for the page between the first modification of the paging structures and the load from the linear address. In this case, the load by the later instruction may cause a page fault that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page).  	  Software may see an unexpected page fault that indicates that there is no translation for the page. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A PCIe* Device That Initially Transmits Minimal Posted Data Credits May Cause a System Hang  	  Under certain conditions, if a PCIe device that initially transmits posted data credits less than Max_Payload_Size/16 + 4 (16B/4DW is unit of data flow control) and is the target of a Peer-to-Peer write of Max_Payload_Size, the system may hang due to Posted Data credit starvation.  	  Under certain conditions, the processor may encounter a Posted Data credit starvation scenario and hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Some Model Specific Branch Events May Overcount  	  Under certain internal conditions the following model specific performance monitoring branch events may overcount: •BR_INST_RETIRED.NOT_TAKEN •BR_INST_RETIRED.NEAR_TAKEN •BR_MISP_RETIRED.NOT_TAKEN •BR_MISP_RETIRED.TAKEN  	  Due to this erratum the events may overcount.  	 None identified. 	  46  For the steppings affected, see the Summary Tables of Changes.  
  Some Performance Monitoring Events in AnyThread Mode May Get Incorrect Count  	  Performance monitoring AnyThread mode allows a given thread to monitor events as a result of any thread running on the same core. Due to this erratum, on systems with SMT enabled, counting any of the following performance monitoring events in AnyThread mode may get incorrect values: •INST_RETIRED; •OTHER_ASSISTS; •UOPS_RETIRED; •MACHINE_CLEARS; •BR_INST_RETIRED; •BR_MISP_RETIRED; •SIMD_INST_RETIRED; •FP_ASSIST; •HW_INTERRUPTS; •ROB_MISC_EVENTS; •MEM_LOAD_RETIRED; •MEM_LOAD_LLC_HIT_RETIRED; •MEM_LOAD_LLC_MISS_RETIRED; •MEM_LOAD_MISC_RETIRED;  	  Incorrect results when counting the above performance monitoring events in AnyThread mode with SMT on.  	 In order to get a correct count for the above events, software may count the same event on both threads of the same physical core, and at post-processing stage sum-up the two values to get the core’s net value. 	  For the steppings affected, see the Summary Tables of Changes. 
  PDIR May Not Function Properly With FREEZE_PERFMON_ON_PMI  	  When the PDIR (Precise Distribution for Instructions Retired) mechanism is activated (INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1 programmed in PEBS mode) along with FREEZE_PERFMON_ON_PMI, bit 11, in the IA32_DEBUGCTL MSR (1D9h), the processor may behave in an undefined manner.  	  Due to this erratum when FREEZE_PERFMON_ON_PMI is programmed along with PDIR the processor behavior is undefined. This can result in any of but not limited to the following: incorrect PMI interrupts, incorrect PEBS events or invalid processor state.  	 A software driver should not program FreezeOnPMI in conjunction with the PDIR mechanism. 	  For the steppings affected, see the Summary Tables of Changes.   47 
  For A Single Logical Processor Package, HTT May be Set to Zero Even Though The Package Reserves More Than One APIC ID  	  When maximum number of addressable IDs for logical processors in this physical package (CPUID.01H.EBX[23:16]) and maximum number of addressable IDs for processor cores in the physical package, (CPUID.04H.EAX[31:26]) indicate more than one reserved APIC ID, HTT(Multi-Threading, CPUID.01H.EDX[28]) should be set to One. However, due to this erratum, it may be set to Zero.  	  Software written expecting HTT to be Zero only when a single APIC ID is reserved for the package may not function correctly.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR May Contain Incorrect Information When Using FREEZE_LBRS_ON_PMI  	  When FREEZE_LBRS_ON_PMI is enabled (bit 11 of IA32_DEBUGCTL MSR (1D9H) is set), and a taken branch retires at the same time that a PMI (Performance Monitor Interrupt) occurs, then under certain internal conditions the record at the top of the LBR stack may contain an incorrect “From” address.  	  When the LBRs are enabled with FREEZE_LRBS_ON_PMI, the “From” address at the top of the LBR stack may be incorrect.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A First Level Data Cache Parity Error May Result in Unexpected Behavior  	  When a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior.  	  Due to this erratum, unpredictable system behavior may occur. Intel has not observed this erratum with any commercially available system.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® Trusted Execution Technology ACM Revocation  	  SINIT ACM 2nd_gen_i5_i7_SINIT_1.9.BIN or earlier are revoked and will not launch with new processor configuration information.  	  Due to this erratum, 2nd_gen_i5_i7_SINIT_1.9.BIN and earlier will be revoked.  	 It is possible for the BIOS to contain a workaround for this erratum. All Intel® TXT enabled software must use SINIT ACM 2nd_gen_i5_i7_SINIT_1.9.BIN or later. 	  48  For the steppings affected, see the Summary Tables of Changes.  
  Programming PDIR And an Additional Precise PerfMon Event May Cause Unexpected PMI or PEBS Events  	  PDIR (Precise Distribution for Instructions Retired) mechanism is activated by programming INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1. When PDIR is activated in PEBS (Precise Event Based Sampling) mode with an additional precise PerfMon event, an incorrect PMI or PEBS event may occur.  	  Due to this erratum, when another PEBS event is programmed along with PDIR, an incorrect PMI or PEBS event may occur.  	 Software should not program another PEBS event in conjunction with the PDIR mechanism. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring May Overcount Some Events During Debugging  	  If the debug-control register (DR7) is configured so that some but not all of the breakpoints in the debug-address registers (DR0-DR3) are enabled and one or more of the following performance-monitoring counters are locally enabled (via IA32_CR_PERMON_EVNTSEL_CNTR{3:0}): BR_INST_RETIRED BR_MISP_RETIRED FP_ASSIST FP_ASSIST INST_RETIRED MACHINE_CLEARS MEM_LOAD_UOPS_LLC_HIT_RETIRED MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS MEM_LOAD_UOPS_RETIRED MEM_TRANS_RETIRED MEM_UOPS_RETIRED OTHER_ASSISTS ROB_MISC_EVENTS.LBR_INSERTS UOPS_RETIRED Any of the globally enabled (via IA32_CR_EMON_PERF_GLOBAL_CTRL) counters may overcount certain events when a disabled breakpoint condition is met  	  Performance-monitor counters may indicate a number greater than the number of events that occurred.  	 Software can disable all breakpoints by clearing DR7. Alternatively, software can ensure that, for a breakpoint disabled in DR7, the corresponding debug-address register contains an address that prevents the breakpoint condition from being met (e.g., a non-canonical address). 	  For the steppings affected, see the Summary Tables of Changes. 
  LTR Message is Not Treated as an Unsupported Request  	  The PCIe* root port does not support LTR (Latency Tolerance Reporting) capability. However, a received LTR message is not treated as a UR (Unsupported Request).  	  Due to this erratum, an LTR message does not generate a UR error.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   49 
  Use of VMASKMOV to Access Memory Mapped I/O or Uncached Memory May Cause The Logical Processor to Hang  	  Under a complex set of conditions, using VMASKMOV to reference memory mapped I/O or uncached memory may cause the logical processor to hang.  	  Due to this erratum, the logical processor may hang. Intel's Software Developers Manual states "VMASKMOV should not be used to access memory mapped I/O and uncached memory as the access and the ordering of the individual loads or stores it does is implementation specific." Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS May Unexpectedly Signal a PMI After The PEBS Buffer is Full  	  The Software Developer’s Manual states that no PMI should be generated when PEBS index reaches PEBS Absolute Maximum. Due to this erratum a PMI may be generated even though the PEBS buffer is full.  	  PEBS may trigger a PMI even though the PEBS index has reached the PEBS Absolute Maximum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  XSAVEOPT May Fail to Save Some State after Transitions Into or Out of STM  	  The XSAVEOPT instruction may optimize performance by not saving state that has not been modified since the last execution of XRSTOR. This optimization should occur only if the executions of XSAVEOPT and XRSTOR are either both or neither in SMM (systemmanagement mode). Due to this erratum, this optimization may be performed by the first execution of XSAVEOPT after a transition into or out of the STM (SMM-transfer monitor) if the most recent execution of XRSTOR occurred before that transition. For transitions into the STM, the erratum applies only to transitions using the VMCALL instruction. This erratum can occur only if the two executions are at the same privilege level, use the same linear address, and are either both or neither in VMX non-root operation. The erratum does not apply if software in SMM never uses XRSTOR or XSAVEOPT.  	  This erratum may lead to unpredictable system behavior.  	 STM software should execute the XRSTOR instruction with the value 0 in EDX:EAX after each transition into the STM (after setting CR4.OSXSAVE) and before each transition out of the STM. Bytes 512 to 575 of the save area used by XRSTOR should be allocated in memory, but bytes 0 to 511 need not be. Bytes 512 to 535 should all be 0. 	  50  For the steppings affected, see the Summary Tables of Changes.  
  Performance Monitor Precise Instruction Retired Event May Present Wrong Indications  	  When the PDIR (Precise Distribution for Instructions Retired) mechanism is activated (INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1 programmed in PEBS mode), the processor may return wrong PEBS/PMI interrupts and/or incorrect counter values if the counter is reset with a SAV below 100 (Sample-After-Value is the counter reset value software programs in MSR IA32_PMC1[47:0] in order to control interrupt frequency).  	  Due to this erratum, when using low SAV values, the program may get incorrect PEBS or PMI interrupts and/or an invalid counter state.  	 The sampling driver should avoid using SAV<100. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Value in IA32_MC3_ADDR MSR May Not be Accurate When MCACOD 0119H is Reported in IA32_MC3_Status  	  Under certain conditions, when the The Machine Check Error Code (MCACOD) in the IA32_MC3_STATUS (MSR 040DH) register is 0119H, the value in IA32_MC3_ADDR MSR (40EH) may refer to the incoming MLC (Mid-Level Cache) cache line instead of the evicted cache line.  	  The address in IA32_MC3_ADDR MSR (40EH) may not be accurate for MLC cache read errors with MSCOD of 119H.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MSR_PKG_Cx_RESIDENCY MSRs May Not be Accurate  	  If the processor is in a package C-state for an extended period of time (greater than 40 seconds) with no wake events, the value in the MSR_PKG_C{2,3,6,7}_RESIDENCY MSRs (60DH and 3F8H–3FAH) will not be accurate.  	  Utilities that report C-state residency times will report incorrect data in cases of long duration package C-states.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Enabling/Disabling PEBS May Result in Unpredictable System Behavior  	  Under certain conditions, enabling or disabling PEBS (Precise Event Based Sampling) via WRMSR to IA32_PEBS_ENABLE MSR may result in unpredictable system behavior near or coincident to this instruction.  	  Due to this erratum, unpredictable system behavior may result.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   51 
  Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for VEX.vvvv May Produce a #NM Exception  	  The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (InvalidOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to this erratum, if CR0.TS is “1”, the processor may instead produce a #NM (Device-NotAvailable) exception.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should always set the vvvv field of the VEX prefix to 1111b for instances of the VAESIMC and VAESKEYGENASSIST instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VZEROALL/VZEROUPPER  	  Execution of the VZEROALL or VZEROUPPER instructions in 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.  	 Compilers should encode VEX.W = 0 for the VZEROALL and VZEROUPPER instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	  Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used.  	 Software can avoid this by: •Avoid using Freeze PerfMon on PMI bit •Enable only one fixed counter at a time when using Freeze PerfMon on PMI 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of FXSAVE or FXRSTOR With the VEX Prefix May Produce a #NM Exception  	  Attempt to use FXSAVE or FXRSTOR with a VEX prefix should produce a #UD (InvalidOpcode) exception. If either the TS or EM flag bits in CR0 are set, a #NM (device-notavailable) exception will be raised instead of #UD exception.  	  Due to this erratum a #NM exception may be signaled instead of a #UD exception on an FXSAVE or an FXRSTOR with a VEX prefix.  	 Software should not use FXSAVE or FXRSTOR with the VEX prefix. 	  52  For the steppings affected, see the Summary Tables of Changes.  
  VM Exits Due to “NMI-Window Exiting” May Not Occur Following a VM Entry to the Shutdown State  	  If VM entry is made with the “virtual NMIs” and “NMI-window exiting”, VM-execution controls set to 1, and if there is no virtual-NMI blocking after VM entry, a VM exit with exit reason “NMI window” should occur immediately after VM entry unless the VM entry put the logical processor in the wait-for SIPI state. Due to this erratum, such VM exits do not occur if the VM entry put the processor in the shutdown state.  	  A VMM may fail to deliver a virtual NMI to a virtual machine in the shutdown state.  	 Before performing a VM entry to the shutdown state, software should check whether the “virtual NMIs” and “NMI-window exiting” VM-execution controls are both 1. If they are, software should clear “NMI-window exiting” and inject an NMI as part of VM entry. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of INVVPID Outside 64-Bit Mode Cannot Invalidate Translations For 64-Bit Linear Addresses  	  Executions of the INVVPID instruction outside 64-bit mode with the INVVPID type “individual-address invalidation” ignore bits 63:32 of the linear address in the INVVPID descriptor and invalidate translations for bits 31:0 of the linear address.  	  The INVVPID instruction may fail to invalidate translations for linear addresses that set bits in the range 63:32. Because this erratum applies only to executions outside 64-bit mode, it applies only to attempts by a 32-bit virtual-machine monitor (VMM) to invalidate translations for a 64-bit guest. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VEX.L is Not Ignored with VCVT*2SI Instructions  	  The VEX.L bit should be ignored for the VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions, however due to this erratum the VEX.L bit is not ignored and will cause a #UD.  	  Unexpected #UDs will be seen when the VEX.L bit is set to 1 with VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions.  	 Software should ensure that the VEX.L bit is set to 0 for all scalar instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCI_ADDR May be Incorrect For Cache Parity Errors  	  In cases when a WBINVD instruction evicts a line containing an address or data parity error (MCACOD of 0x124, and MSCOD of 0x10), the address of this error should be logged in the MCi_ADDR register. Due to this erratum, the logged address may be incorrect, even though MCi_Status.ADDRV (bit 63) is set.  	  The address reported in MCi_ADDR may not be correct for cases of a parity error found during WBINVD execution.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   53 
  Instruction Fetches Page-Table Walks May be Made Speculatively to Uncacheable Memory  	  Page-table walks on behalf of instruction fetches may be made speculatively to uncacheable (UC) memory.  	  If any paging structures are located at addresses in uncacheable memory that are used for memory-mapped I/O, such I/O operations may be invoked as a result of speculative execution that would never actually occur in the executed code path. Intel has not observed this erratum with any commercially available software.  	 Software should avoid locating paging structures at addresses in uncacheable memory that are used for memory-mapped I/O 	  For the steppings affected, see the Summary Tables of Changes. 
  Reported Maximum Memory Frequency Capability May Be Higher Than Expected  	  The Intel® Pentium® Processor G645, Intel® Pentium® Processor G645T and Intel® Celeron® Processor G555 are specified for 1066 MT/s maximum DDR3 memory frequency, but report support for 1333 MT/s.The value in the DDR3 Maximum Frequency Capability (CAPID0_A - Capabilities A Register Device 0; Function 0; Offset E4–E7H; bits [2:0]) may indicate a higher than expected value of 110b, specifying that the memory controller will operate at a maximum of 1333 MT/s. The memory interface will operate as per the table below.  Processor Number G645 G645T G555 	  DDR3 DIMM Type 1066 >=1333 1066 >=1333 1066 >=1333  One DIMM/Channel Memory Frequency 1066 MT/s 1333 MT/s 1066 MT/s 1333 MT/s 1066 MT/s 1333 MT/s  Two DIMM/Channel Memory Frequency 1066 MT/s 1333 MT/s 1066 MT/s 1333 MT/s 1066 MT/s 1066 MT/s  There may be a slight increase to power or thermal characteristics at the faster memory speed. At the faster memory speed the processor still functions correctly and within the published power and thermal specifications.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Not Properly Execute Code Modified Using A Floating-Point Store  	  Under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.  	  Self- or cross-modifying code may not execute as expected. Intel has not observed this erratum with any commercially available software.  	 None identified. Do not use floating-point stores to modify code. 	  54  For the steppings affected, see the Summary Tables of Changes.  
  Execution of GETSEC[SEXIT] May Cause a Debug Exception to be Lost  	  A debug exception occurring at the same time that GETSEC[SEXIT] is executed or when an SEXIT doorbell event is serviced may be lost.  	  Due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of GETSEC[SEXIT]. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to GETSEC May Save an Incorrect Value for “Blocking by STI” in the Context of Probe-Mode Redirection  	  The GETSEC instruction causes a VM exit when executed in VMX non-root operation. Such a VM exit should set bit 0 in the Interruptability-state field in the virtual-machine control structure (VMCS) if the STI instruction was blocking interrupts at the time GETSEC commenced execution. Due to this erratum, a VM exit executed in VMX non-root operation may erroneously clear bit 0 if redirection to probe mode occurs on the GETSEC instruction.  	  After returning from probe mode, a virtual interrupt may be incorrectly delivered prior to GETSEC instruction. Intel has not observed this erratum with any commercially software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Specific Graphics Blitter Instructions May Result in Unpredictable Graphics Controller Behavior  	  Specific source-copy blitter instructions in Intel® HD Graphics 2000 and 3000 Processor may result in unpredictable behavior when a blit source and destination overlap.  	  Due to this erratum, the processor may exhibit unpredictable graphics controller behavior. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC5_CTL2 is Not Cleared by a Warm Reset  	  IA32_MC5_CTL2 MSR (285H) is documented to be cleared on any reset. Due to this erratum this MSR is only cleared upon a cold reset.  	  The algorithm documented in Software Developer’s Manual, Volume 3, section titled “CMCI Initialization” or any other algorithm that counts the IA32_MC5_CTL2 MSR being cleared on reset will not function as expected after a warm reset  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counters May Produce Incorrect Results  	  When operating in hyper-threaded mode, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled counter on the physical core’s other thread rather than the thread experiencing the event. The list of affected memory at-retirement events is as follows: •MEM_UOP_RETIRED.LOADS   55  •MEM_UOP_RETIRED.STORES •MEM_UOP_RETIRED.LOCK •MEM_UOP_RETIRED.SPLIT •MEM_UOP_RETIRED.STLB_MISS •MEM_LOAD_UOPS_RETIRED.HIT_LFB •MEM_LOAD_UOPS_RETIRED.L1_HIT •MEM_LOAD_UOPS_RETIRED.L2_HIT •MEM_LOAD_UOPS_RETIRED.LLC_HIT •MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HIT •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HITM •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_MISS •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_NONE •MEM_LOAD_UOPS_RETIRED.LLC_MISS •MEM_LOAD_UOPS_LLC_MISS_RETIRED.LOCAL_DRAM •MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_DRAM •MEM_LOAD_UOPS_RETIRED.L2_MISS 	  Due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	  The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Spurious Intel® VT-d Interrupts May Occur When the PFO Bit is Set  	  When the PFO (Primary Fault Overflow) field (bit [0] in the VT-d FSTS [Fault Status] register) is set to 1, further faults should not generate an interrupt. Due to this erratum, further interrupts may still occur.  	  Unexpected Invalidation Queue Error interrupts may occur. Intel has not observed this erratum with any commercially available software.  	 Software should be written to handle spurious Intel® VT-d fault interrupts. 	  56  For the steppings affected, see the Summary Tables of Changes.  
  Processor May Livelock During On Demand Clock Modulation  	  The processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the IA32_CLOCK_MODULATION MSR (19AH) and the clock modulation duty cycle is set to 12.5% (02H in bits 3:0 of the same MSR), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access UC memory.  	  Program execution may stall on both threads of the core subject to this erratum.  	 This erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the IA32_CLOCK_MODULATION MSR is 18.75% or higher. 	  For the steppings affected, see the Summary Tables of Changes.
  The Processor may Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions as described in the Software Developers Manual section "Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors" the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	  Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Table of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a non-canonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  16  For the steppings affected, see the Summary Table of Changes.   
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	  Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. • If an instruction that performs a memory load causes a code segment limit violation. • If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending. • If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Topof-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	  In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the sideeffect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception.  	 Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Table of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	  With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Table of Changes.   17  
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Table of Changes. 
  Values for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect.  	  Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used. The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified 	  For the steppings affected, see the Summary Table of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	  When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  	  Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 1: Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  18  For the steppings affected, see the Summary Table of Changes.   
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	  In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame.  	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Table of Changes. 
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g. Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	  Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4G limit (0ffffffffh) may not signal a #GP fault.  	  When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault.  	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4G limit (0ffffffffh). 	  For the steppings affected, see the Summary Table of Changes. 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1's. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   19  
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	  The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Table of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first FAR JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	  The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first FAR JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the FAR JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  20  For the steppings affected, see the Summary Table of Changes.   
  A VM Exit on MWAIT May Incorrectly Report the Monitoring Hardware as Armed  	  A processor write to the address range armed by the MONITOR instruction may not immediately trigger the monitoring hardware. Consequently, a VM exit on a later MWAIT may incorrectly report the monitoring hardware as armed, when it should be reported as unarmed due to the write occurring prior to the MWAIT.  	  If a write to the range armed by the MONITOR instruction occurs between the MONITOR and the MWAIT, the MWAIT instruction may start executing before the monitoring hardware is triggered. If the MWAIT instruction causes a VM exit, this could cause its exit qualification to incorrectly report 0x1. In the recommended usage model for MONITOR/MWAIT, there is no write to the range armed by the MONITOR instruction between the MONITOR and the MWAIT.  	 Software should never write to the address range armed by the MONITOR instruction between the MONITOR and the subsequent MWAIT. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor Event SEGMENT_REG_LOADS Counts Inaccurately  	  The performance monitor event SEGMENT_REG_LOADS (Event 06H) counts instructions that load new values into segment registers. The value of the count may be inaccurate.  	  The performance monitor event SEGMENT_REG_LOADS may reflect a count higher or lower than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	  An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Improper Parity Error Signaled in the IQ Following Reset When a Code Breakpoint is Set on a #GP Instruction  	  While coming out of cold reset or exiting from C6, if the processor encounters an instruction longer than 15 bytes (which causes a #GP) and a code breakpoint is enabled on that instruction, an IQ (Instruction Queue) parity error may be incorrectly logged resulting in an MCE (Machine Check Exception).  	  When this erratum occurs, an MCE may be incorrectly signaled.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   21  
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software or system.  	 As recommended in the Intel® 64 and IA-32 Intel® Architectures Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  IA32_MPERF Counter Stops Counting During On-Demand TM1  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, the ratio of IA32_MPERF (MSR E7H) to IA32_APERF (MSR E8H) should reflect actual performance while TM1 or on-demand throttling is activated. Due to this erratum, IA32_MPERF MSR stops counting while TM1 or on-demand throttling is activated, and the ratio of the two will indicate higher processor performance than actual.  	  The incorrect ratio of IA32_APERF/IA32_MPERF can mislead software P-state (performance state) management algorithms under the conditions described above. It is possible for the Operating System to observe higher processor utilization than actual, which could lead the OS into raising the P-state. During TM1 activation, the OS P-state request is irrelevant and while on-demand throttling is enabled, it is expected that the OS will not be changing the P-state. This erratum should result in no practical implication to software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  The Memory Controller tTHROT_OPREF Timings May be Violated During Self Refresh Entry  	  During self refresh entry, the memory controller may issue more refreshes than permitted by tTHROT_OPREF (bits 29:19 in MC_CHANNEL_{0,1,2}_REFRESH_TIMING CSR).  	  The intention of tTHROT_OPREF is to limit current. Since current supply conditions near self refresh entry are not critical, there is no measurable impact due to this erratum.  	 None identified. 	  22  For the steppings affected, see the Summary Table of Changes.   
  Synchronous Reset of IA32_APERF/IA32_MPERF Counters on Overflow Does Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. This synchronous reset does not work. Instead, both MSRs increment and overflow independently.  	  Software can not rely on synchronous reset of the IA32_APERF/IA32_MPERF registers.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Disabling Thermal Monitor While Processor is Hot, Then Re-enabling, May Result in Stuck Core Operating Ratio  	  If a processor is at its TCC (Thermal Control Circuit) activation temperature and then Thermal Monitor is disabled by a write to IA32_MISC_ENABLES MSR (1A0H) bit [3], a subsequent re-enable of Thermal Monitor will result in an artificial ceiling on the maximum core P-state. The ceiling is based on the core frequency at the time of Thermal Monitor disable. This condition will only correct itself once the processor reaches its TCC activation temperature again.  	  Since Intel requires that Thermal Monitor be enabled in order to be operating within specification, this erratum should never be seen during normal operation.  	 Software should not disable Thermal Monitor during processor operation. 	  For the steppings affected, see the Summary Table of Changes. 
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	  An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.  	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Table of Changes.   23  
  Faulting MMX Instruction May Incorrectly Update x87 FPU Tag Word  	  Under a specific set of conditions, MMX stores (MOVD, MOVQ, MOVNTQ, MASKMOVQ) which cause memory access faults (#GP, #SS, #PF, or #AC), may incorrectly update the x87 FPU tag word register. This erratum will occur when the following additional conditions are also met. • The MMX store instruction must be the first MMX instruction to operate on x87 FPU state (i.e. the x87 FP tag word is not already set to 0x0000). • For MOVD, MOVQ, MOVNTQ stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to MASKMOVQ).  	  If the erratum conditions are met, the x87 FPU tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  xAPIC Timer May Decrement Too Quickly Following an Automatic Reload While in Periodic Mode  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	  Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type.  	 Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  24  For the steppings affected, see the Summary Table of Changes.   
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1. MOV or POP instruction to SS (Stack Segment) selector; 2. Next instruction is FP (Floating Point) that gets FP assist 3. Another instruction after the FP instruction completes successfully 4. A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4.  	  Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints.  	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Table of Changes. 
  Core C6 May Clear Previously Logged TLB Errors  	  Following an exit from core C6, previously logged TLB (Translation Lookaside Buffer) errors in IA32_MCi_STATUS may be cleared.  	  Due to this erratum, TLB errors logged in the associated machine check bank prior to core C6 entry may be cleared. Provided machine check exceptions are enabled, the machine check exception handler can log any uncorrectable TLB errors prior to core C6 entry. The TLB marks all detected errors as uncorrectable.  	 As long as machine check exceptions are enabled, the machine check exception handler can log the TLB error prior to core C6 entry. This will ensure the error is logged before it is cleared. 	  For the steppings affected, see the Summary Table of Changes. 
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex micro-architectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Table of Changes.   25  
  A String Instruction that Re-maps a Page May Encounter an Unexpected Page Fault An unexpected page fault (#PF) may occur for a page under the following conditions: • The paging structures initially specify a valid translation for the page. • Software modifies the paging structures so that there is no valid translation for the page (e.g., by clearing to 0 the present bit in one of the paging-structure entries used to translate the page). • An iteration of a string instruction modifies the paging structures so that the translation is again a valid translation for the page (e.g., by setting to 1 the bit that was cleared earlier). • A later iteration of the same string instruction loads from a linear address on the page.  	  • Software did not invalidate TLB entries for the page between the first modification of the paging structures and the string instruction. In this case, the load in the later iteration may cause a page fault that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page).  	  Software may see an unexpected page fault that indicates that there is no translation for the page. Intel has not observed this erratum with any commercially available software or system.  	 Software should not update the paging structures with a string instruction that accesses pages mapped the modified paging structures. 	  For the steppings affected, see the Summary Table of Changes. 
  Infinite Stream of Interrupts May Occur if an ExtINT Delivery Mode Interrupt is Received while All Cores in C6  	  If all logical processors in a core are in C6, an ExtINT delivery mode interrupt is pending in the xAPIC and interrupts are blocked with EFLAGS.IF=0, the interrupt will be processed after C6 wakeup and after interrupts are re-enabled (EFLAGS.IF=1). However, the pending interrupt event will not be cleared.  	  Due to this erratum, an infinite stream of interrupts will occur on the core servicing the external interrupt. Intel has not observed this erratum with any commercially available software/system.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Two xAPIC Timer Event Interrupts May Unexpectedly Occur  	  If an xAPIC timer event is enabled and while counting down the current count reaches 1 at the same time that the processor thread begins a transition to a low power Cstate, the xAPIC may generate two interrupts instead of the expected one when the processor returns to C0.  	  Due to this erratum, two interrupts may unexpectedly be generated by an xAPIC timer event.  	 None identified. 	  26  For the steppings affected, see the Summary Table of Changes.   
  EOI Transaction May Not be Sent if Software Enters Core C6 During an Interrupt Service Routine  	  If core C6 is entered after the start of an interrupt service routine but before a write to the APIC EOI (End of Interrupt) register, and the core is woken up by an event other than a fixed interrupt source the core may drop the EOI transaction the next time APIC EOI register is written and further interrupts from the same or lower priority level will be blocked.  	NA	 Software should check the ISR register and if any interrupts are in service only enter C1. 	  For the steppings affected, see the Summary Table of Changes. 
  FREEZE_WHILE_SMM Does Not Prevent Event From Pending PEBS During SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if 1. A performance counter overflowed before an SMI 2. A PEBS record has not yet been generated because another count of the event has not occurred 3. The monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM.  	  A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   27  
  DR6 May Contain Incorrect Information When the First Instruction After a MOV SS,r/m or POP SS is a Store  	  Normally, each instruction clears the changes in DR6 (Debug Status Register) caused by the previous instruction. However, the instruction following a MOV SS,r/m (MOV to the stack segment selector) or POP SS (POP stack segment selector) instruction will not clear the changes in DR6 because data breakpoints are not taken immediately after a MOV SS,r/m or POP SS instruction. Due to this erratum, any DR6 changes caused by a MOV SS,r/m or POP SS instruction may be cleared if the following instruction is a store.  	  When this erratum occurs, incorrect information may exist in DR6. This erratum will not be observed under normal usage of the MOV SS,r/m or POP SS instructions (i.e., following them with an instruction that writes [e/r]SP). When debugging or when developing debuggers, this behavior should be noted.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  IA32_PERF_GLOBAL_CTRL MSR May be Incorrectly Initialized  	  The IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [34:32] may be incorrectly set to 7H after reset; the correct value should be 0H.  	  The IA32_PERF_GLOBAL_CTRL MSR bits [34:32] may be incorrect after reset (EN_FIXED_CTR{0, 1, 2} may be enabled).  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  ECC Errors Can Not be Injected on Back-to-Back Writes  	  ECC errors should be injected on every write that matches the address set in the MC_CHANNEL_{0,1,2}_ADDR_MATCH CSRs. Due to this erratum if there are two backto-back writes that match MC_CHANNEL_{0,1,2}_ADDR_MATCH, the 2nd write will not have the error injected.  	  The 2nd back-to-back write that matches MC_CHANNEL_{0,1,2}_ADDR_MATCH will not have the ECC error properly injected. Setting MC_CHANNEL_{0,1,2}_ADDR_MATCH to a specific address will reduce the chance of being impacted by this erratum.  	 Only injecting errors to specific address should reduce the chance on being impacted by this erratum. 	  28  For the steppings affected, see the Summary Table of Changes.   
  Performance Monitor Counter INST_RETIRED.STORES May Count Higher than Expected  	  Performance Monitoring counter INST_RETIRED.STORES (Event: C0H) is used to track retired instructions which contain a store operation. Due to this erratum, the processor may also count other types of instructions including WRMSR and MFENCE.  	  Performance Monitoring counter INST_RETIRED.STORES may report counts higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Sleeping Cores May Not be Woken Up on Logical Cluster Mode Broadcast IPI Using Destination Field Instead of Shorthand  	  If software sends a logical cluster broadcast IPI using a destination shorthand of 00B (No Shorthand) and writes the cluster portion of the Destination Field of the Interrupt Command Register to all ones while not using all 1s in the mask portion of the Destination Field, target cores in a sleep state that are identified by the mask portion of the Destination Field may not be woken up. This erratum does not occur if the destination shorthand is set to 10B (All Including Self) or 11B (All Excluding Self).  	  When this erratum occurs, cores which are in a sleep state may not wake up to handle the broadcast IPI. Intel has not observed this erratum with any commercially available software.  	 Use destination shorthand of 10B or 11B to send broadcast IPIs. 	  For the steppings affected, see the Summary Table of Changes. 
  Faulting Executions of FXRSTOR May Update State Inconsistently  	  The state updated by a faulting FXRSTOR instruction may vary from one execution to another.  	  Software that relies on x87 state or SSE state following a faulting execution of FXRSTOR may behave inconsistently.  	 Software handling a fault on an execution of FXRSTOR can compensate for execution variability by correcting the cause of the fault and executing FXRSTOR again. 	  For the steppings affected, see the Summary Table of Changes. 
  Memory Aliasing of Code Pages May Cause Unpredictable System Behavior  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncacheable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncacheable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	 Code pages should not be mapped with uncacheable and cacheable memory types at the same time. 	  For the steppings affected, see the Summary Table of Changes.   29  
  Performance Monitor Counters May Count Incorrectly  	  Under certain circumstances, a general purpose performance counter, IA32_PMC0-4 (C1H – C4H), may count at core frequency or not count at all instead of counting the programmed event.  	  The Performance Monitor Counter IA32_PMCx may not properly count the programmed event. Due to the requirements of the workaround there may be an interruption in the counting of a previously programmed event during the programming of a new event.  	 Before programming the performance event select registers, IA32_PERFEVTSELx MSR (186H – 189H), the internal monitoring hardware must be cleared. This is accomplished by first disabling, saving valid events and clearing from the select registers, then programming three event values 0x4300D2, 0x4300B1 and 0x4300B5 into the IA32_PERFEVTSELx MSRs, and finally continuing with new event programming and restoring previous programming if necessary. Each performance counter, IA32_PMCx, must have its corresponding IA32_PREFEVTSELx MSR programmed with at least one of the event values and must be enabled in IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [3:0]. All three values must be written to either the same or different IA32_PERFEVTSELx MSRs before programming the performance counters. Note that the performance counter will not increment when its IA32_PERFEVTSELx MSR has a value of 0x4300D2, 0x4300B1 or 0x4300B5 because those values have a zero UMASK field (bits [15:8]). 	  For the steppings affected, see the Summary Table of Changes. 
  Simultaneous Accesses to the Processor via JTAG and PECI May Cause Unexpected Behavior  	  JTAG commands that are executed at the same time as a PECI (Platform Environment Control Interface) access may cause unexpected behavior. In addition the PECI command may take longer to complete or may not complete.  	  The processor could be left in an unexpected state and any software or firmware doing PECI writes may time out.  	 Ensure that PECI commands are not executed while using JTAG. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor Event Offcore_response_0 (B7H) Does Not Count NT Stores to Local DRAM Correctly  	  When a IA32_PERFEVTSELx MSR is programmed to count the Offcore_response_0 event (Event:B7H), selections in the OFFCORE_RSP_0 MSR (1A6H) determine what is counted. The following two selections do not provide accurate counts when counting NT (Non-Temporal) Stores: - OFFCORE_RSP_0 MSR bit [14] is set to 1 (LOCAL_DRAM) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are not counted when they should have been. - OFFCORE_RSP_0 MSR bit [9] is set to (OTHER_CORE_HIT_SNOOP) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are counted when they should not have been.  	  The counter for the Offcore_response_0 event may be incorrect for NT stores.  	 None identified. 	  30  For the steppings affected, see the Summary Table of Changes.   
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Table of Changes. 
  System May Hang if MC_CHANNEL_{0,1,2}_MC_DIMM_INIT_CMD.DO_ZQCL Commands Are Not Issued in Increasing Populated DDR3 Rank Order  	  ZQCL commands are used during initialization to calibrate DDR3 termination. A ZQCL command can be issued by writing 1 to the MC_CHANNEL_{0,1,2}_MC_DIMM_INIT_CMD.DO_ZQCL (Device 4,5,6, Function 0, Offset 15, bit[15]) field and it targets the DDR3 rank specified in the RANK field (bits[7:5]) of the same register. If the ZQCL commands are not issued in increasing populated rank order then ZQ calibration may not complete, causing the system to hang.  	  Due to this erratum the system may hang if writes to the MC_CHANNEL_{0,1,2}_MC_DIMM_INIT_CMD.DO_ZQCL field are not in increasing populated DDR3 rank order.  	NA	  For the steppings affected, see the Summary Table of Changes.   31  
  Package C3/C6 Transitions When Memory 2x Refresh is Enabled May Result in a System Hang  	  If ASR_PRESENT (MC_CHANNEL_{0,1,2}_REFRESH_THROTTLE_SUP PORT CSR function 0, offset 68H, bit [0], Auto Self Refresh Present) is clear which indicates that high temperature operation is not supported on the DRAM, the memory controller will not enter self-refresh if software has REF_2X_NOW (bit 4 of the MC_CLOSED_LOOP CSR, function 3, offset 84H) set. This scenario may cause the system to hang during C3/C6 entry.  	  Failure to enter self-refresh can delay C3/C6 power state transitions to the point that a system hang may result with CATERR being asserted. REF_2X_NOW is used to double the refresh rate when the DRAM is operating in extended temperature range. The ASR_PRESENT was intended to allow low power self refresh with DRAM that does not support automatic self refresh.  	 It is possible for Intel provided BIOS reference code to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Back to Back Uncorrected Machine Check Errors May Overwrite IA32_MC3_STATUS.MSCOD  	  When back-to-back uncorrected machine check errors occur that would both be logged in the IA32_MC3_STATUS MSR (40CH), the IA32_MC3_STATUS.MSCOD (bits [31:16]) field may reflect the status of the most recent error and not the first error. The rest of the IA32_MC3_STATUS MSR contains the information from the first error.  	  Software should not rely on the value IA32_MC3_STATUS.OVER (bit [62]) is set.  of  IA32_MC3_STATUS.MSCOD  if  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Corrected Errors With a Yellow Error Indication May be Overwritten by Other Corrected Errors  	  A corrected cache hierarchy data or tag error that is reported with IA32_MCi_STATUS.MCACOD (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one) and a yellow threshold-based error status indication (bits [54:53] equal to 10B) may be overwritten by a corrected error with a no tracking indication (00B) or green indication (01B).  	  Corrected errors with a yellow threshold-based error status indication may be overwritten by a corrected error without a yellow indication.  	 None identified. 	  32  For the steppings affected, see the Summary Table of Changes.   
  Performance Monitor Events DCACHE_CACHE_LD and DCACHE_CACHE_ST May Overcount  	  The performance monitor events DCACHE_CACHE_LD (Event 40H) and DCACHE_CACHE_ST (Event 41h) count cacheable loads and stores that hit the L1 cache. Due to this erratum, in addition to counting the completed loads and stores, the counter will incorrectly count speculative loads and stores that were aborted prior to completion.  	  The performance monitor events DCACHE_CACHE_LD and DCACHE_CACHE_ST may reflect a count higher than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor Events INSTR_RETIRED and MEM_INST_RETIRED May Count Inaccurately  	  The performance monitor event INSTR_RETIRED (Event C0H) should count the number of instructions retired, and MEM_INST_ RETIRED (Event 0BH) should count the number of load or store instructions retired. However, due to this erratum, they may undercount.  	  The performance monitor event INSTR_RETIRED and MEM_INST_RETIRED may reflect a count lower than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  A Page Fault May Not be Generated When the PS bit is set to "1" in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	  Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.  	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to "1". 	  For the steppings affected, see the Summary Table of Changes.   33  
  Uncacheable Access to a Monitored Address Range May Prevent Future Triggering of the Monitor Hardware  	  It is possible that an address range which is being monitored via the MONITOR instruction could be written without triggering the monitor hardware. A read from the monitored address range which is issued as uncacheable (for example having the CR0.CD bit set) may prevent subsequent writes from triggering the monitor hardware. A write to the monitored address range which is issued as uncacheable, may not trigger the monitor hardware and may prevent subsequent writes from triggering the monitor hardware.  	  The MWAIT instruction will not exit the optimized power state and resume program flow if the monitor hardware is not triggered.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  BIST Results May be Additionally Reported After a GETSEC[WAKEUP] or INIT-SIPI Sequence  	  BIST results should only be reported in EAX the first time a logical processor wakes up from the Wait-For-SIPI state. Due to this erratum, BIST results may be additionally reported after INIT-SIPI sequences and when waking up RLP’s from the SENTER sleep state using the GETSEC[WAKEIUP] command.  	  An INIT-SIPI sequence may show a non-zero value in EAX upon wakeup when a zero value is expected. RLP’s waking up for the SENTER sleep state using the GETSEC[WAKEUP] command may show a different value in EAX upon wakeup than before going into the SENTER sleep state.  	 If necessary software may save the value in EAX prior to launching into the secure environment and restore upon wakeup and/or clear EAX after the INIT-SIPI sequence. 	  For the steppings affected, see the Summary Table of Changes. 
  Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	  Software may be observed #MF being-signaled before pending interrupts are serviced.  	 None identified. 	  34  For the steppings affected, see the Summary Table of Changes.   
  VM Exits Due to “NMI-Window Exiting” May Be Delayed by One Instruction  	  If VM entry is executed with the “NMI-window exiting” VM-execution control set to 1, a VM exit with exit reason “NMI window” should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and not blocking of events by STR. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	  VMM software using “NMI-window exiting” for NMI virutalization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Multiple Performance Monitor Interrupts are Possible on Overflow of IA32_FIXED_CTR2  	  When multiple performance counters are set to generate interrupts on an overflow and more than one counter overflows at the same time, only one interrupt should be generated. However, if one of the counters set to generate an interrupt on overflow is the IA32_FIXED_CTR2 (MSR 30BH) counter, multiple interrupts may be generated when the IA32_FIXED_CTR2 overflows at the same time as any of the other performance counters.  	  Multiple counter overflow interrupts may be unexpectedly generated.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  C-State Autodemotion May be too Aggressive Under Certain Configurations and Workloads  	  The C-state autodemotion feature allows the processor to make intelligent power and performance tradeoffs regarding the OS-requested C-state. Under certain operating system and workload specific conditions, the C-state auto-demotion feature may be overly aggressive in demoting OS C-sate requests to a C-sate with higher power and lower exit latency.  	  This aggressive demotion can result in higher platform power under idle conditions.  	 None identified 	  For the steppings affected, see the Summary Table of Changes. 
  LBRs May Not be Initialized During Power-On Reset of the Processor  	  If a second reset is initiated during the power-on processor reset cycle, the LBRs (Last Branch Records) may not be properly initialized.  	  Due to this erratum, debug software may not be able to rely on the LBRs out of poweron reset.  	 Ensure that the processor has completed its power-on reset cycle prior to initiating a second reset. 	  For the steppings affected, see the Summary Table of Changes.   35  
  Multiple Performance Monitor Interrupts are Possible on Overflow of Fixed Counter 0  	  The processor can be configured to issue a PMI (performance monitor interrupt) upon overflow of the IA32_FIXED_CTR0 MSR (309H). A single PMI should be observed on overflow of IA32_FIXED_CTR0, however multiple PMIs are observed when this erratum occurs. This erratum only occurs when IA32_FIXED_CTR0 overflows and the processor and counter are configured as follows: • Intel® Hyper-Threading Technology is enabled • IA32_FIXED_CTR0 local and global controls are enabled • IA32_FIXED_CTR0 is set to count events only on its own thread (IA32_FIXED_CTR_CTRL MSR (38DH) bits[2] = ‘0) • PMIs are enabled on IA32_FIXED_CTR0 (IA32_FIXED_CTR_CTRL MSR bit[3] = ‘1) • Freeze_on_PMI feature is enabled (IA32_DEBUGCTL MSR (1D9H) bit[12] = ‘1)  	  When this erratum occurs IA32_FIXED_CTR0 overflows.  there  may  be  multiple  PMIs  observed  when  	 Disable the FREEZE_PERFMON_ON_PMI feature in IA32_DEBUGCTL MSR (1D9H) bit[12]. 	  For the steppings affected, see the Summary Table of Changes. 
  VM Exits Due to LIDR/LGDT/SIDT/SGDT Do Not Report Correct Operand Size  	  When a VM exit occurs due to a LIDT, LGDT, SIDT, or SGDT instruction with a 32-bit operand, bit 11 of the VM-exit instruction information field should be set to 1. Due to this erratum, this bit is instead cleared to 0 (indicating a 16-bit operand).  	  Virtual-machine monitors cannot rely on bit 11 of the VM-exit instruction information field to determine the operand size of the instruction causing the VM exit.  	 Virtual-machine monitor software may decode the instruction to determine operand size. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitoring Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA May Not Count Events Correctly  	  Performance Monitor Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA should only increment the count when a load is blocked by a store. Due to this erratum, the count will be incremented whenever a load hits a store, whether it is blocked or can forward. In addition this event does not count for specific threads correctly.  	  If Intel® Hyper-Threading Technology is disabled, the Performance Monitor events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA may indicate a higher occurrence of loads blocked by stores than have actually occurred. If Intel Hyper-Threading Technology is enabled, the counts of loads blocked by stores may be unpredictable and they could be higher or lower than the correct count.  	 None identified. 	  36  For the steppings affected, see the Summary Table of Changes.   
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	  When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMS (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMXTM instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	  The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  The PECI Bus May be Tri-stated After System Reset  	  During power-up, the processor may improperly assert the PECI (Platform Environment Control Interface) pin. This condition is cleared as soon as Bus Clock starts toggling. However, if the PECI host (also referred to as the master or originator) incorrectly determines this asserted state as another PECI host initiating a transaction, it may release control of the bus resulting in a permanent tri-state condition.  	  Due to this erratum, the PECI host may incorrectly determine that it is not the bus master and consequently PECI commands initiated by the PECI software layer may receive incorrect/invalid responses.  	 To workaround this erratum the PECI host should pull the PECI bus low to initiate a PECI transaction. 	  For the steppings affected, see the Summary Table of Changes. 
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	  The values of the LER MSRs may be unreliable.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   37  
  APIC Timer CCR May Report 0 in Periodic Mode  	  In periodic mode the APIC timer CCR (current-count register) is supposed to be automatically reloaded from the initial-count register when the count reaches 0, consequently software would never be able to observe a value of 0. Due to this erratum, software may read 0 from the CCR when the timer has counted down and is in the process of re-arming.  	  Due to this erratum, an unexpected value of 0 may be read from the APIC timer CCR when in periodic mode.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  LBR, BTM or BTS Records May have Incorrect Branch From Information After an EIST Transition, T-states, C1E, or Adaptive Thermal Throttling  	  The “Form” address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after an EIST (Enchanced Intel® SpeedStep Technology) transition, T-states, C1E (C1 Enhanced), or Adaptive Thermal Throttling.  	  When the LBRs, BTM or BTS are enabled, some records may have incorrect branch “From” addresses for the first branch after an EIST transition, T-states, C1E, or Adaptive Thermal Throttling.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  PEBS Records Not Created For FP-Assists Events  	  When a performance monitor counter is configured to count FP_ASSISTS (Event: F7H) and to trigger PEBS (Precise Event Based Sampling), the processor does not create a PEBS record when the counter overflows.  	  FP_ASSISTS events cannot be used for PEBS.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  MSR_TURBO_RATIO_LIMIT MSR May Return Intel® Turbo Boost Technology Core Ratio Multipliers for Non-Existent Core Configurations  	  MSR_TURBO_RATIO_LIMIT MSR (1ADH) is designed to describe the maximum Intel Turbo Boost Technology potential of the processor. On some processors, a non-zero Intel Turbo Boost Technology value will be returned for non-existent core configurations.  	  Due to this erratum, software using the MSR_TURBO_RATIO_LIMIT MSR to report Intel Turbo Boost Technology processor capabilities may report erroneous results.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  38  For the steppings affected, see the Summary Table of Changes.   
  L1 Cache Uncorrected Errors May be Recorded as Correctable in 16K Mode  	  When the L1 Cache is operating in 16K redundant parity mode and a parity error occurs on both halves of the duplicated cache on the same cacheline, an uncorrectable error should be logged. Due to this erratum, the uncorrectable error will be recorded as correctable, however a machine check exception will be appropriately taken in this case.  	  Due to this erratum, the IA32_MCi_STATUS.UC bit will incorrectly contain a value of 0 indicating a correctable error.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Extra APIC Timer Interrupt May Occur During a Write to the Divide Configuration Register  	  If the APIC timer Divide Configuration Register (Offset 03E0H) is written at the same time that the APIC timer Current Count Register (Offset 0390H) reads 1H, it is possible that the APIC timer will deliver two interrupts.  	  Due to this erratum, two interrupts may unexpectedly be generated by an APIC timer event.  	 Software should reprogram the Divide Configuration Register only when the APIC timer interrupt is disarmed. 	  For the steppings affected, see the Summary Table of Changes. 
  PECI Reads of Machine Check MSRs in the Processor Core May Not Function Correctly  	  PECI reads which target machine check MSRs in the processor core may either be directed to a different core than intended or report that the data is not available.  	  PECI reads of machine check MSRs in the processor core may return incorrect data or incorrectly report that data is not available for the requested core.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  The Combination of a Page-Split Lock Access And Data Accesses That Are Split Across Cacheline Boundaries May Lead to Processor Livelock  	  Under certain complex micro-architectural conditions, the simultaneous occurrence of a page-split lock and several data accesses that are split cacheline boundaries may lead to processor livelock.  	  Due to this erratum, a livelock may occur that can only be terminated by a processor reset. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   39  
  Package C6 Transitions May Cause Memory Bit Errors to be Observed  	  During Package C6 transitions, internal signaling noise may cause the DDRx_CKE signal to become asserted during self-refresh. These assertions may result in memory bit errors upon exiting from the package C6 state. Due to this erratum the DDRx_CKE signals can be driven during times in which the DDR3 JEDEC specification requires that they are idle.  	  DDRx_CKE signals can be driven during package C6 memory self-refresh creating an invalid memory DRAM state. A system hang, memory ECC errors or unpredictable system behavior may occur when exiting the package C6 state.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Sensitivity in Clocking Circuitry May Cause Unpredictable System Behavior  	  On a subset of processors the clocking circuitry may be sensitive to fluctuations in Vtt voltage during stressful testing and/or operating conditions and may cause unpredictable system behavior.  	  This erratum may result in unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Accesses to a VMCS May Not Operate Correctly If CR0.CD is Set on Any Logical Processsor of a Core  	  The VMX (virtual-machine extensions) are controlled by the VMCS (virtualmachinecontrol structure). If CR0.CD is set on any logical processor of a core, operations using the VMCS may not function correctly. Such operations include the VMREAD and VMWRITE instructions as well as VM entries and VM exits.  	  If CR0.CD is set on either logical processor in a core, the VMWRITE instruction may not correctly update the VMCS and the VMREAD instruction may not return correct data. VM entries may not load state properly and may not establish VMX controls properly. VM exits may not save or load state properly.  	 VMMs (Virtual-machine monitors) should ensure that CR0.CD is clear on all logical processors of a core before entering VMX operation on any logical processor. Software should not set CR0.CD on a logical processor if any logical processor of the same core is in VMX operation. VMM software should prevent guest software from setting CR0.CD by setting bit 30 in the CR0 guest/host mask field in every VMCS. 	  For the steppings affected, see the Summary Table of Changes. 
  Performance Monitor Events for Hardware Prefetches Which Miss TheL1 Data Cache May be Over Counted  	  Hardware prefetches that miss the L1 data cache but cannot be processed immediately due to resource conflicts will count and then retry. This may lead to incorrectly incrementing the L1D_PREFETCH.MISS (event 4EH, umask 02H) event multiple times for a single miss.  	  The count reported by the L1D_PREFETCH.MISS event may be higher than expected.  	 None identified. 	  40  For the steppings affected, see the Summary Table of Changes.   
  VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]  	  If the "load IA32_PERF_GLOBAL_CTRL" VM-exit control is 1, a VM exit should load the IA32_PERF_GLOBAL_CTRL MSR (38FH) from the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS. Due to this erratum, such a VM exit may instead clear bits 34:32 of the MSR, loading only bits 31:0 from the VMCS.  	  All fixed-function performance counters will be disabled after an affected VM exit, even if the VM exit should have enabled them based on the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS.  	 A VM monitor that wants the fixed-function performance counters to be enabled after a VM exit may do one of two things: (1) clear the "load IA32_PERF_GLOBAL_CTRL" VMexit control; or (2) include an entry for the IA32_PERF_GLOBAL_CTRL MSR in the VMexit MSR-load list. 	  For the steppings affected, see the Summary Table of Changes. 
  Package C6 Transitions May Result in Single and Multi-Bit Memory Errors  	  On a subset of processors, during package C6 transitions, internal circuit marginality may cause DDR3 JEDEC specification violations. These violations may result in control and data signal errors upon exiting from package C6 state.  	  Certain memory control signals may be incorrectly driven during package C6 memory self-refresh. This can create an invalid memory DRAM state, system hang, reboot, memory ECC errors or unpredictable system behavior. For systems with ECC memory, correctable/uncorrectable ECC errors may be logged in the IA32_MC8_STATUS MSR (421H) with the uncorrectable errors resulting in a machine check exception.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  VM Entry May Omit Consistency Checks Related to Bit 14 (BS) of the Pending Debug Exception Field in Guest-State Area of the VMCS  	  Section "Checks on Guest Non-Register State" of Volume 3B specifies consistency checks that VM entry should perform for bit 14 (BS, indicating a pending single-step exception) of the pending debug exception field in guest-state area of the VMCS. These checks enforce the consistency of that bit with other fields in the guest-state area. Due to this erratum, VM entry may fail to perform these checks.  	  A logical processor may enter VMX non-root operation with a pending single-step debug exception that not consistent other register state; this may result in unexpected behavior. Intel has not observed this erratum with any commercially available software  	 When using VMWRITE to write to a field in the guest-state area, software should ensure that the value written is consistent with the state of other guest-state fields. 	  For the steppings affected, see the Summary Table of Changes. 
 	NA	NA	NA	NA
   41  	NA	NA	NA	NA
  Execution of VMPTRLD May Corrupt Memory If Current-VMCS Pointer is Invalid  	  If the VMCLEAR instruction is executed with a pointer to the current-VMCS (virtualmachine control structure), the current-VMCS pointer becomes invalid as expected. A subsequent execution of the VMPTRLD (Load Pointer to Virtual-Machine Control Structure) instruction may erroneously overwrite the four bytes at physical address 0000008FH.  	  Due to this erratum, the four bytes in system memory at physical address 0000008FH may be corrupted.  	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  PerfMon Overflow Status Can Not be Cleared After Certain Conditions Have Occurred  	  Under very specific timing conditions, if software tries to disable a PerfMon counter through MSR IA32_PERF_GLOBAL_CTRL (0x38F) or through the per-counter eventselect (e.g. MSR 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in MSR IA32_PERF_GLOBAL_STAT (0x38E) may be left set with no way for software to clear it.  	  Due to this erratum, software may be unable to clear the PerfMon counter overflow status indication.  	 Software may avoid this erratum by clearing the PerfMon counter value prior to disabling it and then clearing the overflow status indication bit. 	  For the steppings affected, see the Summary Table of Changes. 
  L1 Data Cache Errors May be Logged With Level Set to 1 Instead of 0  	  When an L1 Data Cache error is logged in IA32_MCi_STATUS[15:0], which is the MCA Error Code Field, with a cache error type of the format 0000 0001 RRRR TTLL, the LL field may be incorrectly encoded as 01b instead of 00b.  	  An error in the L1 Data Cache may report the same LL value as the L2 Cache. Software should not assume that an LL value of 01b is the L2 Cache.  	 None identified. 	  42  For the steppings affected, see the Summary Table of Changes.   
  An Unexpected Page Fault or EPT Violation May Occur After Another Logical Processor Creates a Valid Translation for a Page  	  An unexpected page fault (#PF) or EPT violation may occur for a page under the following conditions: • The paging structures initially specify no valid translation for the page. • Software on one logical processor modifies the paging structures so that there is a valid translation for the page (e.g., by setting to 1 the present bit in one of the pagingstructure entries used to translate the page). • Software on another logical processor observes this modification (e.g., by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). • Shortly thereafter, software on that other logical processor performs a store to a linear address on the page. In this case, the store may cause a page fault or EPT violation that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). Intel has not observed this erratum with any commercially available software.  	  An unexpected page fault may be reported. There are no other side effects due to this erratum.  	 System software can be constructed to tolerate these unexpected page faults. See Section "Propagation of Paging-Structure Changes to Multiple Processors" of Volume 3A of IA-32 Intel® Architecture Software Developer's Manual, for recommendations for software treatment of asynchronous paging-structure updates. 	  For the steppings affected, see the Summary Table of Changes. 
  PerfMon Event LOAD_HIT_PRE.SW_PREFETCH May Overcount  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH (event 4CH, umask 01H) should count load instructions hitting an ongoing software cache fill request initiated by a preceding software prefetch instruction. Due to this erratum, this event may also count when there is a preceding ongoing cache fill request initiated by a locking instruction.  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH may overcount.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   43  
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter's overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	  Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used.  	 Software can avoid this by: 1. Avoid using Freeze PerfMon on PMI bit 2. Enable only one fixed counter at a time when using Freeze PerfMon on PMI. 	  For the steppings affected, see the Summary Table of Changes. 
  #GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions  	  When a 2-byte opcode of a conditional branch (opcodes 0F8xH, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid VEX prefix, it may sometimes signal a #GP fault (illegal instruction length > 15-bytes) instead of a #UD (illegal opcode) fault.  	  Due to this erratum, #GP fault instead of a #UD may be signaled on an illegal instruction.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  A Logical Processor May Wake From Shutdown State When BranchTrace Messages or Branch-Trace Stores Are Enabled  	  Normally, a logical processor that entered the shutdown state will remain in that state until a break event (NMI, SMI, INIT) occurs. Due to this erratum, if CR4.MCE (Machine Check Enable) is 0 and a branch-trace message or branch-trace store is pending at the time of a machine check, the processor may not remain in shutdown state. In addition, if the processor was in VMX non-root operation when it improperly woke from shutdown state, a subsequent VM exit may save a value of 2 into the activity-state field in the VMCS (indicating shutdown) even though the VM exit did not occur while in shutdown state.  	  This erratum may result in unexpected system behavior. If a VM exit saved a value of 2 into the activity-state field in the VMCS, the next VM entry will take the processor to shutdown state.  	 Software should ensure that CR4.MCE is set whenever IA32_DEBUGCTL MSR (60EH) TR bit [6] is set. 	  44  For the steppings affected, see the Summary Table of Changes.   
  Task Switch to a TSS With an Inaccessible LDTR Descriptor May Cause Unexpected Faults  	  A task switch may load the LDTR (Local Descriptor Table Register) with an incorrect segment descriptor if the LDT (Local Descriptor Table) segment selector in the new TSS specifies an inaccessible location in the GDT (Global Descriptor Table).  	  Future accesses to the LDT may result in unpredictable system behavior.  	 Operating system code should ensure that segment selectors used during task switches to the GDT specify offsets within the limit of the GDT and that the GDT is fully paged into memory. 	  For the steppings affected, see the Summary Table of Changes. 
  Unexpected Load May Occur on Execution of Certain Opcodes  	  If software executes an instruction with an opcode of the form 66 0F 38 8x (where x is in the range 0 to 6), the processor may unexpectedly perform a load operation (the data loaded is not used). The load occurs even if the instruction causes a VM exit or a fault (including an invalid-opcode exception). If the VMXON instruction has been executed successfully, the load is from the physical address in the VMXON pointer plus 408H; otherwise, it is from physical address 407H. The affected opcodes include the INVEPT and INVVPID instructions as well as five invalid opcodes.  	  This erratum may cause incorrect side effects if the load accesses a memory-mapped I/ O device. Intel has not observed this erratum with any commercially available system.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  EOI-Broadcast Suppression May Not Function Properly if Enabled or Disabled While an Interrupt is in Service  	  If a processor supports EOI-broadcast suppression, a write to the local APIC's EOI register does not generate a broadcast EOI (even if the interrupt is level-triggered) if bit 12 of the local APIC's SVR (Spurious-Interrupt Vector Register) is set at the time of the write. Due to this erratum, the local APIC decides whether to generate a broadcast EOI based on the value that bit 12 of the SVR had at the time at which the most recent interrupt was delivered or the time of the most recent write to the EOI register (whichever is later).  	  If software modifies bit 12 of SVR while servicing an interrupt, the next write to the EOI register may not use the new bit value.  	 Software should not modify bit 12 of SVR while servicing a level-triggered interrupt. 	  For the steppings affected, see the Summary Table of Changes. 
  A First Level Data Cache Parity Error May Result in Unexpected Behavior  	  When a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior.  	  Due to this erratum unpredictable system behavior may occur. Intel has not observed this erratum with any commercially available system.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   45  
  An Event May Intervene Before a System Management Interrupt That Results from IN or INS  	  If an I/O instruction (IN, INS, OUT, or OUTS) results in an SMI (system-management interrupt), the processor will set the IO_SMI bit at offset 7FA4H in SMRAM. This interrupt should be delivered immediately after execution of the I/O instruction so that the software handling the SMI can cause the I/O instruction to be re-executed. Due to this erratum, it is possible for another event (e.g., a nonmaskable interrupt) to be delivered before the SMI that follows the execution of an IN or INS instruction.  	  If software handling an affected SMI uses I/O instruction restart, the handler for the intervening event will not be executed.  	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Table of Changes. 
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	  Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used.  	 Software can avoid this by: 1. Avoid using Freeze PerfMon on PMI bit 2. Enable only one fixed counter at a time when using Freeze PerfMon on PMI 	  For the steppings affected, see the Summary Table of Changes. 
  VM Exits Due to “NMI-Window Exiting” May Not Occur Following a VM Entry to the Shutdown State  	  If VM entry is made with the "virtual NMIs" and "NMI-window exiting", VM-execution controls set to 1, and if there is no virtual-NMI blocking after VM entry, a VM exit with exit reason "NMI window" should occur immediately after VM entry unless the VM entry put the logical processor in the wait-for SIPI state. Due to this erratum, such VM exits do not occur if the VM entry put the processor in the shutdown state.  	  A VMM may fail to deliver a virtual NMI to a virtual machine in the shutdown state.  	 Before performing a VM entry to the shutdown state, software should check whether the “virtual NMIs” and “NMI-window exiting” VM-execution controls are both 1. If they are, software should clear “NMI-window exiting” and inject an NMI as part of VM entry. 	  46  For the steppings affected, see the Summary Table of Changes.   
  Execution of INVVPID Outside 64-Bit Mode Cannot Invalidate Translations For 64-Bit Linear Addresses  	  Executions of the INVVPID instruction outside 64-bit mode with the INVVPID type "individual-address invalidation" ignore bits 63:32 of the linear address in the INVVPID descriptor and invalidate translations for bits 31:0 of the linear address.  	  The INVVPID instruction may fail to invalidate translations for linear addresses that set bits in the range 63:32. Because this erratum applies only to executions outside 64-bit mode, it applies only to attempts by a 32-bit virtual-machine monitor (VMM) to invalidate translations for a 64-bit guest. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  A Combination of Data Accesses That Are Split Across Cacheline Boundaries May Lead to a Processor Hang  	  Under certain complex micro-architectural conditions, closely spaced data accesses that are split across cacheline boundaries may lead to a processor hang.  	  Due to this erratum, the processor may hang. This erratum has not been observed with any general purpose operating systems.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Package C6 C-State Exit May Result in Uncorrectable Memory Errors  	  On a subset of processors, during package C6 C-State transitions, internal circuit marginality may cause uncorrectable memory errors to occur on exiting Package C6 CState. The errors will be logged in IA32_MCi_STATUS MSR with MCACOD = 0x009F.  	  Uncorrectable memory errors may cause a system reboot/shutdown.  	 A BIOS workaround has been identified. Please refer to the latest version of BIOS Memory Reference Code and release notes. 	  For the steppings affected, see the Summary Table of Changes. 
  VMRESUME May Omit Check of Revision Identifier of Linked VMCS  	  If the VMCS link pointer is valid in the VMCS, VM entry instructions should check that the 32 bits referenced by that pointer contains the processor’s VMCS revision identifier and fail if it does not. Due to this erratum, VMRESUME may omit this check and thus not cause VM entry to fail in some cases.  	  The revision identifier of the linked VMCS may not be checked. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes.   47  
  An INIT Signal May Cause Unpredictable Behavior After a VMXOFF  	  If software has used VMX-preemption timer and subsequently leaves VMX operation using VMXOFF, then an INIT signal may result in unpredictable behavior.  	  This erratum may lead to unpredictable behavior, including a system hang. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  APIC Timer Interrupts May be Lost During Core C3  	  APIC timer interrupts intended to awaken from core C3 may be lost under certain timing conditions.  	  Due to this erratum, a lost timer interrupt may cause the system to hang.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  MCI_ADDR May be Incorrect For Cache Parity Errors  	  In cases when a WBINVD instruction evicts a line containing an address or data parity error (MCACOD of 0x124, and MSCOD of 0x10), the address of this error should be logged in the MCi_ADDR register. Due to this erratum, the logged address may be incorrect, even though MCi_Status.ADDRV (bit 63) is set.  	  The address reported in MCi_ADDR may not be correct for cases of a parity error found during WBINVD execution.  	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	  The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.  	 None identified. 	NA
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions as described in the Software Developers Manual section "Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors" the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	  Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes.   17 
  Code Segment Limit/Canonical Faults on RSM May Be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g., NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commerciallyavailable software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	  Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. • If an instruction that performs a memory load causes a code segment limit violation. • If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending. • If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Topof-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	  In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the sideeffect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception.  	 Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when  18   accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	  With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed for Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM Will Be Incorrect after an Exit from SMM  	  Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   19 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	  When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e., residual stack data as a result of processing the fault).  	  Data in the created stack frame may be altered following a fault on the ENTER instruction. Refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer's Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in Ring 3. Faults are usually processed in Ring 0 and stack switch occurs when transferring to Ring 0. Intel has not observed this erratum on any commercially-available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	  In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame.  	 Software should not generate misaligned stack frames for use with IRET. 	  20  For the steppings affected, see the Summary Tables of Changes.  
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g., Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	  Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4-G limit (0ffffffffh) may not signal a #GP fault.  	  When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault.  	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4-G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with Bits 63 to 48 incorrectly sign extended to all 1's. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   21 
  Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	  The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially-available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first FAR JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	  The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first FAR JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the FAR JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially-available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Read Miss to Level 3 Cache Fill Occupancy Counter may be Incorrect  	  Whenever an Level 3 cache fill conflicts with another request's address, the miss to fill occupancy counter, UNC_GQ_ALLOC.RT_LLC_MISS (Event 02H), will provide erroneous results.  	  The Performance Monitoring UNC_GQ_ALLOC.RT_LLC_MISS event may count a value higher than expected. The extent to which the value is higher than expected is determined by the frequency of the L3 address conflict.  	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.  
  A VM Exit on MWAIT May Incorrectly Report the Monitoring Hardware as Armed  	  A processor write to the address range armed by the MONITOR instruction may not immediately trigger the monitoring hardware. Consequently, a VM exit on a later MWAIT may incorrectly report the monitoring hardware as armed, when it should be reported as unarmed due to the write occurring prior to the MWAIT.  	  If a write to the range armed by the MONITOR instruction occurs between the MONITOR and the MWAIT, the MWAIT instruction may start executing before the monitoring hardware is triggered. If the MWAIT instruction causes a VM exit, this could cause its exit qualification to incorrectly report 0x1. In the recommended usage model for MONITOR/MWAIT, there is no write to the range armed by the MONITOR instruction between the MONITOR and the MWAIT.  	 Software should never write to the address range armed by the MONITOR instruction between the MONITOR and the subsequent MWAIT. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event SEGMENT_REG_LOADS Counts Inaccurately  	  The performance monitor event SEGMENT_REG_LOADS (Event 06H) counts instructions that load new values into segment registers. The value of the count may be inaccurate.  	  The performance monitor event SEGMENT_REG_LOADS may reflect a count higher or lower than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler’s stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	NA	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Improper Parity Error Signaled in the IQ Following Reset When a Code Breakpoint is Set on a #GP Instruction  	  While coming out of cold reset or exiting from C6, if the processor encounters an instruction longer than 15 bytes (which causes a #GP) and a code breakpoint is enabled on that instruction, an IQ (Instruction Queue) parity error may be incorrectly logged resulting in an MCE (Machine Check Exception).  	  When this erratum occurs, an MCE may be incorrectly signaled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially-available software or system.  	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MPERF Counter Stops Counting During On-Demand TM1  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, the ratio of IA32_MPERF (MSR E7H) to IA32_APERF (MSR E8H) should reflect actual performance while TM1 or on-demand throttling is activated. Due to this erratum, IA32_MPERF MSR stops counting while TM1 or on-demand throttling is activated, and the ratio of the two will indicate higher processor performance than actual.  	  The incorrect ratio of IA32_APERF/IA32_MPERF can mislead software P-state (performance state) management algorithms under the conditions described above. It is possible for the Operating System to observe higher processor utilization than actual, which could lead the OS into raising the P-state. During TM1 activation, the OS P-state request is irrelevant and while on-demand throttling is enabled, it is expected that the OS will not be changing the P-state. This erratum should result in no practical implication to software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Synchronous Reset of IA32_APERF/IA32_MPERF Counters on Overflow Does Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. This synchronous reset does not work. Instead, both MSRs increment and overflow independently.  	  Software can not rely on synchronous reset of the IA32_APERF/IA32_MPERF registers.  	 None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.  
  Disabling Thermal Monitor While Processor is Hot, Then Re-enabling, May Result in Stuck Core Operating Ratio  	  If a processor is at its TCC (Thermal Control Circuit) activation temperature and then Thermal Monitor is disabled by a write to IA32_MISC_ENABLES MSR (1A0H) bit [3], a subsequent re-enable of Thermal Monitor will result in an artificial ceiling on the maximum core P-state. The ceiling is based on the core frequency at the time of Thermal Monitor disable. This condition will only correct itself once the processor reaches its TCC activation temperature again.  	  Since Intel requires that Thermal Monitor be enabled in order to be operating within specification, this erratum should never be seen during normal operation.  	 Software should not disable Thermal Monitor during processor operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	  An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.  	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  xAPIC Timer May Decrement Too Quickly Following an Automatic Reload While in Periodic Mode  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	  When the xAPIC Timer is automatically reloaded by counting down to zero in periodic mode, the xAPIC Timer may slip in its synchronization with the external clock. The xAPIC timer may be shortened by up to one xAPIC timer tick.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   25 
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	  Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type.  	 Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially-available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
 details removed from the specification update document.  26  	NA	NA	NA	NA
  Delivery of Certain Events Immediately Following a VM Exit May Push a Corrupted RIP onto the Stack  	  If any of the following events is delivered immediately following a VM exit to 64-bit mode from outside 64-bit mode, bits 63:32 of the RIP value pushed on the stack may be cleared to 0: • A non-maskable interrupt (NMI); • A machine-check exception (#MC); • A page fault (#PF) during instruction fetch; or • A general-protection exception (#GP) due to an attempt to decode an instruction whose length is greater than 15 bytes.  	  Unexpected behavior may occur due to the incorrect value of the RIP on the stack. Specifically, return from the event handler via IRET may encounter an unexpected page fault or may begin fetching from an unexpected code address.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Infinite Stream of Interrupts May Occur if an ExtINT Delivery Mode Interrupt is Received while All Cores in C6  	  If all logical processors in a core are in C6, an ExtINT delivery mode interrupt is pending in the xAPIC and interrupts are blocked with EFLAGS.IF=0, the interrupt will be processed after C6 wakeup and after interrupts are re-enabled (EFLAGS.IF=1). However, the pending interrupt event will not be cleared.  	  Due to this erratum, an infinite stream of interrupts will occur on the core servicing the external interrupt. Intel has not observed this erratum with any commercially-available software/system.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Two xAPIC Timer Event Interrupts May Unexpectedly Occur  	  If an xAPIC timer event is enabled and while counting down the current count reaches 1 at the same time that the processor thread begins a transition to a low power Cstate, the xAPIC may generate two interrupts instead of the expected one when the processor returns to C0.  	  Due to this erratum, two interrupts may unexpectedly be generated by an xAPIC timer event.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   27 
  EOI Transaction May Not be Sent if Software Enters Core C6 During an Interrupt Service Routine  	  If core C6 is entered after the start of an interrupt service routine but before a write to the APIC EOI (End of Interrupt) register, and the core is woken up by an event other than a fixed interrupt source the core may drop the EOI transaction the next time APIC EOI register is written and further interrupts from the same or lower priority level will be blocked.  	  EOI transactions and interrupts may be blocked when core C6 is used during interrupt service routines. Intel has not observed this erratum with any commercially-available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  FREEZE_WHILE_SMM Does Not Prevent Event From Pending PEBS During SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if 1. A performance counter overflowed before an SMI 2. A PEBS record has not yet been generated because another count of the event has not occurred 3. The monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM.  	  A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  28  For the steppings affected, see the Summary Tables of Changes.  
  DR6 May Contain Incorrect Information When the First Instruction After a MOV SS,r/m or POP SS is a Store  	  Normally, each instruction clears the changes in DR6 (Debug Status Register) caused by the previous instruction. However, the instruction following a MOV SS,r/m (MOV to the stack segment selector) or POP SS (POP stack segment selector) instruction will not clear the changes in DR6 because data breakpoints are not taken immediately after a MOV SS,r/m or POP SS instruction. Due to this erratum, any DR6 changes caused by a MOV SS,r/m or POP SS instruction may be cleared if the following instruction is a store.  	  When this erratum occurs, incorrect information may exist in DR6. This erratum will not be observed under normal usage of the MOV SS,r/m or POP SS instructions (i.e., following them with an instruction that writes [e/r]SP). When debugging or when developing debuggers, this behavior should be noted.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May Also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_PERF_GLOBAL_CTRL MSR May Be Incorrectly Initialized  	  The IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [34:32] may be incorrectly set to 7H after reset; the correct value should be 0H.  	  The IA32_PERF_GLOBAL_CTRL MSR bits [34:32] may be incorrect after reset (EN_FIXED_CTR{0, 1, 2} may be enabled).  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counter INST_RETIRED.STORES May Count Higher than Expected  	  Performance Monitoring counter INST_RETIRED.STORES (Event: C0H) is used to track retired instructions which contain a store operation. Due to this erratum, the processor may also count other types of instructions including WRMSR and MFENCE.  	  Performance Monitoring counter INST_RETIRED.STORES may report counts higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29 
  Sleeping Cores May Not be Woken Up on Logical Cluster Mode Broadcast IPI Using Destination Field Instead of Shorthand  	  If software sends a logical cluster broadcast IPI using a destination shorthand of 00B (No Shorthand) and writes the cluster portion of the Destination Field of the Interrupt Command Register to all ones while not using all 1s in the mask portion of the Destination Field, target cores in a sleep state that are identified by the mask portion of the Destination Field may not be woken up. This erratum does not occur if the destination shorthand is set to 10B (All Including Self) or 11B (All Excluding Self).  	  When this erratum occurs, cores which are in a sleep state may not wake up to handle the broadcast IPI. Intel has not observed this erratum with any commercially-available software.  	 Use destination shorthand of 10B or 11B to send broadcast IPIs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Faulting Executions of FXRSTOR May Update State Inconsistently  	  The state updated by a faulting FXRSTOR instruction may vary from one execution to another.  	  Software that relies on x87 state or SSE state following a faulting execution of FXRSTOR may behave inconsistently.  	 Software handling a fault on an execution of FXRSTOR can compensate for execution variability by correcting the cause of the fault and executing FXRSTOR again. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event EPT.EPDPE_MISS May be Counted While EPT is Disable  	  Performance monitor event EPT.EPDPE_MISS (Event: 4FH, Umask: 08H) is used to count Page Directory Pointer table misses while EPT (extended page tables) is enabled. Due to this erratum, the processor will count Page Directory Pointer table misses regardless of whether EPT is enabled or not.  	  Due to this erratum, performance monitor event EPT.EPDPE_MISS may report counts higher than expected.  	 Software should ensure this event is only enabled while in EPT mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  Memory Aliasing of Code Pages May Cause Unpredictable System Behavior  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncachable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	  If this erratum occurs the system may have unpredictable behavior including a system hang. The aliasing of memory regions, a condition necessary for this erratum to occur, is documented as being unsupported in the Intel 64 and IA-32 Intel® Architecture Software Developer's Manual, Volume 3A, in the section titled Programming the PAT. Intel has not observed this erratum with any commercially-available software or system.  	 Code pages should not be mapped with uncacheable and cacheable memory types at the same time. 	  30  For the steppings affected, see the Summary Tables of Changes.  
  Performance Monitor Counters May Count Incorrectly  	  Under certain circumstances, a general purpose performance counter, IA32_PMC0-4 (C1H - C4H), may count at core frequency or not count at all instead of counting the programmed event.  	  The Performance Monitor Counter IA32_PMCx may not properly count the programmed event. Due to the requirements of the workaround there may be an interruption in the counting of a previously programmed event during the programming of a new event.  	 Before programming the performance event select registers, IA32_PERFEVTSELx MSR (186H - 189H), the internal monitoring hardware must be cleared. This is accomplished by first disabling, saving valid events and clearing from the select registers, then programming three event values 0x4300D2, 0x4300B1 and 0x4300B5 into the IA32_PERFEVTSELx MSRs, and finally continuing with new event programming and restoring previous programming if necessary. Each performance counter, IA32_PMCx, must have its corresponding IA32_PREFEVTSELx MSR programmed with at least one of the event values and must be enabled in IA32_PERF_GLOBAL_CTRL MSR (38FH) bits [3:0]. All three values must be written to either the same or different IA32_PERFEVTSELx MSRs before programming the performance counters. Note that the performance counter will not increment when its IA32_PERFEVTSELx MSR has a value of 0x4300D2, 0x4300B1 or 0x4300B5 because those values have a zero UMASK field (bits [15:8]). 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Event Offcore_response_0 (B7H) Does Not Count NT Stores to Local DRAM Correctly  	  When a IA32_PERFEVTSELx MSR is programmed to count the Offcore_response_0 event (Event:B7H), selections in the OFFCORE_RSP_0 MSR (1A6H) determine what is counted. The following two selections do not provide accurate counts when counting NT (Non-Temporal) Stores: • OFFCORE_RSP_0 MSR bit [14] is set to 1 (LOCAL_DRAM) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are not counted when they should have been. • OFFCORE_RSP_0 MSR bit [9] is set to (OTHER_CORE_HIT_SNOOP) and bit [7] is set to 1 (OTHER): NT Stores to Local DRAM are counted when they should not have been.  	  The counter for the Offcore_response_0 event may be incorrect for NT stores.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   31 
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Back to Back Uncorrected Machine Check Errors May Overwrite IA32_MC3_STATUS.MSCOD  	  When back-to-back uncorrected machine check errors occur that would both be logged in the IA32_MC3_STATUS MSR (40CH), the IA32_MC3_STATUS.MSCOD (bits [31:16]) field may reflect the status of the most recent error and not the first error. The rest of the IA32_MC3_STATUS MSR contains the information from the first error.  	  Software should not rely on the value of IA32_MC3_STATUS.MSCOD if IA32_MC3_STATUS.OVER (bit [62]) is set.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Corrected Errors With a Yellow Error Indication May be Overwritten by Other Corrected Errors  	  A corrected cache hierarchy data or tag error that is reported with IA32_MCi_STATUS.MCACOD (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one) and a yellow threshold-based error status indication (bits [54:53] equal to 10B) may be overwritten by a corrected error with a no tracking indication (00B) or green indication (01B).  	  Corrected errors with a yellow threshold-based error status indication may be overwritten by a corrected error without a yellow indication.  	 None identified. 	  32  For the steppings affected, see the Summary Tables of Changes.  
  Performance Monitor Events DCACHE_CACHE_LD and DCACHE_CACHE_ST May Overcount  	  The performance monitor events DCACHE_CACHE_LD (Event 40H) and DCACHE_CACHE_ST (Event 41H) count cacheable loads and stores that hit the L1 cache. Due to this erratum, in addition to counting the completed loads and stores, the counter will incorrectly count speculative loads and stores that were aborted prior to completion.  	  The performance monitor events DCACHE_CACHE_LD and DCACHE_CACHE_ST may reflect a count higher than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Rapid Core C3/C6 Transitions May Cause Unpredictable System Behavior  	  Under a complex set of internal conditions, cores rapidly performing C3/C6 transitions in a system with Intel® Hyper-Threading Technology enabled may cause a machine check error (IA32_MCi_STATUS.MCACOD = 0x0106), system hang or unpredictable system behavior.  	  This erratum may cause a machine check error, system hang or unpredictable system behavior.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Timer CCR May Report 0 in Periodic Mode  	  In periodic mode the APIC timer CCR (current-count register) is supposed to be automatically reloaded from the initial-count register when the count reaches 0, consequently software would never be able to observe a value of 0. Due to this erratum, software may read 0 from the CCR when the timer has counted down and is in the process of re-arming.  	  Due to this erratum, an unexpected value of 0 may be read from the APIC timer CCR when in periodic mode.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Events INSTR_RETIRED and MEM_INST_RETIRED May Count Inaccurately  	  The performance monitor event INSTR_RETIRED (Event C0H) should count the number of instructions retired, and MEM_INST_ RETIRED (Event 0BH) should count the number of load or store instructions retired. However, due to this erratum, they may undercount.  	  The performance monitor event INSTR_RETIRED and MEM_INST_RETIRED may reflect a count lower than the actual number of events.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   33 
  A Page Fault May Not be Generated When the PS bit is set to "1" in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	  Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.  	 Software should not set Bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to "1". 	  For the steppings affected, see the Summary Tables of Changes. 
  BIST Results May be Additionally Reported After a GETSEC[WAKEUP] or INIT-SIPI Sequence  	  BIST results should only be reported in EAX the first time a logical processor wakes up from the Wait-For-SIPI state. Due to this erratum, BIST results may be additionally reported after INIT-SIPI sequences and when waking up RLP's from the SENTER sleep state using the GETSEC[WAKEUP] command.  	  An INIT-SIPI sequence may show a non-zero value in EAX upon wakeup when a zero value is expected. RLP's waking up for the SENTER sleep state using the GETSEC[WAKEUP] command may show a different value in EAX upon wakeup than before going into the SENTER sleep state.  	 If necessary software may save the value in EAX prior to launching into the secure environment and restore upon wakeup and/or clear EAX after the INIT-SIPI sequence. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	  Software may observe #MF being signaled before pending interrupts are serviced.  	 None identified. 	  34  For the steppings affected, see the Summary Tables of Changes.  
  VM Exits Due to "NMI-Window Exiting" May Be Delayed by One Instruction  	  If VM entry is executed with the "NMI-window exiting" VM-execution control set to 1, a VM exit with exit reason "NMI window" should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	  VMM software using "NMI-window exiting" for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Memory Controller tTHROT_OPREF Timings May be Violated During Self Refresh Entry  	  During self refresh entry, the memory controller may issue more refreshes than permitted by tTHROT_OPREF (bits 29:19 in MC_CHANNEL_{0,1}_REFRESH_TIMING CSR).  	  The intention of tTHROT_OPREF is to limit current. Since current supply conditions near self refresh entry are not critical, there is no measurable impact due to this erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to EPT Violations Do Not Record Information About PreIRET NMI Blocking  	  With certain settings of the VM-execution controls VM exits due to EPT violations set bit 12 of the exit qualification if the EPT violation was a result of an execution of the IRET instruction that commenced with non-maskable interrupts (NMIs) blocked. Due to this erratum, such VM exits will instead clear this bit.  	  Due to this erratum, a virtual-machine monitor that relies on the proper setting of bit 12 of the exit qualification may deliver NMIs to guest software prematurely.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Multiple Performance Monitor Interrupts are Possible on Overflow of IA32_FIXED_CTR2  	  When multiple performance counters are set to generate interrupts on an overflow and more than one counter overflows at the same time, only one interrupt should be generated. However, if one of the counters set to generate an interrupt on overflow is the IA32_FIXED_CTR2 (MSR 30BH) counter, multiple interrupts may be generated when the IA32_FIXED_CTR2 overflows at the same time as any of the other performance counters.  	  Multiple counter overflow interrupts may be unexpectedly generated.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   35 
  LBRs May Not be Initialized During Power-On Reset of the Processor  	  If a second reset is initiated during the power-on processor reset cycle, the LBRs (Last Branch Records) may not be properly initialized.  	  Due to this erratum, debug software may not be able to rely on the LBRs out of poweron reset.  	 Ensure that the processor has completed its power-on reset cycle prior to initiating a second reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTM or BTS Records May have Incorrect Branch From Information After an EIST Transition, T-states, C1E, or Adaptive Thermal Throttling  	  The "From" address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after an EIST (Enhanced Intel® SpeedStep Technology) transition, T-states, C1E (C1 Enhanced), or Adaptive Thermal Throttling.  	  When the LBRs, BTM or BTS are enabled, some records may have incorrect branch "From" addresses for the first branch after an EIST transition, T-states, C1E, or Adaptive Thermal Throttling.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMX-Preemption Timer Does Not Count Down at the Rate Specified  	  The VMX-preemption timer should count down by 1 every time a specific bit in the TSC (Time Stamp Counter) changes. (This specific bit is indicated by IA32_VMX_MISC bits [4:0] (0x485h) and has a value of 5 on the affected processors.) Due to this erratum, the VMX-preemption timer may instead count down at a different rate and may do so only intermittently.  	  The VMX-preemption timer may cause VM exits at a rate different from that expected by software.  	 None identified. 	  36  For the steppings affected, see the Summary Tables of Changes.  
  Multiple Performance Monitor Interrupts are Possible on Overflow of Fixed Counter 0  	  The processor can be configured to issue a PMI (performance monitor interrupt) upon overflow of the IA32_FIXED_CTR0 MSR (309H). A single PMI should be observed on overflow of IA32_FIXED_CTR0, however multiple PMIs are observed when this erratum occurs. This erratum only occurs when IA32_FIXED_CTR0 overflows and the processor and counter are configured as follows: • Intel® Hyper-Threading Technology is enabled • IA32_FIXED_CTR0 local and global controls are enabled • IA32_FIXED_CTR0 is set to count events only on its own thread (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] = ‘0) • PMIs are enabled on IA32_FIXED_CTR0 (IA32_FIXED_CTR_CTRL MSR bit [3] = ‘1) • Freeze_on_PMI feature is enabled (IA32_DEBUGCTL MSR (1D9H) bit [12] = ‘1)  	  When this erratum occurs there may be multiple PMIs observed when IA32_FIXED_CTR0 overflows  	 Disable the FREEZE_PERFMON_ON_PMI feature in IA32_DEBUGCTL MSR (1D9H) bit [12]. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to LIDT/LGDT/SIDT/SGDT Do Not Report Correct Operand Size  	  When a VM exit occurs due to a LIDT, LGDT, SIDT, or SGDT instruction with a 32-bit operand, bit 11 of the VM-exit instruction information field should be set to 1. Due to this erratum, this bit is instead cleared to 0 (indicating a 16-bit operand).  	  Virtual-machine monitors cannot rely on bit 11 of the VM-exit instruction information field to determine the operand size of the instruction causing the VM exit.  	 Virtual Machine Monitor software may decode the instruction to determine operand size. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA May Not Count Events Correctly  	  Performance Monitor Events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA should only increment the count when a load is blocked by a store. Due to this erratum, the count will be incremented whenever a load hits a store, whether it is blocked or can forward. In addition this event does not count for specific threads correctly.  	  If Intel® Hyper-Threading Technology is disabled, the Performance Monitor events STORE_BLOCKS.NOT_STA and STORE_BLOCKS.STA may indicate a higher occurrence of loads blocked by stores than have actually occurred. If Intel Hyper-Threading Technology is enabled, the counts of loads blocked by stores may be unpredictable and they could be higher or lower than the correct count.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   37 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	  When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	  The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially-available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Following INVEPT or INVVPID May Fail to Flush All Translations for a Large Page  	  This erratum applies if the address of the memory operand of an INVEPT or INVVPID instruction resides on a page larger than 4KBytes and either (1) that page includes the low 1 MBytes of physical memory; or (2) the physical address of the memory operand matches an MTRR that covers less than 4 MBytes. A subsequent execution of INVLPG that targets the large page and that occurs before the next VM-entry instruction may fail to flush all TLB entries for the page. Such entries may persist in the TLB until the next VM-entry instruction.  	  Accesses to the large page between INVLPG and the next VM-entry instruction may incorrectly use translations that are inconsistent with the in-memory page tables.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  38  For the steppings affected, see the Summary Tables of Changes.  
  Logical Processor May Use Incorrect VPID after VM Entry That Returns From SMM  	  A logical processor in VMX root operation should use VPID 0000H. Due to this erratum, a logical processor may instead use VPID 1FB3H if VMX root operation was entered using a VM entry that returns from SMM.  	  After a VM entry that sets the "enable VPID" VM-execution control and that establishes VPID 1FB3H, the logical processor may erroneously use TLB entries that were cached in VMX root operation.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Memory Controller May Hang Due to Uncorrectable ECC Errors or Parity Errors Occurring on Both Channels in Mirror Channel Mode  	  If an uncorrectable ECC or parity error occurs on the mirrored channel before an uncorrectable ECC or parity error on the other channel can be resolved, the Memory Controller may hang without an uncorrectable ECC or parity error being logged.  	  The processor may hang and not report the error when uncorrectable ECC or parity errors occur in close proximity on both channels in a mirrored channel pair. No uncorrectable ECC or parity error will be logged in the machine check banks.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MSR_TURBO_RATIO_LIMIT MSR May Return Intel® Turbo Boost Technology Core Ratio Multipliers for Non-Existent Core Configurations  	  MSR_TURBO_RATIO_LIMIT MSR (1ADH) is designed to describe the maximum Intel Turbo Boost Technology potential of the processor. On some processors, a non-zero Intel Turbo Boost Technology value will be returned for non-existent core configurations.  	  Due to this erratum, software using the MSR_TURBO_RATIO_LIMIT MSR to report Intel Turbo Boost Technology processor capabilities may report erroneous results.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Internal Parity Error May Be Incorrectly Signaled during C6 Exit  	  In a complex set of internal conditions an internal parity error may occur during a Core C6 exit.  	  Due to this erratum, an uncorrected error may be reported and a machine check exception may be triggered.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   39 
  PMIs during Core C6 Transitions May Cause the System to Hang  	  If a performance monitoring counter overflows and causes a PMI (Performance Monitoring Interrupt) at the same time that the core enters C6, then this may cause the system to hang.  	  Due to this erratum, the processor may hang when a PMI coincides with core C6 entry.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  2MB Page Split Lock Accesses Combined With Complex Internal Events May Cause Unpredictable System Behavior  	  A 2MB Page Split Lock (a locked access that spans two 2MB large pages) coincident with additional requests that have particular address relationships in combination with a timing sensitive sequence of complex internal conditions may cause unpredictable system behavior.  	  This erratum may cause unpredictable system behavior. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  If the APIC timer Divide Configuration Register (Offset 03E0H) is written at the same time that the APIC timer Current Count Register (Offset 0390H) reads 1H, it is possible that the APIC timer will deliver two interrupts.  	  If the APIC timer Divide Configuration Register (Offset 03E0H) is written at the same time that the APIC timer Current Count Register (Offset 0390H) reads 1H, it is possible that the APIC timer will deliver two interrupts.  	  Due to this erratum, two interrupts may unexpectedly be generated by an APIC timer event.  	 Software should reprogram the Divide Configuration Register only when the APIC timer interrupt is disarmed. 	  For the steppings affected, see the Summary Tables of Changes. 
  TXT.PUBLIC.KEY is Not Reliable  	  On Intel® TXT (Intel® Trusted Execution Technology) capable processors, the TXT.PUBLIC.KEY value (Intel TXT registers FED3_0400H to FED3_041FH) is not reliable.  	  Due to this erratum, the TXT.PUBLIC.KEY value should not be relied on or used for retrieving the hash of the TXT public key for the platform.  	 None identified. 	  40  For the steppings affected, see the Summary Tables of Changes.  
  8259 Virtual Wire B Mode Interrupt May Be Dropped When it Collides With Interrupt Acknowledge Cycle From the Preceding Interrupt  	  If an un-serviced 8259 Virtual Wire B Mode (8259 connected to IOAPIC) External Interrupt is pending in the APIC and a second 8259 Virtual Wire B Mode External Interrupt arrives, the processor may incorrectly drop the second 8259 Virtual Wire B Mode External Interrupt request. This occurs when both the new External Interrupt and Interrupt Acknowledge for the previous External Interrupt arrive at the APIC at the same time.  	  to this erratum, any further 8259 Virtual Wire B Mode External Interrupts will subsequently be ignored.  	 Do not use 8259 Virtual Wire B mode when using the 8259 to deliver interrupts. 	  For the steppings affected, see the Summary Tables of Changes. 
  The APIC Timer Current Count Register May Prematurely Read 0x0 While the Timer is Still Running  	  The APIC Timer Current Counter Register may prematurely read 0x00000000 while the timer is still running. This problem occurs when a core frequency or C-state transition occurs while the APIC timer countdown is in progress.  	  Due to this erratum, certain software may incorrectly assess that the APIC timer countdown is complete when it is actually still running. This erratum does not affect the delivery of the timer interrupt.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Secondary PCIe Port May Not Train After A Warm Reset  	  In a dual PCIe port configuration, the secondary PCIe port may not train after a warm reset.  	  The second PCIe port and therefore any device connected to the PCIe bus instantiated by that PCIe port may not be functional after a warm reset. Intel has not observed this erratum with any commercially available system.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   41 
  The PECI Bus May Be Tri-stated after System Reset  	  During power-up, the processor may improperly assert the PECI (Platform Environment Control Interface) pin. This condition is cleared as soon as Bus Clock starts toggling. However, if the PECI host (also referred to as the master or originator) incorrectly determines this asserted state as another PECI host initiating a transaction, it may release control of the bus resulting in a permanent tri-state condition.  	  Due to this erratum, the PECI host may incorrectly determine that it is not the bus master and consequently PECI commands initiated by the PECI software layer may receive incorrect/invalid responses.  	 To workaround this erratum the PECI host should pull the PECI bus low to initiate a PECI transaction. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Combination of a Page-Split Lock Access And Data Accesses That Are Split Across Cacheline Boundaries May Lead to Processor Livelock  	  Under certain complex micro-architectural conditions, the simultaneous occurrence of a page-split lock and several data accesses that are split across cacheline boundaries may lead to processor livelock.  	  Due to this erratum, a livelock may occur that can only be terminated by a processor reset. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor Hangs on Package C6 State Exit  	  An internal timing condition in the processor power management logic will result in processor hangs upon a Package C6 state exit.  	  Due to this erratum, the processor will hang during Package C6 state exit.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Synchronous SMI May be Delayed  	  A synchronous SMI (System Management Interrupt) occurs as a result of an SMI generating I/O Write instruction and should be handled prior to the next instruction executing. Due to this erratum, the processor may not observe the synchronous SMI prior to execution of the next instruction.  	  Due to this erratum, instructions after the I/O Write instruction, which triggered the SMI, may be allowed to execute before the SMI handler. Delayed delivery of the SMI may make it difficult for an SMI Handler to determine the source of the SMI. Software that relies on the IO_SMI bit in SMM save state or synchronous SMI behavior may not function as expected.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  42  For the steppings affected, see the Summary Tables of Changes.  
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express x16 Port Links May Fail to Dynamically Switch From 5.0GT/s to 2.5GT/s  	  If an endpoint device initiates a PCI Express speed change from 5.0 GT/s to 2.5 GT/s, the link may incorrectly go into Recovery.Idle rather than the expected Recovery.Speed state. This may cause the link to lose sync, eventually resulting in a link down. The link will recover and re-train to the L0 state, however any outstanding packets queued during the speed change may be lost.  	  Due to this erratum, the link may lose sync resulting in link down with queued packet being lost. No known failures have been observed on systems using production PCI Express graphics cards. This erratum has only been observed in a synthetic test environment.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express Cards May Not Train to x16 Link Width  	  The Maximum Link Width field in the Link Capabilities register (LCAP; Bus 0; Device 1; Function 0; offset 0xAC; bits [9:4]) may limit the width of the PCI Express link to x8, even though the processor may actually be capable of supporting the full x16 width.  	  PCI Express x16 Graphics Cards used in normal operation and PCI Express CLB (Compliance Load Board) Cards used during PCI Express Compliance mode testing may only train to x8 link width.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected Graphics VID Transition During Warm Reset May Cause the System to Hang  	  During a warm reset to the processor, the graphics VID (Voltage ID) may transition to an unexpected value that may cause the voltage regulator to shut off.  	  The processor may hang during integrated graphics initialization. Cold boots and platforms using discrete graphics are not affected by this issue.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum.   43  	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May Be Lost  	  The IO_SMI bit (bit 0) in the IO state field at SMRAM offset 7FA4H is set to "1" by the processor to indicate a System Management Interrupt (SMI) is either taken immediately after a successful I/O instruction or is taken after a successful iteration of a REP I/O instruction. Due to this erratum, the setting of the IO_SMI bit may be lost. This may happen under a complex set of internal conditions with Intel® HyperThreading Technology enabled and has not been observed with commercially available software.  	  Due to this erratum, SMI handlers may not be able to identify the occurrence of I/O SMIs.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry to 64-Bit Mode May Fail if Bits 48 And 47 of Guest RIP Are Different  	  VM entry to 64-bit mode should allow any value for bits [47:0] of the RIP field in the guest-state area as long as bits 63:48 are identical. Due to this erratum, such a VM entry may fail if bit 47 of the field has a value different from that of bit 48.  	  It is not possible to perform VM entry to a 64-bit guest that has made a transition to a non-canonical instruction pointer.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry Loading an Unusable SS Might Not Set SS.B to 1  	  If the unusable bit (bit 16) is 1 in the guest SS (Stack Segment) access-rights field, VM entry should set the B bit (default stack-pointer size) in the SS (stack segment) register to 1. Due to this erratum, VM entry may instead load SS.B from bit 14 of the guest SS access-rights field, potentially clearing SS.B to 0.  	  This erratum can affect software only if a far RET instruction is executed after a VM entry that erroneously clears the B bit and only if the following other three conditions are also true: (1) the SS register is not loaded between VM entry and far RET; (2) the far RET instruction is executed in 64-bit mode with an immediate operand; (3) the far RET instruction makes a transition to compatibility mode without changing CPL (Current Privilege Level). Due to the far RET being executed with an immediate operand, an adjustment is made to the stack pointer. Normally, when SS is unusable the SS.B bit is 1 and the adjustment will be to the 32-bit ESP register. Due to this erratum, the adjustment will incorrectly be made to the 16-bit SP register. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  FSW May Be Corrupted If an x87 Store Instruction Causes a Page Fault in VMX Non-Root Operation  	  The X87 FSW (FPU Status Word) may be corrupted if execution of a floating-point store instruction (FST, FSTP, FIST, FISTP, FISTTP) causes a page fault in VMX non-root operation.  44   	  This erratum may result in unexpected behavior of software that uses x87 FPU instructions.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  None identified. 
  Under Certain Low Temperature Conditions, Some Uncore Performance Monitoring Events May Report Incorrect Results  	  Due to this erratum, under certain low operating temperatures, a small number of Last Level Cache and external bus performance monitoring events in the uncore report incorrect counts. This erratum may affect event codes in the ranges 00H to 0CH and 40H to 43H.  	  Due to this erratum, the count value for some uncore Performance Monitoring Events may be inaccurate. The degree of under or over counting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observedthis erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CKE May go Low Within tRFC(min) After a PD Exit  	  After a refresh command is issued, followed by an early PD(Power Down) Entry and Exit, the CKE (Clock Enable) signal may be asserted low prior to tRFC(min), the Minimum Refresh Cycle timing. This additional instance of CKE being low causes the processor not to meet the JEDEC DDR3 DRAM specification requirement (Section 4.17.4 Power-Down clarifications - Case 3).  	  Due to this erratum, the processor may not meet the JEDEC DDR3 DRAM specification requirement that states: “CKE cannot be registered low twice within a tRFC(min) window”. Intel has not observed any functional failure due to this erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
 details removed from the specification update document. 	NA	NA	NA	NA
  Performance Monitor Events for Hardware Prefetches Which Miss The L1 Data Cache May be Over-Counted  	  Hardware prefetches that miss the L1 data cache but cannot be processed immediately due to resource conflicts will count and then retry. This may lead to incorrectly incrementing the L1D_PREFETCH.MISS (event 4EH, umask 02H) event multiple times for a single miss.  	  The count reported by the L1D_PREFETCH.MISS event may be higher than expected.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exit May Incorrectly Clear IA32_PERF_GLOBAL_CTRL [34:32]  	  If the “load IA32_PERF_GLOBAL_CTRL” VM-exit control is 1, a VM exit should load the IA32_PERF_GLOBAL_CTRL MSR (38FH) from the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS. Due to this erratum, such a VM exit may instead clear bits 34:32 of the MSR, loading only bits 31:0 from the VMCS.   45  	  All fixed-function performance counters will be disabled after an affected VM exit, even if the VM exit should have enabled them based on the IA32_PERF_GLOBAL_CTRL field in the guest-state area of the VMCS.  	 A VM monitor that wants the fixed-function performance counters to be enabled after a VM exit may do one of two things: (1) clear the “load IA32_PERF_GLOBAL_CTRL” VMexit control; or (2) include an entry for the IA32_PERF_GLOBAL_CTRL MSR in the VMexit MSR-load list. 	  For the steppings affected, see the Summary Tables of Changes. 
  Correctable and Uncorrectable Cache Errors May be Reported Until the First Core C6 Transition  	  On a subset of processors it is possible that correctable/uncorrectable cache errors may be logged and/or a machine check exception may occur prior to the first core C6 transition. The errors will be logged in IA32_MC5_STATUS MSR (415H) with the MCACOD (Machine Check Architecture Error Code) bits [15:0] indicating a Cache Hierarchy Error of the form 000F 0001 RRRR TTLL.  	  Due to this erratum, correctable/uncorrectable cache error may be logged or signaled.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Accesses to a VMCS May Not Operate Correctly If CR0.CD is Set on Any Logical Processor of a Core  	  The VMX (virtual-machine extensions) are controlled by the VMCS (virtual-machine control structure). If CR0.CD is set on any logical processor of a core, operations using the VMCS may not function correctly. Such operations include the VMREAD and VMWRITE instructions as well as VM entries and VM exits.  	  If CR0.CD is set on either logical processor in a core, the VMWRITE instruction may not correctly update the VMCS and the VMREAD instruction may not return correct data. VM entries may not load state properly and may not establish VMX controls properly. VM exits may not save or load state properly.  	 VMMs (Virtual-machine monitors) should ensure that CR0.CD is clear on all logical processors of a core before entering VMX operation on any logical processor. Software should not set CR0.CD on a logical processor if any logical processor of the same core is in VMX operation. VMM software should prevent guest software from setting CR0.CD by setting bit 30 in the CR0 guest/host mask field in every VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Port’s LTSSM May Not Transition Properly in the Presence of TS1 or TS2 Ordered Sets That Have Unexpected Symbols Within those Sets  	  When a PCIe port receives TS1 and/or TS2 ordered sets with unexpected symbols (per the PCIe Base Specification), the port’s LTSSM (Link Training State Machine) might not transition according to the PCIe Base Specification requirements. The LTSSM may incorrectly stay in its current state, or transition to an incorrect state. If the unexpected symbols are sporadic in nature the link will recover and go to the proper state.  	  PCIe Port’s LTSMM may not transition according to PCIe Base Specification as described above. This problem has not been seen in real system testing, but was discovered by synthetic tests designed to check for illegal conditions.  	 None identified. 	  46  For the steppings affected, see the Summary Tables of Changes.  
  NTB/RP Link Will Send Extra TS2 Ordered Set During Link Training  	  The NTB (Non-Transparent Bridge) when operating in NTB/RP (Root Port) mode will send a superfluous TS2 ordered set after transitioning to the CONFIGURATION.IDLE state during link training. This TS2 ordered set may contain invalid capability data.  	  NTB/RP Link will transmit a TS2 ordered set after transitioning to the CONFIGURATION.IDLE state. No impact expected for specification compliant PCIe partners. Specification compliant PCIe link partners will have transitioned to CONFIGURATION.IDLE before this ordered set is sent and will ignore it.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe Ports May Not Enter Slave Loopback Mode From the Configuration LTSSM State  	  If a PCIe port’s LTSSM (Link Training State Machine) is in the CONFIG.LINK_WIDTH_START state, it may not enter slave loopback mode when requested to do so by the link partner. If the request is missed the link will continue to train and enter the Slave loopback mode after it first transitions through the L0 and RECOVERY LTSSM states.  	  Due to this erratum, PCIe ports may be delayed in entering the slave loopback mode.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  USB Devices May Not Function Properly With Integrated Graphics While Running Targeted Stress Graphics Workloads With NonMatching Memory Configurations  	  When the integrated graphics engine continuously generates a large stream of writes to system memory, and Intel Flex Memory Technology is enabled, with a different amount of memory in each channel, the memory arbiter may temporarily stop servicing other device-initiated traffic. In some cases this can cause certain USB devices, such as keyboard and mouse, to become unresponsive. Intel has only observed this erratum with targeted stress content. This erratum is not seen when the platform is configured with single channel or dual channel symmetric memory and is not dependent on the memory frequency.  	  Due to this erratum, certain USB devices may become unresponsive.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entry May Omit Consistency Checks Related to Bit 14 (BS) of the Pending Debug Exception Field in Guest-State Area of the VMCS  	  Section “Checks on Guest Non-Register State” of Volume 3B specifies consistency checks that VM entry should perform for bit 14 (BS, indicating a pending single-step exception) of the pending debug exception field in guest-state area of the VMCS. These checks enforce the consistency of that bit with other fields in the guest-state area. Due to this erratum, VM entry may fail to perform these checks.  	  A logical processor may enter VMX non-root operation with a pending single-step debug exception that not consistent other register state; this may result in unexpected behavior. Intel has not observed this erratum with any commercially available software.  	 When using VMWRITE to write to a field in the guest-state area, software should ensure that the value written is consistent with the state of other guest-state fields.   47  	  For the steppings affected, see the Summary Tables of Changes. 
  Intel Turbo Boost Technology Ratio Changes May Cause Unpredictable System Behavior  	  When Intel Turbo Boost Technology is enabled as determined by the TURBO_MODE_DISABLE bit being “0” in the IA32_MISC_ENABLES MSR (1A0H), the process of locking to new ratio may cause the processor to run with incorrect ratio settings. The result of this erratum may be unpredictable system behavior.  	  Due to this erratum, unpredictable system behavior may be observed.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of VMPTRLD May Corrupt Memory If Current-VMCS Pointer is Invalid  	  If the VMCLEAR instruction is executed with a pointer to the current-VMCS (virtualmachine control structure), the current-VMCS pointer becomes invalid as expected. A subsequent execution of the VMPTRLD (Load Pointer to Virtual-Machine Control Structure) instruction may erroneously overwrite the four bytes at physical address 0000008FH.  	  Due to this erratum, the four bytes in system memory at physical address 0000008FH may be corrupted.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PerfMon Overflow Status Can Not be Cleared After Certain Conditions Have Occurred  	  Under very specific timing conditions, if software tries to disable a PerfMon counter through MSR IA32_PERF_GLOBAL_CTRL (0x38F) or through the per-counter eventselect (e.g. MSR 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in MSR IA32_PERF_GLOBAL_STAT (0x38E) may be left set with no way for software to clear it.  	  Due to this erratum, software may be unable to clear the PerfMon counter overflow status indication.  	 Software may avoid this erratum by clearing the PerfMon counter value prior to disabling it and then clearing the overflow status indication bit.	NA
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary, since the MOV SS/POP SS and the following instruction should be executed atomically.  	  This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software or system.  	 As recommended in the IA32 Intel® Architecture Software Developer's Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum 	  For the steppings affected, see the Summary Tables of Changes. 
  APIC Error “Received Illegal Vector” May be Lost  	  APIC (Advanced Programmable Interrupt Controller) may not update the ESR (Error Status Register) flag Received Illegal Vector bit [6] properly when an illegal vector error is received on the same internal clock that the ESR is being written (as part of the write-read ESR access flow). The corresponding error interrupt will also not be generated for this case.  	  Due to this erratum, an incoming illegal vector error may not be logged into ESR properly and may not generate an error interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Uncorrectable Error Logged in IA32_CR_MC2_STATUS May also Result in a System Hang  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS MSR (409H) may also result in a system hang causing an Internal Timer Error (MCACOD = 0x0400h) to be logged in another machine check bank (IA32_MCi_STATUS).  	  Uncorrectable errors logged in IA32_CR_MC2_STATUS can further cause a system hang and an Internal Timer Error to be logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   19 
  B0-B3 Bits in DR6 For Non-Enabled Breakpoints May be Incorrectly Set  	  Some of the B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: 1.  MOV or POP instruction to SS (Stack Segment) selector.  2.  Next instruction is FP (Floating Point) that gets FP assist.  3.  Another instruction after the FP instruction completes successfully.  4. A breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. Due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in B0-B3 after the breakpoint occurs in step 4. 	  Due to this erratum, B0-B3 bits in DR6 may be incorrectly set for non-enabled breakpoints.  	 Software should not execute a floating point instruction directly after a MOV SS or POP SS instruction. 	  For the steppings affected, see the Summary Tables of Changes. 
  Changing the Memory Type for an In-Use Page Translation May Lead to Memory-Ordering Violations  	  Under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.  	  Memory ordering may be violated. Intel has not observed this erratum with any commercially available software.  	 Software should ensure pages are not being actively used before requesting their memory type be changed. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a non-canonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	  Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  20  For the steppings affected, see the Summary Tables of Changes.  
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	  The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A: System Programming Guide, Part 1, in the section titled “Switching to Protected Mode” recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Debug Exception Flags DR6.B0-B3 Flags May be Incorrect for Disabled Breakpoints  	  When a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (DR7.G0-G3 and DR7.L0-L3), the DR6.B0-B3 flags may be incorrect.  	  The debug exception DR6.B0-B3 flags may be incorrect for the load if the corresponding breakpoint enable flag in DR7 is disabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR6.B0-B3 May Not Report All Breakpoints Matched When a MOV/POP SS is Followed by a Store or an MMX Instruction  	  Normally, data breakpoints matches that occur on a MOV SS, r/m or POP SS will not cause a debug exception immediately after MOV/POP SS but will be delayed until the instruction boundary following the next instruction is reached. After the debug exception occurs, DR6.B0-B3 bits will contain information about data breakpoints matched during the MOV/POP SS as well as breakpoints detected by the following instruction. Due to this erratum, DR6.B0-B3 bits may not contain information about data breakpoints matched during the MOV/POP SS when the following instruction is either an MMX instruction that uses a memory addressing mode with an index or a store instruction.  	  When this erratum occurs, DR6 may not contain information about all breakpoints matched. This erratum will not be observed under the recommended usage of the MOV SS,r/m or POP SS instructions (i.e., following them only with an instruction that writes (E/R)SP).  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   21 
  EFLAGS Discrepancy on Page Faults and on EPT-Induced VM Exits after a Translation Change  	  This erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate TLB invalidation. When a subsequent access to that address by a specific instruction (ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD) causes a page fault or an EPTinduced VM exit, the value saved for EFLAGS may incorrectly contain the arithmetic flag values that the EFLAGS register would have held had the instruction completed without fault or VM exit. For page faults, this can occur even if the fault causes a VM exit or if its delivery causes a nested fault.  	  None identified. Although the EFLAGS value saved by an affected event (a page fault or an EPT-induced VM exit) may contain incorrect arithmetic flag values, Intel has not identified software that is affected by this erratum. This erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or VM exit.  	 If the handler of the affected events inspects the arithmetic portion of the saved EFLAGS value, then system software should perform a synchronized paging structure modification and TLB invalidation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  	  Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to “Procedure Calls For Block-Structured Languages” in IA-32 Intel® Architecture Software Developer's Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software.  	 None identified. 	  22  For the steppings affected, see the Summary Tables of Changes.  
  Faulting MMX Instruction May Incorrectly Update x87 FPU Tag Word  	  Under a specific set of conditions, MMX stores (MOVD, MOVQ, MOVNTQ, MASKMOVQ) which cause memory access faults (#GP, #SS, #PF, or #AC), may incorrectly update the x87 FPU tag word register. This erratum will occur when the following additional conditions are also met: •The MMX store instruction must be the first MMX instruction to operate on x87 FPU state (i.e. the x87 FP tag word is not already set to 0x0000). •For MOVD, MOVQ, MOVNTQ stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to MASKMOVQ).  	  If the erratum conditions are met, the x87 FPU tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.  	 None identified 	  For the steppings affected, see the Summary Tables of Changes. 
  FREEZE_WHILE_SMM Does Not Prevent Event From Pending PEBS During SMM  	  In general, a PEBS record should be generated on the first count of the event after the counter has overflowed. However, IA32_DEBUGCTL_MSR.FREEZE_WHILE_SMM (MSR 1D9H, bit [14]) prevents performance counters from counting during SMM (System Management Mode). Due to this erratum, if: 1.  A performance counter overflowed before an SMI.  2. A PEBS record has not yet been generated because another count of the event has not occurred. 3. The monitored event occurs during SMM then a PEBS record will be saved after the next RSM instruction. When FREEZE_WHILE_SMM is set, a PEBS should not be generated until the event occurs outside of SMM. 	  A PEBS record may be saved after an RSM instruction due to the associated performance counter detecting the monitored event during SMM; even when FREEZE_WHILE_SMM is set.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g. Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	  Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   23 
  #GP on Segment Selector Descriptor that Straddles Canonical Boundary May Not Provide Correct Exception Error Code  	  During a #GP (General Protection Exception), the processor pushes an error code on to the exception handler's stack. If the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.  	  An incorrect error code may be pushed onto the stack. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM's location 7FA4H is set to “1” by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: •A non-I/O instruction •SMI is pending while a lower priority event interrupts •A REP I/O read •A I/O read that redirects to MWAIT  	  SMM handlers may get false IO_SMI indication.  	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	  In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame.  	 Software should not generate misaligned stack frames for use with IRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May Be Unreliable  	  Due to certain internal processor events, updates to the LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH), may happen when no update was expected.  	  The values of the LER MSRs may be unreliable.  	 None identified. 	  24  For the steppings affected, see the Summary Tables of Changes.  
  LBR, BTS, BTM May Report a Wrong Address when an Exception/ Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1's. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	  LBR, BTS and BTM may report incorrect information in the event of an exception/ interrupt.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCi_Status Overflow Bit May Be Incorrectly Set on a Single Instance of a DTLB Error  	  A single Data Translation Look Aside Buffer (DTLB) error can incorrectly set the Overflow (bit [62]) in the MCi_Status register. A DTLB error is indicated by MCA error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the MCi_Status register.  	  Due to this erratum, the Overflow bit in the MCi_Status register may not be an accurate indication of multiple occurrences of DTLB errors. There is no other impact to normal processor functionality.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MONITOR or CLFLUSH on the Local XAPIC's Address Space Results in Hang  	  If the target linear address range for a MONITOR or CLFLUSH is mapped to the local xAPIC's address space, the processor will hang.  	  When this erratum occurs, the processor will hang. The local xAPIC's address space must be uncached. The MONITOR instruction only functions correctly if the specified linear address range is of the type write-back. CLFLUSH flushes data from the cache. Intel has not observed this erratum with any commercially available software.  	 Do not execute MONITOR or CLFLUSH instructions on the local xAPIC address space. 	  For the steppings affected, see the Summary Tables of Changes.   25 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	  With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault.  	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS Record not Updated when in Probe Mode  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflows of the counter can result in storage of a PEBS record in the PEBS buffer. Due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new PEBS record may not be added to the PEBS buffer.  	  Due to this erratum, the PEBS buffer may not be updated by overflows that occur during probe mode.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	  The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  26  For the steppings affected, see the Summary Tables of Changes.  
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations  	  Under certain conditions as described in the Software Developers Manual section “Outof-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	  Upon crossing the page boundary the following may occur, dependent on the new page memory type: • UC the data size of each write will now always be 8 bytes, as opposed to the original data size. • WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. • WT there may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  Reported Memory Type May Not Be Used to Access the VMCS and Referenced Data Structures  	  Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor uses to access the VMCS and data structures referenced by pointers in the VMCS. Due to this erratum, a VMX access to the VMCS or referenced data structures will instead use the memory type that the MTRRs (memory-type range registers) specify for the physical address of the access.  	  Bits 53:50 of the IA32_VMX_BASIC MSR report that the WB (write-back) memory type will be used but the processor may use a different memory type.  	 Software should ensure that the VMCS and referenced data structures are located at physical addresses that are mapped to WB memory type by the MTRRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	  When this erratum occurs, #DB will be incorrectly handled as follows: •#DB is signaled before the pending higher priority #MF (Interrupt 16). •#DB is generated twice on the same instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   27 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	  When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	  Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to “NMI-Window Exiting” May Be Delayed by One Instruction  	  If VM entry is executed with the “NMI-window exiting” VM-execution control set to 1, a VM exit with exit reason “NMI window” should occur before execution of any instruction if there is no virtual-NMI blocking, no blocking of events by MOV SS, and no blocking of events by STI. If VM entry is made with no virtual-NMI blocking but with blocking of events by either MOV SS or STI, such a VM exit should occur after execution of one instruction in VMX non-root operation. Due to this erratum, the VM exit may be delayed by one additional instruction.  	  VMM software using “NMI-window exiting” for NMI virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual NMI, which is virtually asynchronous. The erratum may affect VMMs relying on deterministic delivery of the affected VM exits.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected  	  x87 instructions that trigger #MF normally service interrupts before the #MF. Due to this erratum, if an instruction that triggers #MF is executed while Enhanced Intel SpeedStep® Technology transitions, Intel® Turbo Boost Technology transitions, or Thermal Monitor events occur, the pending #MF may be signaled before pending interrupts are serviced.  	  Software may observe #MF being signaled before pending interrupts are serviced.  	 None identified. 	  28  For the steppings affected, see the Summary Tables of Changes.  
  Values for LBR/BTS/BTM Will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	  The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unsupported PCIe* Upstream Access May Complete with an Incorrect Byte Count  	  PCIe* Upstream IO and Configuration accesses are not supported. If an IO or Configuration request is received upstream, the integrated PCIe controller will treat it as an unsupported request, the request will be dropped, and a completion will be sent with the UR (Unsupported Request) completion status. This completion, according to the PCIe specification, should indicate a byte count of 4. Due to this erratum, the byte count is set to the same byte count as the offending request.  	  The processor response to an unsupported PCIe access may not fully comply to the PCIe specification.  	 PCIe agents should not issue unsupported accesses. 	  For the steppings affected, see the Summary Tables of Changes. 
  Malformed PCIe* Transactions May be Treated as Unsupported Requests Instead of as Critical Errors  	  PCIe MSG/MSG_D TLPs (Transaction Layer Packets) with incorrect Routing Code as well as the deprecated TCfgRD and TCfgWr types should be treated as malformed transactions leading to a critical error. Due to this erratum, the integrated PCIe controller's root ports may treat such messages as UR (Unsupported Requests).  	  Legacy malformed PCIe transactions may be treated as UR instead of as critical errors.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   29 
  PCIe* Root Port May Not Initiate Link Speed Change  	  PCIe specification rev 2.0 requires the upstream component to maintain the PCIe link at the target link speed or the highest speed supported by both components on the link, whichever is lower. PCIe root port will not initiate the link speed change without being triggered by the software. System BIOS will trigger the link speed change under normal boot scenarios. However, BIOS is not involved in some scenarios such as link disable/re-enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. This erratum does not affect the ability of the downstream component to initiate a link speed change. All known 5.0Gb/ s-capable PCIe downstream components have been observed to initiate the link speed change without relying on the root port to do so.  	  Due to this erratum, the PCIe root port may not initiate a link speed change during some hardware scenarios causing the PCIe link to operate at a lower than expected speed. Intel has not observed this erratum with any commercially available platform.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR or XSAVE/XRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the FXSAVE or XSAVE image or a partial memory state restore of the FXRSTOR or XRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	  FXSAVE/FXRSTOR or XSAVE/XRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.  	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.  	  Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected.  	 None identified. 	  30  For the steppings affected, see the Summary Tables of Changes.  
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	  Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80-bit FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software.  	 If the FP Data Operand Pointer is used in an operating system which may run 16-bit FP code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  Spurious Interrupts May be Generated From the Intel® VT-d Remap Engine  	  If software clears the F (Fault) bit 127 of the Fault Recording Register (FRCD_REG at offset 0x208 in Remap Engine BAR) by writing 1b through RW1C command (Read Write 1 to Clear) when the F bit is already clear then a spurious interrupt from Intel® VT-d (Intel® Virtualization Technology for Directed I/O) Remap Engine may be observed.  	  Due to this erratum, spurious interrupts will occur from the Intel VT-d Remap Engine following RW1C clearing F bit.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   31 
  Fault Not Reported When Setting Reserved Bits of Intel® VT-d Queued Invalidation Descriptors  	  Reserved bits in the Queued Invalidation descriptors of Intel VT-d (Virtualization Technology for Directed I/O) are expected to be zero, meaning that software must program them as zero while the processor checks if they are not zero. Upon detection of a non-zero bit in a reserved field, an Intel VT-d fault should be recorded. Due to this erratum, the processor does not check reserved bit values for Queued Invalidation descriptors.  	  Due to this erratum, faults will not be reported when writing to reserved bits of Intel VT-d Queued Invalidation Descriptors.  	 None identified 	  For the steppings affected, see the Summary Tables of Changes. 
  VPHMINPOSUW Instruction in Vex Format Does Not Signal #UD When vex.vvvv !=1111b  	  Processor does not signal #UD fault when executing the reserved instruction VPHMINPOSUW with vex.vvvv !=1111b.  	  Executing VPHMINPOSUW with vex.vvvv !=1111b results in the same behavior as executing with vex.vvvv=1111b.  	 Software should not use VPHMINPOSUW with vex.vvvv !=1111b, in order to ensure future compatibility. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTM or BTS Records May have Incorrect Branch From Information After an EIST/T-state/S-state/C1E Transition or Adaptive Thermal Throttling  	  The “From” address associated with the LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) may be incorrect for the first branch after a transition of: • EIST (Enhanced Intel® SpeedStep Technology). • T-state (Thermal Monitor states). • S1-state (ACPI package sleep state). • C1E (Enhanced C1 Low Power state). • Adaptive Thermal Throttling.  	  When the LBRs, BTM or BTS are enabled, some records may have incorrect branch “From” addresses for the first branch after a transition of EIST, T-states, S-states, C1E, or Adaptive Thermal Throttling.  	 None identified. 	  32  For the steppings affected, see the Summary Tables of Changes.  
  VMREAD/VMWRITE Instruction May Not Fail When Accessing an Unsupported Field in VMCS  	  The Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 2B states that execution of VMREAD or VMWRITE should fail if the value of the instruction's register source operand corresponds to an unsupported field in the VMCS (Virtual Machine Control Structure). The correct operation is that the logical processor will set the ZF (Zero Flag), write 0CH into the VM-instruction error field and for VMREAD leave the instruction's destination operand unmodified. Due to this erratum, the instruction may instead clear the ZF, leave the VM-instruction error field unmodified and for VMREAD modify the contents of its destination operand.  	  Accessing an unsupported field in VMCS will fail to properly report an error. In addition, VMREAD from an unsupported VMCS field may unexpectedly change its destination operand. Intel has not observed this erratum with any commercially available software.  	 Software should avoid accessing unsupported fields in a VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  Clock Modulation Duty Cycle Cannot be Programmed to 6.25%  	  When programming field T_STATE_REQ of the IA32_CLOCK_MODULATION MSR (19AH) bits [3:0] to '0001, the actual clock modulation duty cycle will be 12.5% instead of the expected 6.25% ratio.  	  Due to this erratum, it is not possible to program the clock modulation to a 6.25% duty cycle.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for VEX.vvvv May Produce a #NM Exception  	  The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (InvalidOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to this erratum, if CR0.TS is “1”, the processor may instead produce a #NM (Device-NotAvailable) exception.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should always set the vvvv field of the VEX prefix to 1111b for instances of the VAESIMC and VAESKEYGENASSIST instructions. 	  For the steppings affected, see the Summary Tables of Changes.   33 
  Memory Aliasing of Code Pages May Cause Unpredictable System Behavior  	  The type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. Specifically, if one code page is mapped by one logical processor as write-back and by another as uncachable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.  	  If this erratum occurs, the system may have unpredictable behavior, including a system hang. The aliasing of memory regions, a condition necessary for this erratum to occur, is documented as being unsupported in the Intel 64 and IA-32 Intel® Architecture Software Developer's Manual, Volume 3A, in the section titled Programming the PAT. Intel has not observed this erratum with any commercially available software or system.  	 Code pages should not be mapped with uncacheable and cacheable memory types at the same time. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express* Graphics Receiver Error Reported When Receiver With L0s Enabled and Link Retrain Performed  	  If the Processor PCI Express* root port is the receiver with L0s enabled and the root port itself initiates a transition to the recovery state via the retrain link configuration bit in the 'Link Control' register (Bus 0; Device 1; Functions 0, 1, 2 and Device 6; Function 0; Offset B0H; bit 5), then the root port may not mask the receiver or bad DLLP (Data Link Layer Packet) errors as expected. These correctable errors should only be considered valid during PCIe configuration and L0 but not L0s. This causes the processor to falsely report correctable errors in the 'Device Status' register (Bus 0; Device 1; Functions 0, 1, 2 and Device 6; Function 0; Offset AAH; bit 0) upon receiving the first FTS (Fast Training Sequence) when exiting Receiver L0s. Under normal conditions there is no reason for the Root Port to initiate a transition to Recovery. Note: This issue is only exposed when a recovery event is initiated by the processor.  	  The processor does not comply with the PCI Express 2.0 Specification. This does not impact functional compatibility or interoperability with other PCIe devices.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VZEROALL/VZEROUPPER  	  Execution of the VZEROALL or VZEROUPPER instructions in 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.  	 Compilers should encode VEX.W = 0 for executions of the VZEROALL and VZEROUPPER instructions in 64-bit mode to ensure future compatibility. 	  34  For the steppings affected, see the Summary Tables of Changes.  
  Perfmon Event LD_BLOCKS.STORE_FORWARD May Overcount  	  Perfmon LD_BLOCKS.STORE_FORWARD (event 3H, umask 01H) may overcount in the cases of 4KB address aliasing and in some cases of blocked 32-byte AVX load operations. 4KB address aliasing happens when unrelated load and store that have different physical addresses appear to overlap due to partial address check done on the lower 12 bits of the address. In some cases, such memory aliasing can cause load execution to be significantly delayed. Blocked AVX load operations refer to 32-byte AVX loads that are blocked due to address conflict with an older store.  	  The perfmon event LD_BLOCKS.STORE_FORWARD may overcount for these cases.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Conflict Between Processor Graphics Internal Message Cycles And Graphics Reads From Certain Physical Memory Ranges May Cause a System Hang  	  Processor Graphics internal message cycles occurring concurrently with a physical memory read by graphics from certain memory ranges may cause memory reads to be stalled resulting in a system hang. The following physical page (4K) addresses cannot be assigned to Processor Graphics: 00_2005_0xxx, 00_2013_0xxx, 00_2013_8xxx and 00_4000_4xxx.  	  Due to this erratum, accesses by the graphics engine to the defined memory ranges may cause memory reads to be stalled, resulting in a system hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of Opcode 9BH with the VEX Opcode Extension May Produce a #NM Exception  	  Attempt to use opcode 9BH with a VEX opcode extension should produce a #UD (Invalid-Opcode) exception. Due to this erratum, if CR0.MP and CR0.TS are both 1, the processor may produce a #NM (Device-Not-Available) exception if one of the following conditions exists: •66H, F2H, F3H or REX as a preceding prefix. •An illegal map specified in the VEX.mmmmm field.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should not use opcode 9BH with the VEX opcode extension. 	  For the steppings affected, see the Summary Tables of Changes.   35 
  Executing The GETSEC Instruction While Throttling May Result in a Processor Hang  	  If the processor throttles, due to either high temperature thermal conditions or due to an explicit operating system throttling request (TT1), while executing GETSEC[SENTER] or GETSEC[SEXIT] instructions, then under certain circumstances, the processor may hang. Intel has not been observed this erratum with any commercially available software.  	  Possible hang during execution of GETSEC instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to the IA32_FIXED_CTR1 MSR May Result in Incorrect Value in Certain Conditions  	  Under specific internal conditions, if software tries to write the IA32_FIXED_CTR1 MSR (30AH) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (i.e. its value was 0xFFFF FFFF FFFF), then due to this erratum the new value in the MSR may be corrupted.  	  Due to this erratum, IA32_FIXED_CTR1 MSR may be written with a corrupted value.  	 Software may avoid this erratum by writing zeros to the IA32_FIXED_CTR1 MSR, before the desired write operation. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause Machine Check if Page Size and Memory Type Was Changed Without Invalidation  	  This erratum may cause a machine-check error (IA32_MCi_STATUS.MCACOD=0150H) on the fetch of an instruction that crosses a 4-KByte address boundary. It applies only if (1) the 4-KByte linear region on which the instruction begins is originally translated using a 4-KByte page with the WB memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-MByte, 4-MByte, or 1GByte) with the UC memory type; and (3) the instruction fetch occurs after the pagingstructure modification but before software invalidates any TLB entries for the linear region.  	  Due to this erratum, an unexpected machine check with error code 0150H may occur, possibly resulting in a shutdown. Intel has not observed this erratum with any commercially available software.  	 Software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. It can instead use the following algorithm: first clear the P flag in the relevant paging-structure entry (e.g., PDE); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the P flag and establish the new page size and memory type. 	  36  For the steppings affected, see the Summary Tables of Changes.  
  Reception of Certain Malformed Transactions May Cause PCIe* Port to Hang Rather Than Reporting an Error  	  If the processor receives an upstream malformed non posted packet for which the type field is IO, Configuration or the deprecated TCfgRd and the format is 4 DW header, then due to this erratum the integrated PCIe controller may hang instead of reporting the malformed packet error or issuing an unsupported request completion transaction.  	  Due to this erratum, the processor may hang without reporting errors when receiving a malformed PCIe transaction. Intel has not observed this erratum with any commercially available device.  	 None identified. Upstream transaction initiators should avoid issuing unsupported requests with 4 DW header formats. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* LTR Incorrectly Reported as Being Supported  	  LTR (Latency Tolerance Reporting) is a new optional feature specified in PCIe rev. 2.1. The processor reports LTR as supported in LTRS bit in DCAP2 register (bus 0; Device 1; Function 0; offset 0xc4), but this feature is not supported.  	  Due to this erratum, LTR is always reported as supported by the LTRS bit in the DCAP2 register.  	 None the identified. 	  For steppings affected, see the Summary Tables of Changes. 
  Performance-Counter Overflow Indication May Cause Undesired Behavior  	  Under certain conditions (listed below) when a performance counter overflows, its overflow indication may remain set indefinitely. This erratum affects the generalpurpose performance counters IA32_PMC{0-7} and the fixed-function performance counters IA32_FIXED_CTR{0-2}. The erratum may occur if any of the following conditions are applied concurrent to when an actual counter overflow condition is reached: 1. Software disables the counter either globally through the IA32_PERF_GLOBAL_CTRL MSR (38FH), or locally through the IA32_PERFEVTSEL{0-7} MSRs (186H-18DH), or the IA32_FIXED_CTR_CTRL MSR (38DH). 2. Software sets the IA32_DEBUGCTL MSR (1D9H) FREEZE_PERFMON_ON_PMI bit [12]. 3. The processor attempts to disable the counters by updating the state of the IA32_PERF_GLOBAL_CTRL MSR (38FH) as part of transitions such as VM exit, VM entry, SMI, RSM, or processor C-state.  	  Due to this erratum, the corresponding overflow status bit in IA32_PERF_GLOBAL_STATUS MSR (38DH) for an affected counter may not get cleared when expected. If a corresponding counter is configured to issue a PMI (performance monitor interrupt), multiple PMIs may be signaled from the same overflow condition. Likewise, if a corresponding counter is configured in PEBS mode (applies to only the general purpose counters), multiple PEBS events may be signaled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   37 
  XSAVE Executed During Paging-Structure Modification May Cause Unexpected Processor Behavior  	  Execution of XSAVE may result in unexpected behavior if the XSAVE instruction writes to a page while another logical processor clears the dirty flag or the accessed flag in any paging-structure entry that maps that page.  	  This erratum may cause unpredictable system behavior. Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  C-state Exit Latencies May be Higher Than Expected  	  Core C-state exit can be delayed if a P-state transition is requested before the pending C-state exit request is completed. Under certain internal conditions the core C-state exit latencies may be over twice the value specified in the Intel® 64 and IA-32 Architectures Optimization Reference Manual.  	  While typical exit latencies are not impacted, the worst case core C-state exit latency may be over twice the value specified in the Intel® 64 and IA-32 Architectures Optimization Reference Manual and may lead to a delay in servicing interrupts. Intel has not observed any system failures due to this erratum.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® VT-d Interrupt Remapping Will Not Report a Fault if Interrupt Index Exceeds FFFFH  	  With Intel VT-d (Virtualization Technology for Directed I/O) interrupt remapping, if subhandle valid (bit 3) is set in the address of an interrupt request, the interrupt index is computed as the sum of the interrupt request’s handle and subhandle. If the sum is greater than FFFFH (the maximum possible interrupt-remapping table size), a remapping fault with fault reason 21H should be reported. Due to this erratum, this condition is not reported as a fault. Instead, the low 16 bits of the sum are erroneously used as an interrupt index to access the interrupt-remapping table.  	  If the interrupt index of an interrupt request exceeds FFFFH, a remapping fault with fault reason 21H is not reported and, instead, the request uses the IRTE (interruptremapping table entry) indexed by the low 16 bits of the interrupt index.  	 Software can use requestor-id verification to block the interrupts that would be delivered due to this erratum. Interrupts blocked in this way produce a remapping fault with fault reason 26H. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Link Speed May Not Change From 5.0 GT/s to 2.5 GT/s  	  If a PCI Express device changes its supported PCIe link speed from 5.0 GT/s to 2.5 GT/ s without initiating a speed change request and subsequently the L1 power management mode is entered, further retrains initiated by software will not change speed to 2.5 GT/s.  	  Intel has not observed any PCI Express device that changes supported link speed without actually initiating a speed change.  	 None identified. 	  38  For the steppings affected, see the Summary Tables of Changes.  
  L1 Data Cache Errors May be Logged With Level Set to 1 Instead of 0  	  When an L1 Data Cache error is logged in IA32_MCi_STATUS[15:0], which is the MCA Error Code Field, with a cache error type of the format 0000 0001 RRRR TTLL, the LL field may be incorrectly encoded as 01 instead of 00.  	  An error in the L1 Data Cache may report the same LL value as the L2 Cache. Software should not assume that an LL value of 01 is the L2 Cache.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Unexpected Page Fault or EPT Violation May Occur After Another Logical Processor Creates a Valid Translation for a Page  	  An unexpected page fault (#PF) or EPT violation may occur for a page under the following conditions: •The paging structures initially specify no valid translation for the page. •Software on one logical processor modifies the paging structures so that there is a valid translation for the page (e.g., by setting to 1 the present bit in one of the pagingstructure entries used to translate the page). •Software on another logical processor observes this modification (e.g., by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). •Shortly thereafter, software on that other logical processor performs a store to a linear address on the page. In this case, the store may cause a page fault or EPT violation that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). Intel has not observed this erratum with any commercially available software.  	  An unexpected page fault may be reported. There are no other side effects due to this erratum.  	 System software can be constructed to tolerate these unexpected page faults. See Section “Propagation of Paging-Structure Changes to Multiple Processors” of Volume 3A of IA-32 Intel® Architecture Software Developer’s Manual, for recommendations for software treatment of asynchronous paging-structure updates. 	  For the steppings affected, see the Summary Tables of Changes.   39 
  TSC Deadline Not Armed While in APIC Legacy Mode  	  Under specific timing conditions, when in Legacy APIC Mode, writing to IA32_TSC_DEADLINE MSR (6E0H) may fail to arm the TSC Deadline (Time Stamp Counter Deadline) event as expected. Exposure to this erratum is dependent on the proximity of TSC_Deadline MSR Write to a Timer CCR register read or to a write to the Timer LVT that enabled the TSC Deadline mode (writing 10 to bits [18:17] of Timer LVT).  	  Due to this erratum the expected timer event will either not be generated or will be generated at a wrong time. The TSC Deadline may fail until an LVT write to transition from “TSC Deadline mode” back to “Timer mode” occurs or until the next reset.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Upstream TCfgWr May Cause Unpredictable System Behavior  	  TCfgWr (Trusted Configuration Writes) is a PCIe Base spec deprecated transaction type which should be treated as a malformed packet. If a PCIe upstream TCfgWr request is received, then due to this erratum the request may not be managed as a Malformed Packet.  	  Upstream memory writes subsequent to a TCfgWr transaction may cause unpredictable system behavior. Intel has not observed any PCIe Device that sends such a TCfgWr request.  	 PCIe end points should not initiate upstream TCfgWr requests. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Fail to Acknowledge a TLP Request  	  When a PCIe root port’s receiver is in Receiver L0s power state and the port initiates a Recovery event, it will issue Training Sets to the link partner. The link partner will respond by initiating an L0s exit sequence. Prior to transmitting its own Training Sets, the link partner may transmit a TLP (Transaction Layer Packet). Due to this erratum, the root port may not acknowledge the TLP request.  	  After completing the Recovery event, the PCIe link partner will replay the TLP request. The link partner may set a Correctable Error status bit, which has no functional effect.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Executing The GETSEC Instruction While Throttling May Result in a Processor Hang  	  If the processor throttles, due to either high temperature thermal conditions or due to an explicit operating system throttling request (TT1), while executing GETSEC[SENTER] or GETSEC[SEXIT] instructions, then under certain circumstances, the processor may hang.  	  Possible hang during execution of GETSEC instruction. Intel has not been observed this erratum with any commercially available software.  	 None Identified. 	  40  For the steppings affected, see the Summary Tables of Changes.  
  PerfMon Event LOAD_HIT_PRE.SW_PREFETCH May Overcount  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH (event 4CH, umask 01H) should count load instructions hitting an ongoing software cache fill request initiated by a preceding software prefetch instruction. Due to this erratum, this event may also count when there is a preceding ongoing cache fill request initiated by a locking instruction.  	  PerfMon event LOAD_HIT_PRE.SW_PREFETCH may overcount.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of FXSAVE or FXRSTOR With the VEX Prefix May Produce a #NM Exception  	  Attempt to use FXSAVE or FXRSTOR with a VEX prefix should produce a #UD (InvalidOpcode) exception. If either the TS or EM flag bits in CR0 are set, a #NM (device-notavailable) exception will be raised instead of #UD exception.  	  Due to this erratum a #NM exception may be signaled instead of a #UD exception on an FXSAVE or an FXRSTOR with a VEX prefix.  	 Software should not use FXSAVE or FXRSTOR with the VEX prefix. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VPEXTRD/VPINSRD  	  Execution of the VPEXTRD or VPINSRD instructions outside of 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions outside 64-bit mode.  	 Software should encode VEX.W = 0 for executions of the VPEXTRD and VPINSRD instructions outside 64-bit mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  Erratum Removed 	NA	NA	NA	NA
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	  Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used.  	 Software can avoid this by: •Avoid using Freeze PerfMon on PMI bit. •Enable only one fixed counter at a time when using Freeze PerfMon on PMI. 	  For the steppings affected, see the Summary Tables of Changes.   41 
  #GP May be Signaled When Invalid VEX Prefix Precedes Conditional Branch Instructions  	  When a 2-byte opcode of a conditional branch (opcodes 0F8xH, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid VEX prefix, it may sometimes signal a #GP fault (illegal instruction length > 15-bytes) instead of a #UD (illegal opcode) fault.  	  Due to this erratum, #GP fault instead of a #UD may be signaled on an illegal instruction.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Read from The APIC-Timer CCR May Disarm The TSC_Deadline Counter  	  When in TSC Deadline mode with TSC_Deadline timer armed (IA32_TSC_DEADLINE<>0, MSR 6E0H), a read from the local APIC’s CCR (current count register) using RDMSR 0839H may disarm the TSC Deadline timer without generating an interrupt as specified in the APIC Timer LVT (Local Vector Table) entry.  	  Due to this erratum, unexpected disarming of the TSC_Deadline counter and possible loss of an interrupt may occur.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Unexpected PMI May Occur After Writing a Large Value to IA32_FIXED_CTR2  	  If the fixed-function performance counter IA32_FIXED_CTR2 MSR (30BH) is configured to generate a performance-monitor interrupt (PMI) on overflow and the counter’s value is greater than FFFFFFFFFFC0H, then this erratum may incorrectly cause a PMI if software performs a write to this counter.  	  A PMI may be generated unexpectedly when programming IA32_FIXED_CTR2. Other than the PMI, the counter programming is not affected by this erratum as the attempted write operation does succeed.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  RDMSR From The APIC-Timer CCR May Disarm The APIC Timer in TSC Deadline Mode  	  When in TSC Deadline mode with TSC_Deadline timer armed (IA32_TSC_DEADLINE<>0, MSR 6E0H), a read from the local APIC’s CCR (current count register) in APIC MMIO space may disarm the TSC Deadline timer without generating an interrupt as specified in the APIC Timer LVT (Local Vector Table) entry.  	  Due to this erratum, unexpected disarming of the APIC timer and possible loss of an interrupt may occur.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  42  For the steppings affected, see the Summary Tables of Changes  
  RC6 Entry Can be Blocked by Asynchronous Intel® VT-d Flows  	  The graphics Command Streamer can get into a state that will effectively inhibit graphic RC6 (Render C6) power management state entry until render reset occurs. Any asynchronous Intel VT-d (Virtualization Technology for Directed I/O) access to IOTLB can potentially cause graphics Command Streamer to get into this RC6 inhibited state.  	  Average power will increase until RC6 is activated with a render reset.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Repeated PCIe* and/or DMI L1 Transitions During Package Power States May Cause a System Hang  	  Under a complex set of internal conditions when the processor is in a deep power state (package C3, C6 or C7) and the PCIe and/or DMI links are toggling in and out of L1 state, internal states of the processor may become inaccessible resulting in a system hang.  	  Due to this erratum, the system may hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of BIST During Cold RESET May Result in a Machine Check Shutdown  	  If BIST (Built In Self-Test) is enabled and a Cold RESET follows, an unrecoverable machine check shutdown will occur.  	  Due to this erratum, BIST cannot be enabled.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCI Express* Differential Peak-Peak Tx Voltage Swing May Violate the Specification  	  Under certain conditions, including extreme voltage and temperature, the peak-peak voltage may be higher than the specification.  	  Violation of PCI Express Base Specification of the VTX--DIFF-PP voltage. No failures have been observed due to this erratum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCIe* Presence Detect State May Not be Accurate After a Warm Reset  	  Under certain conditions, when there is no PCIe device present, the status of Presence Detect State bit (SLOTSTS Device 1; Function 0,1,2; Offset BAH; bit [6] and/or Device 6; Function 0; Offset BAH; bit [6]) may not be accurate after a warm reset.  	  The Presence Detect State bit may incorrectly report a PCIe device is present even though no device is actually present, which may result in a system hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   43 
  Display Corruption May be Seen After Graphics Voltage Rail (VCC_AXG) Power Up  	  Powering up the processor graphics logic in the cases of initial poweron, Sx resume state power up, or powering up from RC6+ ( RC6 at 0V ) may cause a nondeterministic state in the processor graphics logic.  	  This erratum may cause improper 3D rendering and may result in display corruption.  	 A graphics driver workaround has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PCMPESTRI, PCMPESTRM, VPCMPESTRI and VPCMPESTRM Always Operate with 32-bit Length Registers  	  In 64-bit mode, using REX.W=1 with PCMPESTRI and PCMPESTRM or VEX.W=1 with VPCMPESTRI and VPCMPESTRM should support a 64-bit length operation with RAX/ RDX. Due to this erratum, the length registers are incorrectly interpreted as 32-bit values.  	  Due to this erratum, using REX.W=1 with PCMPESTRI and PCMPESTRM as well as VEX.W=1 with VPCMPESTRI and VPCMPESTRM do not result in promotion to 64-bit length registers.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Entries That Return From SMM Using VMLAUNCH May Not Update The Launch State of the VMCS  	  Successful VM entries using the VMLAUNCH instruction should set the launch state of the VMCS to “launched”. Due to this erratum, such a VM entry may not update the launch state of the current VMCS if the VM entry is returning from SMM.  	  Subsequent VM entries using the VMRESUME instruction with this VMCS will fail. RFLAGS.ZF is set to 1 and the value 5 (indicating VMRESUME with non-launched VMCS) is stored in the VM-instruction error field. This erratum applies only if dual monitor treatment of SMI and SMM is active.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  44  For the steppings affected, see the Summary Tables of Changes.  
  Interrupt From Local APIC Timer May Not Be Detectable While Being Delivered  	  If the local-APIC timer’s CCR (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the LVT timer register and then reading the bit in the IRR (interrupt-request register) corresponding to the vector in the LVT timer register. If both values are read as 0, no timer interrupt should be in the process of being delivered. Due to this erratum, a timer interrupt may be delivered even if the CCR is 0 and the LVT and IRR bits are read as 0. This can occur only if the DCR (Divide Configuration Register) is greater than or equal to 4. The erratum does not occur if software writes zero to the Initial Count Register before reading the LVT and IRR bits.  	  Software that relies on reads of the LVT and IRR bits to determine whether a timer interrupt is being delivered may not operate properly.  	 Software that uses the local-APIC timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading CCR and the LVT and IRR bits; alternatively, software can avoid the problem by writing zero to the Initial Count Register before reading the LVT and IRR bits. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Unexpected Page Fault May Occur Following the Unmapping and Re-mapping of a Page  	  An unexpected page fault (#PF) may occur for a page under the following conditions: •The paging structures initially specify a valid translation for the page. •Software modifies the paging structures so that there is no valid translation for the page (e.g., by clearing to 0 the present bit in one of the paging-structure entries used to translate the page). •Software later modifies the paging structures so that the translation is again a valid translation for the page (e.g., by setting to 1 the bit that was cleared earlier). •A subsequent instruction loads from a linear address on the page. •Software did not invalidate TLB entries for the page between the first modification of the paging structures and the load from the linear address. In this case, the load by the later instruction may cause a page fault that indicates that there is no translation for the page (e.g., with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page).  	  Software may see an unexpected page fault that indicates that there is no translation for the page. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   45 
  A PCIe* Device That Initially Transmits Minimal Posted Data Credits May Cause a System Hang  	  Under certain conditions, if a PCIe device that initially transmits posted data credits less than Max_Payload_Size/16 + 4 (16B/4DW is unit of data flow control) and is the target of a Peer-to-Peer write of Max_Payload_Size, the system may hang due to Posted Data credit starvation.  	  Under certain conditions, the processor may encounter a Posted Data credit starvation scenario and hang.  	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Some Model Specific Branch Events May Overcount  	  Under certain internal conditions the following model specific performance monitoring branch events may overcount: •BR_INST_RETIRED.NOT_TAKEN •BR_INST_RETIRED.NEAR_TAKEN •BR_MISP_RETIRED.NOT_TAKEN •BR_MISP_RETIRED.TAKEN  	  Due to this erratum the events may overcount.  	 None identified. 	  46  For the steppings affected, see the Summary Tables of Changes.  
  Some Performance Monitoring Events in AnyThread Mode May Get Incorrect Count  	  Performance monitoring AnyThread mode allows a given thread to monitor events as a result of any thread running on the same core. Due to this erratum, on systems with SMT enabled, counting any of the following performance monitoring events in AnyThread mode may get incorrect values: •INST_RETIRED; •OTHER_ASSISTS; •UOPS_RETIRED; •MACHINE_CLEARS; •BR_INST_RETIRED; •BR_MISP_RETIRED; •SIMD_INST_RETIRED; •FP_ASSIST; •HW_INTERRUPTS; •ROB_MISC_EVENTS; •MEM_LOAD_RETIRED; •MEM_LOAD_LLC_HIT_RETIRED; •MEM_LOAD_LLC_MISS_RETIRED; •MEM_LOAD_MISC_RETIRED;  	  Incorrect results when counting the above performance monitoring events in AnyThread mode with SMT on.  	 In order to get a correct count for the above events, software may count the same event on both threads of the same physical core, and at post-processing stage sum-up the two values to get the core’s net value. 	  For the steppings affected, see the Summary Tables of Changes. 
  PDIR May Not Function Properly With FREEZE_PERFMON_ON_PMI  	  When the PDIR (Precise Distribution for Instructions Retired) mechanism is activated (INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1 programmed in PEBS mode) along with FREEZE_PERFMON_ON_PMI, bit 11, in the IA32_DEBUGCTL MSR (1D9h), the processor may behave in an undefined manner.  	  Due to this erratum when FREEZE_PERFMON_ON_PMI is programmed along with PDIR the processor behavior is undefined. This can result in any of but not limited to the following: incorrect PMI interrupts, incorrect PEBS events or invalid processor state.  	 A software driver should not program FreezeOnPMI in conjunction with the PDIR mechanism. 	  For the steppings affected, see the Summary Tables of Changes.   47 
  For A Single Logical Processor Package, HTT May be Set to Zero Even Though The Package Reserves More Than One APIC ID  	  When maximum number of addressable IDs for logical processors in this physical package (CPUID.01H.EBX[23:16]) and maximum number of addressable IDs for processor cores in the physical package, (CPUID.04H.EAX[31:26]) indicate more than one reserved APIC ID, HTT(Multi-Threading, CPUID.01H.EDX[28]) should be set to One. However, due to this erratum, it may be set to Zero.  	  Software written expecting HTT to be Zero only when a single APIC ID is reserved for the package may not function correctly.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR May Contain Incorrect Information When Using FREEZE_LBRS_ON_PMI  	  When FREEZE_LBRS_ON_PMI is enabled (bit 11 of IA32_DEBUGCTL MSR (1D9H) is set), and a taken branch retires at the same time that a PMI (Performance Monitor Interrupt) occurs, then under certain internal conditions the record at the top of the LBR stack may contain an incorrect “From” address.  	  When the LBRs are enabled with FREEZE_LRBS_ON_PMI, the “From” address at the top of the LBR stack may be incorrect.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A First Level Data Cache Parity Error May Result in Unexpected Behavior  	  When a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior.  	  Due to this erratum, unpredictable system behavior may occur. Intel has not observed this erratum with any commercially available system.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Intel® Trusted Execution Technology ACM Revocation  	  SINIT ACM 2nd_gen_i5_i7_SINIT_1.9.BIN or earlier are revoked and will not launch with new processor configuration information.  	  Due to this erratum, 2nd_gen_i5_i7_SINIT_1.9.BIN and earlier will be revoked.  	 It is possible for the BIOS to contain a workaround for this erratum. All Intel® TXT enabled software must use SINIT ACM 2nd_gen_i5_i7_SINIT_1.9.BIN or later. 	  48  For the steppings affected, see the Summary Tables of Changes.  
  Programming PDIR And an Additional Precise PerfMon Event May Cause Unexpected PMI or PEBS Events  	  PDIR (Precise Distribution for Instructions Retired) mechanism is activated by programming INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1. When PDIR is activated in PEBS (Precise Event Based Sampling) mode with an additional precise PerfMon event, an incorrect PMI or PEBS event may occur.  	  Due to this erratum, when another PEBS event is programmed along with PDIR, an incorrect PMI or PEBS event may occur.  	 Software should not program another PEBS event in conjunction with the PDIR mechanism. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring May Overcount Some Events During Debugging  	  If the debug-control register (DR7) is configured so that some but not all of the breakpoints in the debug-address registers (DR0-DR3) are enabled and one or more of the following performance-monitoring counters are locally enabled (via IA32_CR_PERMON_EVNTSEL_CNTR{3:0}): BR_INST_RETIRED BR_MISP_RETIRED FP_ASSIST FP_ASSIST INST_RETIRED MACHINE_CLEARS MEM_LOAD_UOPS_LLC_HIT_RETIRED MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS MEM_LOAD_UOPS_RETIRED MEM_TRANS_RETIRED MEM_UOPS_RETIRED OTHER_ASSISTS ROB_MISC_EVENTS.LBR_INSERTS UOPS_RETIRED Any of the globally enabled (via IA32_CR_EMON_PERF_GLOBAL_CTRL) counters may overcount certain events when a disabled breakpoint condition is met  	  Performance-monitor counters may indicate a number greater than the number of events that occurred.  	 Software can disable all breakpoints by clearing DR7. Alternatively, software can ensure that, for a breakpoint disabled in DR7, the corresponding debug-address register contains an address that prevents the breakpoint condition from being met (e.g., a non-canonical address). 	  For the steppings affected, see the Summary Tables of Changes. 
  LTR Message is Not Treated as an Unsupported Request  	  The PCIe* root port does not support LTR (Latency Tolerance Reporting) capability. However, a received LTR message is not treated as a UR (Unsupported Request).  	  Due to this erratum, an LTR message does not generate a UR error.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   49 
  Use of VMASKMOV to Access Memory Mapped I/O or Uncached Memory May Cause The Logical Processor to Hang  	  Under a complex set of conditions, using VMASKMOV to reference memory mapped I/O or uncached memory may cause the logical processor to hang.  	  Due to this erratum, the logical processor may hang. Intel's Software Developers Manual states "VMASKMOV should not be used to access memory mapped I/O and uncached memory as the access and the ordering of the individual loads or stores it does is implementation specific." Intel has not observed this erratum with any commercially available software.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS May Unexpectedly Signal a PMI After The PEBS Buffer is Full  	  The Software Developer’s Manual states that no PMI should be generated when PEBS index reaches PEBS Absolute Maximum. Due to this erratum a PMI may be generated even though the PEBS buffer is full.  	  PEBS may trigger a PMI even though the PEBS index has reached the PEBS Absolute Maximum.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  XSAVEOPT May Fail to Save Some State after Transitions Into or Out of STM  	  The XSAVEOPT instruction may optimize performance by not saving state that has not been modified since the last execution of XRSTOR. This optimization should occur only if the executions of XSAVEOPT and XRSTOR are either both or neither in SMM (systemmanagement mode). Due to this erratum, this optimization may be performed by the first execution of XSAVEOPT after a transition into or out of the STM (SMM-transfer monitor) if the most recent execution of XRSTOR occurred before that transition. For transitions into the STM, the erratum applies only to transitions using the VMCALL instruction. This erratum can occur only if the two executions are at the same privilege level, use the same linear address, and are either both or neither in VMX non-root operation. The erratum does not apply if software in SMM never uses XRSTOR or XSAVEOPT.  	  This erratum may lead to unpredictable system behavior.  	 STM software should execute the XRSTOR instruction with the value 0 in EDX:EAX after each transition into the STM (after setting CR4.OSXSAVE) and before each transition out of the STM. Bytes 512 to 575 of the save area used by XRSTOR should be allocated in memory, but bytes 0 to 511 need not be. Bytes 512 to 535 should all be 0. 	  50  For the steppings affected, see the Summary Tables of Changes.  
  Performance Monitor Precise Instruction Retired Event May Present Wrong Indications  	  When the PDIR (Precise Distribution for Instructions Retired) mechanism is activated (INST_RETIRED.ALL (event C0H, umask value 00H) on Counter 1 programmed in PEBS mode), the processor may return wrong PEBS/PMI interrupts and/or incorrect counter values if the counter is reset with a SAV below 100 (Sample-After-Value is the counter reset value software programs in MSR IA32_PMC1[47:0] in order to control interrupt frequency).  	  Due to this erratum, when using low SAV values, the program may get incorrect PEBS or PMI interrupts and/or an invalid counter state.  	 The sampling driver should avoid using SAV<100. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Value in IA32_MC3_ADDR MSR May Not be Accurate When MCACOD 0119H is Reported in IA32_MC3_Status  	  Under certain conditions, when the The Machine Check Error Code (MCACOD) in the IA32_MC3_STATUS (MSR 040DH) register is 0119H, the value in IA32_MC3_ADDR MSR (40EH) may refer to the incoming MLC (Mid-Level Cache) cache line instead of the evicted cache line.  	  The address in IA32_MC3_ADDR MSR (40EH) may not be accurate for MLC cache read errors with MSCOD of 119H.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  MSR_PKG_Cx_RESIDENCY MSRs May Not be Accurate  	  If the processor is in a package C-state for an extended period of time (greater than 40 seconds) with no wake events, the value in the MSR_PKG_C{2,3,6,7}_RESIDENCY MSRs (60DH and 3F8H–3FAH) will not be accurate.  	  Utilities that report C-state residency times will report incorrect data in cases of long duration package C-states.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Enabling/Disabling PEBS May Result in Unpredictable System Behavior  	  Under certain conditions, enabling or disabling PEBS (Precise Event Based Sampling) via WRMSR to IA32_PEBS_ENABLE MSR may result in unpredictable system behavior near or coincident to this instruction.  	  Due to this erratum, unpredictable system behavior may result.  	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes.   51 
  Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for VEX.vvvv May Produce a #NM Exception  	  The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (InvalidOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to this erratum, if CR0.TS is “1”, the processor may instead produce a #NM (Device-NotAvailable) exception.  	  Due to this erratum, some undefined instruction encodings may produce a #NM instead of a #UD exception.  	 Software should always set the vvvv field of the VEX prefix to 1111b for instances of the VAESIMC and VAESKEYGENASSIST instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unexpected #UD on VZEROALL/VZEROUPPER  	  Execution of the VZEROALL or VZEROUPPER instructions in 64-bit mode with VEX.W set to 1 may erroneously cause a #UD (invalid-opcode exception).  	  The affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.  	 Compilers should encode VEX.W = 0 for the VZEROALL and VZEROUPPER instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  Successive Fixed Counter Overflows May be Discarded  	  Under specific internal conditions, when using Freeze PerfMon on PMI feature (bit 12 in IA32_DEBUGCTL.Freeze_PerfMon_on_PMI, MSR 1D9H), if two or more PerfMon Fixed Counters overflow very closely to each other, the overflow may be mishandled for some of them. This means that the counter’s overflow status bit (in MSR_PERF_GLOBAL_STATUS, MSR 38EH) may not be updated properly; additionally, PMI interrupt may be missed if software programs a counter in Sampling-Mode (PMI bit is set on counter configuration).  	  Successive Fixed Counter overflows may be discarded when Freeze PerfMon on PMI is used.  	 Software can avoid this by: •Avoid using Freeze PerfMon on PMI bit •Enable only one fixed counter at a time when using Freeze PerfMon on PMI 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of FXSAVE or FXRSTOR With the VEX Prefix May Produce a #NM Exception  	  Attempt to use FXSAVE or FXRSTOR with a VEX prefix should produce a #UD (InvalidOpcode) exception. If either the TS or EM flag bits in CR0 are set, a #NM (device-notavailable) exception will be raised instead of #UD exception.  	  Due to this erratum a #NM exception may be signaled instead of a #UD exception on an FXSAVE or an FXRSTOR with a VEX prefix.  	 Software should not use FXSAVE or FXRSTOR with the VEX prefix. 	  52  For the steppings affected, see the Summary Tables of Changes.  
  VM Exits Due to “NMI-Window Exiting” May Not Occur Following a VM Entry to the Shutdown State  	  If VM entry is made with the “virtual NMIs” and “NMI-window exiting”, VM-execution controls set to 1, and if there is no virtual-NMI blocking after VM entry, a VM exit with exit reason “NMI window” should occur immediately after VM entry unless the VM entry put the logical processor in the wait-for SIPI state. Due to this erratum, such VM exits do not occur if the VM entry put the processor in the shutdown state.  	  A VMM may fail to deliver a virtual NMI to a virtual machine in the shutdown state.  	 Before performing a VM entry to the shutdown state, software should check whether the “virtual NMIs” and “NMI-window exiting” VM-execution controls are both 1. If they are, software should clear “NMI-window exiting” and inject an NMI as part of VM entry. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of INVVPID Outside 64-Bit Mode Cannot Invalidate Translations For 64-Bit Linear Addresses  	  Executions of the INVVPID instruction outside 64-bit mode with the INVVPID type “individual-address invalidation” ignore bits 63:32 of the linear address in the INVVPID descriptor and invalidate translations for bits 31:0 of the linear address.  	  The INVVPID instruction may fail to invalidate translations for linear addresses that set bits in the range 63:32. Because this erratum applies only to executions outside 64-bit mode, it applies only to attempts by a 32-bit virtual-machine monitor (VMM) to invalidate translations for a 64-bit guest. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VEX.L is Not Ignored with VCVT*2SI Instructions  	  The VEX.L bit should be ignored for the VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions, however due to this erratum the VEX.L bit is not ignored and will cause a #UD.  	  Unexpected #UDs will be seen when the VEX.L bit is set to 1 with VCVTSS2SI, VCVTSD2SI, VCVTTSS2SI, and VCVTTSD2SI instructions.  	 Software should ensure that the VEX.L bit is set to 0 for all scalar instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  MCI_ADDR May be Incorrect For Cache Parity Errors  	  In cases when a WBINVD instruction evicts a line containing an address or data parity error (MCACOD of 0x124, and MSCOD of 0x10), the address of this error should be logged in the MCi_ADDR register. Due to this erratum, the logged address may be incorrect, even though MCi_Status.ADDRV (bit 63) is set.  	  The address reported in MCi_ADDR may not be correct for cases of a parity error found during WBINVD execution.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes.   53 
  Instruction Fetches Page-Table Walks May be Made Speculatively to Uncacheable Memory  	  Page-table walks on behalf of instruction fetches may be made speculatively to uncacheable (UC) memory.  	  If any paging structures are located at addresses in uncacheable memory that are used for memory-mapped I/O, such I/O operations may be invoked as a result of speculative execution that would never actually occur in the executed code path. Intel has not observed this erratum with any commercially available software.  	 Software should avoid locating paging structures at addresses in uncacheable memory that are used for memory-mapped I/O 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Not Properly Execute Code Modified Using A Floating-Point Store  	  Under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.  	  Self- or cross-modifying code may not execute as expected. Intel has not observed this erratum with any commercially available software.  	 None identified. Do not use floating-point stores to modify code. 	  For the steppings affected, see the Summary Tables of Changes. 
  Execution of GETSEC[SEXIT] May Cause a Debug Exception to be Lost  	  A debug exception occurring at the same time that GETSEC[SEXIT] is executed or when an SEXIT doorbell event is serviced may be lost.  	  Due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of GETSEC[SEXIT]. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Exits Due to GETSEC May Save an Incorrect Value for “Blocking by STI” in the Context of Probe-Mode Redirection  	  The GETSEC instruction causes a VM exit when executed in VMX non-root operation. Such a VM exit should set bit 0 in the Interruptability-state field in the virtual-machine control structure (VMCS) if the STI instruction was blocking interrupts at the time GETSEC commenced execution. Due to this erratum, a VM exit executed in VMX non-root operation may erroneously clear bit 0 if redirection to probe mode occurs on the GETSEC instruction.  	  After returning from probe mode, a virtual interrupt may be incorrectly delivered prior to GETSEC instruction. Intel has not observed this erratum with any commercially software.  	 None identified. 	  54  For the steppings affected, see the Summary Tables of Changes.  
  Specific Graphics Blitter Instructions May Result in Unpredictable Graphics Controller Behavior  	  Specific source-copy blitter instructions in Intel® HD Graphics 2000 and 3000 Processor may result in unpredictable behavior when a blit source and destination overlap.  	  Due to this erratum, the processor may exhibit unpredictable graphics controller behavior. Intel has not observed this erratum with any commercially available software.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC5_CTL2 is Not Cleared by a Warm Reset  	  IA32_MC5_CTL2 MSR (285H) is documented to be cleared on any reset. Due to this erratum this MSR is only cleared upon a cold reset.  	  The algorithm documented in Software Developer’s Manual, Volume 3, section titled “CMCI Initialization” or any other algorithm that counts the IA32_MC5_CTL2 MSR being cleared on reset will not function as expected after a warm reset  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor Counters May Produce Incorrect Results  	  When operating in hyper-threaded mode, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled counter on the physical core’s other thread rather than the thread experiencing the event. The list of affected memory at-retirement events is as follows: •MEM_UOP_RETIRED.LOADS •MEM_UOP_RETIRED.STORES •MEM_UOP_RETIRED.LOCK •MEM_UOP_RETIRED.SPLIT •MEM_UOP_RETIRED.STLB_MISS •MEM_LOAD_UOPS_RETIRED.HIT_LFB •MEM_LOAD_UOPS_RETIRED.L1_HIT •MEM_LOAD_UOPS_RETIRED.L2_HIT •MEM_LOAD_UOPS_RETIRED.LLC_HIT •MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HIT •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_HITM •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_MISS •MEM_LOAD_UOPS_LLC_HIT_RETIRED.XSNP_NONE •MEM_LOAD_UOPS_RETIRED.LLC_MISS •MEM_LOAD_UOPS_LLC_MISS_RETIRED.LOCAL_DRAM •MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_DRAM •MEM_LOAD_UOPS_RETIRED.L2_MISS   55  	  Due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not Updated After a UC Error is Logged  	  When a UC (uncorrected) error is logged in the IA32_MC0_STATUS MSR (401H), corrected errors will continue to update the lower 14 bits (bits 51:38) of the Corrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of the Corrected Error Count will not get updated after a UC error is logged.  	  The Corrected Error Count Overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Spurious Intel® VT-d Interrupts May Occur When the PFO Bit is Set  	  When the PFO (Primary Fault Overflow) field (bit [0] in the VT-d FSTS [Fault Status] register) is set to 1, further faults should not generate an interrupt. Due to this erratum, further interrupts may still occur.  	  Unexpected Invalidation Queue Error interrupts may occur. Intel has not observed this erratum with any commercially available software.  	 Software should be written to handle spurious Intel® VT-d fault interrupts. 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Livelock During On Demand Clock Modulation  	  The processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the IA32_CLOCK_MODULATION MSR (19AH) and the clock modulation duty cycle is set to 12.5% (02H in bits 3:0 of the same MSR), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access UC memory.  	  Program execution may stall on both threads of the core subject to this erratum.  	 This erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the IA32_CLOCK_MODULATION MSR is 18.75% or higher. 	NA
  Different INTx Deassertions in Close Succession May Cause SMBus Controller Misbehavior  	  Spurious interrupt deassertion glitches may happen in the SMBus controller if different INTx deassertions are closely spaced.  	 This erratum causes improper functioning of the SMBus controller. 	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Spurious SMI May Occur During Warm Reset  	  Due to this erratum, during a warm reset a spurious SMI may be generated.  	 A spurious SMI during warm reset may cause the system to hang. 	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  SMBus Controller May Send Spurious Legacy PCI Error Interrupts  	  When operating in Legacy interrupt mode, the SMBus controller may not be able to suppress its legacy PCI error interrupt when the legacy PCI error interrupt is disabled.  	 Due to this erratum, the system may experience numerous unexpected interrupts. 	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.  Intel® Atom™ Processor S1200 Product Family for Microserver 12  November 2012 Document Number: 328198-001  
  PCIe* Root Port May Transmit a Truncated DLLP  	  If a PCIe root port is configured to be an x2 link and it nullifies a transmitted TLP (Transaction Layer Packet), then due to this erratum, the root port may transmit a truncated DLLP (Data Link Layer Packet) subsequent to the nullified TLP.  	 When a link partner receives the truncated DLLP, it may signal a Framing Error and subsequently retrain the link. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  The Processor May Hang Under Complex Conditions When Thermal Throttling Is Enabled  	  Processor may hang when a transaction is master aborted by the processor during thermal throttling state.  	 This erratum may cause the processor to hang when thermal throttling is enabled 	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Incorrect Logging of Masked PCIe Root Fabric AER Errors  	  When simultaneous multiple PCIe Root Fabric AER errors occur, the processor may log the AER Header of the higher priority error even if it is masked.  	 This erratum may impact the error logging capabilities of the processor. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  SMBus ERRUNCSEV Register Has The Wrong Default Value For Some Bits  	  Due to this erratum, the uncorrectable error Severity Register for the SMBus controller (Bus 0; Device 19; Function 0, 1; offset 108H, bit 12, 15, 16, 20) is incorrectly initialized at reset.  	 By default, uncorrectable errors incurred by the SMBus controller may be signaled as fatal errors. 	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.  November 2012 Document Number: 328198-001  Intel® Atom™ Processor S1200 Product Family for Microserver 13  
  PCIe* Header Log Register Contents Does Not Conform to Specification  	  The PCIe Header Log Register (Device 14; Function 0; Offset 1CH) captures the TLP (Transaction Layer Packet) header when an error is detected. Due to this erratum, the 32-bit items comprising the TLP header appear in reversed order with respect to the PCIe Base Specification definition for this register. That is, ordered as HDRLOG4..HDRLOG1 rather than the specified HDRLOG1..HDRLOG4.  	 Software attempting to access the Header Log Register may not behave as expected. 	 None identified. It is possible to modify software accessing the Header Log Register to compensate for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  PCIe Root Port May Not Treat TLP as a Malformed TLP  	  A PCIe root port that receives a TLP (Transaction Layer Packet) with a data size greater than Max_Packet_Size must treat that TLP as a Malformed TLP. Due to this erratum, the processor may not treat the TLP as a Malformed TLP.  	 Receipt of TLPs with data sizes greater than Max_Packet_Size may lead to unpredictable system behavior. Intel has not observed this erratum with any commercially available system. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  PCIe Ports May Log Receiver Overflow Error on an Unexpected Completion  	  Upon receipt of an Unexpected Completion, the PCIe Root Port (Bus 0; Device 1-4; Function 0) may log a Receiver Overflow error in addition to an unexpected completion error.  	 Due to this erratum, a Receiver Overflow error may be logged incorrectly. If Receiver Overflow errors are configured to be Fatal errors, this may result in a system hang. 	 To avoid a hang, it is possible to configure Receiver Overflow errors to be Non-Fatal errors 	  For the steppings affected, see the Summary Table of Changes.  Intel® Atom™ Processor S1200 Product Family for Microserver 14  November 2012 Document Number: 328198-001  
  Thermal Trip May be Asserted During Cold Reset  	  A false thermal-trip event can occur during cold reset.  	 Due to this erratum, the system may shutdown during cold reset. 	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software. 	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  For the steppings affected, see the Summary Table of Changes. 
  Synchronous Reset of IA32_MPERF on IA32_APERF Overflow May Not Work  	  When either the IA32_MPERF or IA32_APERF MSR (E7H, E8H) increments to its maximum value of 0xFFFF_FFFF_FFFF_FFFF, both MSRs are supposed to synchronously reset to 0x0 on the next clock. Due to this erratum, IA32_MPERF may not be reset when IA32_APERF overflows. Instead, IA32_MPERF may continue to increment without being reset.  	 Due to this erratum, software cannot rely on synchronous reset of the IA32_MPERF register. The typical usage of IA32_MPERF/IA32_APERF is to initialize them with a value of 0; in this case the overflow of the counter wouldn’t happen for over 10 years. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes.  November 2012 Document Number: 328198-001  Intel® Atom™ Processor S1200 Product Family for Microserver 15  
  A Page Fault May Not be Generated When the PS bit is set to “1” in a PML4E or PDPTE  	  On processors supporting Intel® 64 architecture, the PS bit (Page Size, bit 7) is reserved in PML4Es and PDPTEs. If the translation of the linear address of a memory access encounters a PML4E or a PDPTE with PS set to 1, a page fault should occur. Due to this erratum, PS of such an entry is ignored and no page fault will occur due to its being set.  	 Software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries. 	 Software should not set bit 7 in any PML4E or PDPTE that has Present Bit (Bit 0) set to “1.” 	  For the steppings affected, see the Summary Table of Changes. 
  LBR/BTM/BTS Information Immediately After a Transition From Legacy/Compatibility Mode to 64-bit Mode May be Incorrect  	  If a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any FROM address recorded by LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) on that second event may incorrectly report the upper 32 bits as zero.  	 Due to this erratum, bits 63:32 of the ‘FROM’ value for LBR/BTM/BTS may be improperly zeroed after a transition to 64 bite mode when the RIP (Instruction Pointer Register) is greater than 4 Gigabyte. 	 None identified. This erratum may be detected by a ‘FROM’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘TO’ address recorded. 	  For the steppings affected, see the Summary Table of Changes. 
  VID Information in IA32_PERF_STS MSR Bits [7:0] May be Incorrect  	  IA32_PERF_STS MSR (198H) bits [7:0] are supposed to indicate the VID (Voltage ID) after an Enhanced Intel SpeedStep® Technology transition. Due to this erratum, one core in a dual core CPU may report incorrect VID values in certain corner cases.  	 IA32_PERF_STS MSR bits [7:0] may contain incorrect VID values after certain Enhanced Intel SpeedStep® Technology transitions. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes.  Intel® Atom™ Processor S1200 Product Family for Microserver 16  November 2012 Document Number: 328198-001  
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring >0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  A VM Exit Occurring in IA-32e Mode May Not Produce a VMX Abort When Expected  	  If a VM exit occurs while the processor is in IA-32e mode and the “host address-space size” VM-exit control is 0, a VMX abort should occur. Due to this erratum, the expected VMX aborts may not occur and instead the VM Exit will occur normally. The conditions required to observe this erratum are a VM entry that returns from SMM with the “IA-32e guest” VM-entry control set to 1 in the SMM VMCS and the “host address-space size” VM-exit control cleared to 0 in the executive VMCS.  	 A VM exit will occur when a VMX abort was expected. 	 An SMM VMM should always set the “IA-32e guest” VM-entry control in the SMM VMCS to be the value that was in the LMA bit (IA32_EFER.LMA.LMA[bit 10]) in the IA32_EFER MSR (C0000080H) at the time of the last SMM VM exit. If this guideline is followed, that value will be 1 only if the “host address-space size” VM-exit control is 1 in the executive VMCS. 	  For the steppings affected, see the Summary Table of Changes. 
  C6 Auto-Demotion Does Not Occur as Expected  	  C6 auto-demotion is enabled by setting PMG_CST_CONFIG_CONTROL MSR (E2H) bit 25 to 1. When enabled, C6 C-state is demoted to a lower C-state if average C6 residency time is low. Due to this erratum auto-demotion will not occur even when this bit is set and the average C6 residency time is low.  	 Due to this erratum the C6 transition may occur more frequently than desired. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.  November 2012 Document Number: 328198-001  Intel® Atom™ Processor S1200 Product Family for Microserver 17  
  APIC Timer Can Expire Earlier Than Expected  	  Under certain circumstances, the APIC Timer may expire early on the first expiration after the CCR (Current Count Register) of the Local APIC is programmed. If the CCR in the APIC is written when BUS clock frequency is twice as fast as the nominal BUS clock, the first countdown of the APIC Timer may expire n nominal BUS clocks early, where n can be [1, 2, 4, 8, 16, 32, 64, 128] as determined by the DCR (Divide Configuration Register) in the Local APIC. In the worst case, for a nominal BUS frequency of 100 MHz and a DCR of 128 the APIC Timer can expire 1280 ns early.  	 When the CCR is written while BUS clock frequency is twice as fast as the nominal BUS clock the APIC timer may expire early on the first expiration. 	 None identified. 	  For the steppings affected, see the Summary Table of Changes. 
  Core C-state Residency MSR Values Are Incorrect  	  RDMSR of the core C-state residency MSRs will return a value of zero regardless of the actual residency time. This affects the following MSRs: • C2_RESIDENCY_TIMER (3F8H) • C4_RESIDENCY_TIMER (3F9H) • C6_RESIDENCY_TIMER (3FAH)  	 Software cannot determine core C-state residencies by reading these MSRs. 	 It is possible for the BIOS to contain a workaround. 	  For the steppings affected, see the Summary Table of Changes. 
  Local APIC Timer Expiration May Not be Honored if Software Requests Different Deep C-states For Each Logical Processor  	  If one logical processor requests the C6 state and the other logical processor requests the C4 state in close temporal proximity, the local APIC timer expiration event of the logical processor going to C6 may be dropped.  	 The platform will wake based only on the local APIC timer of the logical processor going to C4, or can hang if the timer is disabled. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.  Intel® Atom™ Processor S1200 Product Family for Microserver 18  November 2012 Document Number: 328198-001  
  Task-switching IRET May Not Guarantee That All Memory Writes Have Become Globally Visible  	  Serializing instructions ensure that all preceding memory writes have become globally visible before any subsequent load or store instruction. An IRET is a serializing instruction. Due to this erratum, an IRET instruction that performs a task-switch does not guarantee serializing behavior.  	 Memory writes may not be observed in the correct order with respect to the taskswitching IRET instruction. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  An Indirect Jump Instruction May Execute to An Incorrect Target  	  An indirect jump instruction may execute incorrectly to the target from a previous instance of the jump instead of to the correct target. This may occur only when the indirect jump is part of a short loop.  	 Due to this erratum, an indirect jump may cause unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  A VM Exit as a Result of a Task-Switching IRET May Not Properly Save the State of NMI Blocking  	  A VM exit due to a fault or an EPT violation caused by an IRET instruction should set bit 12 (NMI unblocking due to IRET) of the VM-exit interruption-information field or the exit qualification respectively. This is required if IRET began execution when either (1) the “NMI exiting” VM-execution control was 0 and blocking by NMI was in effect; or (2) the “virtual NMIs” VM-execution control was 1 and virtual-NMI blocking was in effect. Due to this erratum, such VM exits may clear this bit if the IRET was causing a task switch.  	 If a VMM resumes a guest at the IRET instruction after handling such a VM exit, an NMI or a VM exit due to the 1-setting of the “NMI-window exiting” VM-execution control may be delivered prematurely. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.  November 2012 Document Number: 328198-001  Intel® Atom™ Processor S1200 Product Family for Microserver 19  
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel® 64 and IA32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Section: Handling Self- and CrossModifying Code. 	  For the steppings affected, see the Summary Table of Changes. 
  Software Requested or Thermal Based Clock Modulation May Not Result in an Accurate Stop-Clock Duty Cycle  	  Clock modulation can occur either by software request through the IA32_CLOCK_MODULATION MSR (19AH) or based on thermal conditions when the TM1 feature is enabled (bit 3) in IA32_MISC_ENABLE MSR(1A0H). Both engage internal stop-clock circuitry to impose a requested clocking duty cycle. This requested duty cycle ranges from 12.5% to 87.5%. Due to this erratum, the actual duty cycle may deviate from the requested duty cycle.  	 Software which is sensitive to the accuracy of the requested clock modulation duty cycle may not operate properly. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes. 
  Programming MSR_PKG_CST_CONFIG_CONTROL Package C-state Limit Field to 0x3 May Result in a System Hang  	  When software requests an MWAIT with a target state of 2 or greater and the MSR_PKG_CST_CONFIG_CONTROL MSR (0E2H) Package C-state Limit (bits 2:0) is programmed with a value of 0x3 it is possible for the system to hang.  	 Due to this erratum, an MWAIT instruction could result in a system hang. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Table of Changes.  Intel® Atom™ Processor S1200 Product Family for Microserver 20  November 2012 Document Number: 328198-001  
  CS Limit Violations May Not be Detected After VM Entry  	  The processor may fail to detect a CS limit violation on fetching the first instruction after VM entry if the first byte of that instruction is outside the CS limit but the last byte of the instruction is inside the limit.  	 The processor may erroneously execute an instruction that should have caused a general protection exception. 	 When a VMM emulates a branch instruction, it should inject a general protection exception if the instruction’s target EIP is beyond the CS limit. 	  For the steppings affected, see the Summary Table of Changes. 
  Fast-String Operations Are Not Enabled by Default  	  IA32_MISC_ENABLE MSR (1A0H) Fast Strings Enable bit 0 should be set to 1 after reset. Due to this erratum, it has a value of 0 after reset.  	 Code capable of utilizing fast-string operations will not be optimized until fast strings are enabled. 	 Software can enable the fast-strings feature by setting bit 0 of IA32_MISC_ENABLE MSR. 	  For the steppings affected, see the Summary Table of Changes. 
  PCIe* Root Ports May Incorrectly Indicate CRS Software Visibility Support  	  The PCIe Root Port ROOTCAP.CRSSV (Bus 0; Device 1-4; Function 0; offset 5EH; bit 0) field indicates that the root port is capable of returning CRS (Configuration Request Retry Status) completion status to software. Due to this erratum, the default value of this bit is set to 1, incorrectly indicating that CRS is supported.  	 Due to this erratum, software that expects CRS completion status may not function as expected. 	 A BIOS code change has been identified and may be implemented as a workaround for this erratum. 	NA
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  LOCK# Asserted During a Special Cycle Shutdown Transaction May Unexpectedly De-assert  	  During a processor shutdown transaction, when LOCK# is asserted and if a DEFER# is received during a snoop phase and the Locked transaction is pipelined on the front side bus (FSB), LOCK# may unexpectedly de-assert.  	 When this erratum occurs, the system may hang during shutdown. Intel has not observed this erratum with any commercially available systems or software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Address Reported by Machine-Check Architecture (MCA) on Single-bit L2 ECC Errors May be Incorrect  	  When correctable Single-bit ECC errors occur in the L2 cache, the address is logged in the MCA address register (MCi_ADDR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in MCi_ADDR, for Single-bit L2 ECC errors.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  23   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VERW/VERR/LSL/LAR Instructions May Unexpectedly Update the Last Exception Record (LER) MSR  	  The LER MSR may be unexpectedly updated, if the resultant value of the Zero Flag (ZF) is zero after executing the following instructions 1) VERR (ZF=0 indicates unsuccessful segment read verification) 2) VERW (ZF=0 indicates unsuccessful segment write verification) 3) LAR (ZF=0 indicates unsuccessful access rights load) 4) LSL (ZF=0 indicates unsuccessful segment limit load)  	 The value of the LER MSR may be inaccurate if VERW/VERR/LSL/LAR instructions are executed after the occurrence of an exception. 	 Software exception handlers that rely on the LER MSR value should read the LER MSR before executing VERW/VERR/LSL/LAR instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  DR3 Address Match on MOVD/MOVQ/MOVNTQ Memory Store Instruction May Incorrectly Increment Performance Monitoring Count for Saturating SIMD Instructions Retired (Event CFH)  	  Performance monitoring for Event CFH normally increments on saturating SIMD instruction retired. Regardless of DR7 programming, if the linear address of a retiring memory store MOVD/MOVQ/MOVNTQ instruction executed matches the address in DR3, the CFH counter may be incorrectly incremented.  	 The value observed for performance monitoring count for saturating SIMD instructions retired may be too high. The size of the error is dependent on the number of occurrences of the conditions described above, while the counter is active. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  SYSRET May Incorrectly Clear RF (Resume Flag) in the RFLAGS Register  	  In normal operation, SYSRET will restore the value of RFLAGS from R11 (the value previously saved upon execution of the SYSCALL instruction). Due to this erratum, the RFLAGS.RF bit will be unconditionally cleared after execution of the SYSRET instruction.  	 The SYSRET instruction can not be used if the RF flag needs to be set after returning from a system call. Intel has not observed this erratum with any commercially available software. 24  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 Use the IRET instruction to return from a system call, if RF flag has to be set after the return. 	  For the steppings affected, see the Summary Tables of Changes. 
  General Protection Fault (#GP) for Instructions Greater than 15 Bytes May be Preempted  	  When the processor encounters an instruction that is greater than 15 bytes in length, a #GP is signaled when the instruction is decoded. Under some circumstances, the #GP fault may be preempted by another lower priority fault (e.g. Page Fault (#PF)). However, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #GP fault will occur.  	 Software may observe a lower-priority fault occurring before or in lieu of a #GP fault. Instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  25  
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB will be incorrectly handled as follows: •  #DB is signaled before the pending higher priority #MF (Interrupt 16)  •  #DB is generated twice on the same instruction  	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory-based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, e.g. CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 26  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	  For the steppings affected, see the Summary Tables of Changes. 
  Count Value for Performance-Monitoring Counter PMH_PAGE_WALK May be Incorrect  	  Performance-Monitoring Counter PMH_PAGE_WALK is used to count the number of page walks resulting from Data Translation Look-Aside Buffer (DTLB) and Instruction Translation Look-Aside (ITLB) misses. Under certain conditions, this counter may be incorrect.  	 There may be small errors in the accuracy of the counter. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  LER MSRs May be Incorrectly Updated  	  The LER (Last Exception Record) MSRs, MSR_LER_FROM_LIP (1DDH) and MSR_LER_TO_LIP (1DEH) may contain incorrect values after any of the following: •  Either STPCLK#, NMI (NonMaskable Interrupt) or external interrupts  •  CMP or TEST instructions with an uncacheable memory operand followed by a conditional jump  •  STI/POP SS/MOV SS instructions followed by CMP or TEST instructions and then by a conditional jump  	 When the conditions for this erratum occur, the value of the LER MSRs may be incorrectly updated. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for Retired Instructions (C0H) May Not Be Accurate  	  The INST_RETIRED performance monitor may miscount retired instructions as follows: •  Repeat string and repeat I/O operations are not counted when a hardware interrupt is received during or after the last iteration of the repeat flow.  •  VMLAUNCH and VMRESUME instructions are not counted.  • 	NA	NA	NA
 b) RSM from an SMI during a HLT instruction.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  27   	NA	 There may be a smaller than expected value in the INST_RETIRED performance monitoring counter. The extent to which this value is smaller than expected is determined by the frequency of the above cases. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event For Number Of Reference Cycles When The Processor Is Not Halted (3CH) Does Not Count According To The Specification  	  The CPU_CLK_UNHALTED performance monitor with mask 1 counts bus clock cycles instead of counting the core clock cycles at the maximum possible ratio. The maximum possible ratio is computed by dividing the maximum possible core frequency by the bus frequency.  	 The CPU_CLK_UNHALTED performance monitor with mask 1 counts a value lower than expected. The value is lower by exactly one multiple of the maximum possible ratio. 	 Multiply the performance monitor value by the maximum possible ratio. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit 20 may not be masked. •  Paging is enabled  •  A linear address has bit 20 set  •  The address references a large page  •  A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system. 	 Operating systems should not allow A20M# to be enabled if the masking of address bit 20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  Writing Shared Unaligned Data that Crosses a Cache Line without Proper Semaphores or Barriers May Expose a Memory Ordering Issue  	  Software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory  28  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   ordering issue if multiple loads access this shared data shortly thereafter. Exposure to this problem requires the use of a data write which spans a cache line boundary. 	 This erratum may cause loads to be observed out of order. Intel has not observed this erratum with any commercially available software or system. 	 Software should ensure at least one of the following is true when modifying shared data by multiple agents: •  The shared data is aligned  •  Proper semaphores or barriers are used in order to prevent concurrent data accesses.  	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit Violation May Occur on 4 Gigabyte Limit Check  	  Code Segment limit violation may occur on 4 Gigabyte limit check when the code stream wraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.  	 This is a rare condition that may result in a system hang. Intel has not observed this erratum with any commercially available software, or system. 	 Avoid code that wraps around segment limit. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Inexact-Result Exception Flag May Not Be Set  	  When the result of a floating-point operation is not exactly representable in the destination format (1/3 in binary form, for example), an inexact-result (precision) exception occurs. When this occurs, the PE bit (bit 5 of the FPU status word) is normally set by the processor. Under certain rare conditions, this bit may not be set when this rounding occurs. However, other actions taken by the processor (invoking the software exception handler if the exception is unmasked) are not affected. This erratum can only occur if one of the following FST instructions is one or two instructions after the floatingpoint operation which causes the precision exception: • • • • • • • • • • • • •  FST m32real FST m64real FSTP m32real FSTP m64real FSTP m80real FIST m16int FIST m32int FISTP m16int FISTP m32int FISTP m64int FISTTP m16int FISTTP m32int FISTTP m64int  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  29   Note that even if this combination of instructions is encountered, there is also a dependency on the internal pipelining and execution state of both instructions in the processor.  	 Inexact-result exceptions are commonly masked or ignored by applications, as it happens frequently, and produces a rounded result acceptable to most applications. The PE bit of the FPU status word may not always be set upon receiving an inexact-result exception. Thus, if these exceptions are unmasked, a floating-point error exception handler may not recognize that a precision exception occurred. Note that this is a "sticky" bit, i.e., once set by an inexact-result condition, it remains set until cleared by software. 	 This condition can be avoided by inserting either three NOPs or three nonfloating-point non-Jcc instructions between the two floating-point instructions. 	  For the steppings affected, see the Summary Tables of Changes. 
  Global Pages in the Data Translation Look-Aside Buffer (DTLB) May Not Be Flushed by RSM instruction before Restoring the Architectural State from SMRAM  	  The Resume from System Management Mode (RSM) instruction does not flush global pages from the Data Translation Look-Aside Buffer (DTLB) prior to reloading the saved architectural state.  	 If SMM turns on paging with global paging enabled and then maps any of linear addresses of SMRAM using global pages, RSM load may load data from the wrong location. 	 Do not use global pages in system management mode. 	  For the steppings affected, see the Summary Tables of Changes. 
  Sequential Code Fetch to Non-canonical Address May have Nondeterministic Results  	  If code sequentially executes off the end of the positive canonical address space (falling through from address 00007fffffffffff to non- canonical address 0000800000000000), under some circumstances the code fetch will be converted to a canonical fetch at address ffff800000000000.  	 Due to this erratum, the processor may transfer control to an unintended address. The result of fetching code at that address is unpredictable and may include an unexpected trap or fault, or execution of the instructions found there.  30  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 If the last page of the positive canonical address space is not allocated for code (4K page at 00007ffffffff000 or 2M page at 00007fffffe00000) then the problem cannot occur. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMCALL to Activate Dual-monitor Treatment of SMIs and SMM Ignores Reserved Bit settings in VM-exit Control Field  	  Processors supporting Intel® Virtualization Technology can execute VMCALL from within the Virtual Machine Monitor (VMM) to activate dual-monitor treatment of SMIs and SMM. Due to this erratum, if reserved bits are set to values inconsistent with VMX Capability MSRs, VMCALL may not VMFail.  	 VMCALL executed to activate dual-monitor treatment of SMIs and SMM may not VMFail due to incorrect reserved bit settings in VM-Exit control field. 	 Software should ensure that all VMCS reserved bits are set to values consistent with VMX Capability MSRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  The PECI Controller Resets to the Idle State  	  After reset, the Platform Environment Control Interface (PECI) client controller should first identify a PECI bus idle condition and only then search for the first rising edge. Due to this erratum, the processor PECI controller resets into the "Idle Detected" state upon processor reset. If another PECI device on the platform is attempting to send a message as the processor PECI controller comes out of reset, the processor PECI controller will typically experience a Frame Check Sequence error and move to the idle state. Rarely, the processor PECI controller may interpret that the message was intended for it and try to reply. In this case a message may be corrupted but this situation will be caught and handled by the PECI error handling protocol.  	 The processor PECI controller resets to an incorrect state but the error handling capability of PECI will resolve the situation so that the processor will be able to respond to an incoming message immediately after reset and will not disregard an incoming message that arrives before an idle bus is formally detected. 	 No workaround is necessary due to the PECI error handling protocol. 	  For the steppings affected, see the Summary Tables of Changes. 
  Some Bus Performance Monitoring Events May Not Count Local Events under Certain Conditions  	  Many Performance Monitoring Events require core-specificity, which specifies which core’s events are to be counted (local core, other core or both cores). Due to this erratum, some Bus Performance Monitoring events may not count when the core-specificity is set to the local core.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  31   The following Bus Performance Monitoring events will not count power management related events for local core-specificity: •  BUS_TRANS_ IO (Event: 6CH) – Will not count I/O level reads resulting from package-resolved C-state  •  BUS_TRANS_ANY (Event: 70H) – Will not count Stop-Grants  	 The count values for the affected events may be lower than expected. The degree of undercount depends on the occurrence of erratum conditions while the affected events are active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Premature Execution of a Load Operation Prior to Exception Handler Invocation  	  If any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. •  If an instruction that performs a memory load causes a code segment limit violation.  •  If a waiting X87 floating-point (FP) instruction or MMX™ technology (MMX) instruction that performs a memory load has a floating-point exception pending.  •  If an MMX or SSE/SSE2/SSE3/SSSE3 extensions (SSE) instruction that performs a memory load and has either CR0.EM=1 (Emulation bit set), or a floating-point Top-of-Stack (FP TOS) not equal to 0, or a DNA exception pending.  	 In normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. If the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side-effect. Particularly, while CR0.TS [bit 3] is set, a MOVD/MOVQ with MMX/XMM register operands may issue a memory load before getting the DNA exception. 	 Code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory.	NA
  General Protection (#GP) Fault May Not Be Signaled on Data Segment Limit Violation above 4-G Limit  	  In 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4G limit (0ffffffffh) may not signal a #GP fault.  	 When such memory accesses occur in 32-bit mode, the system may not issue a #GP fault. 32  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 Software should ensure that memory accesses in 32-bit mode do not occur above the 4G limit (0ffffffffh). 	  For the steppings affected, see the Summary Tables of Changes. 
  EIP May be Incorrect after Shutdown in IA-32e Mode  	  When the processor is going into shutdown state the upper 32 bits of the instruction pointer may be incorrect. This may be observed if the processor is taken out of shutdown state by NMI#.  	 A processor that has been taken out of the shutdown state may have an incorrect EIP. The only software which would be affected is diagnostic software that relies on a valid EIP. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  #GP Fault is Not Generated on Writing IA32_MISC_ENABLE [34] When Execute Disable Bit is Not Supported  	  A #GP fault is not generated on writing to IA32_MISC_ENABLE [34] bit in a processor which does not support Execute Disable Bit functionality.  	 Writing to IA32_MISC_ENABLE [34] bit is silently ignored without generating a fault. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  (E)CX May Get Incorrectly Updated When Performing Fast String REP MOVS or Fast String REP STOS With Large Data Structures  	  When performing Fast String REP MOVS or REP STOS commands with data structures [(E)CX*Data Size] larger than the supported address size structure (64K for 16-bit address size and 4G for 32-bit address size) some addresses may be processed more than once. After an amount of data greater than or equal to the address size structure has been processed, external events (such as interrupts) will cause the (E)CX registers to be increment by a value that corresponds to 64K bytes for 16 bit address size and 4G bytes for 32 bit address size.  	 (E)CX may contain an incorrect count which may cause some of the MOVS or STOS operations to re-execute. Intel has not observed this erratum with any commercially available software. 	 Do not use values in (E)CX that when multiplied by the data size give values larger than the address space size (64K for 16-bit address size and 4G for 32-bit address size). 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  33  
  Performance Monitoring Events for Retired Loads (CBH) and Instructions Retired (C0H) May Not Be Accurate  	  The following events may be counted as instructions that contain a load by the MEM_LOAD_RETIRED performance monitor events and may be counted as loads by the INST_RETIRED (mask 01H) performance monitor event: • • • • • • •  Prefetch instructions x87 exceptions on FST* and FBSTP instructions Breakpoint matches on loads, stores, and I/O instructions Stores which update the A and D bits Stores that split across a cache line VMX transitions Any instruction fetch that misses in the ITLB  	 The MEM_LOAD_RETIRED and INST_RETIRED (mask 01H) performance monitor events may count a value higher than expected. The extent to which the values are higher than expected is determined by the frequency of the above events. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Upper 32 bits of 'From' Address Reported through BTMs or BTSs May be Incorrect  	  When a far transfer switches the processor from 32-bit mode to IA-32e mode, the upper 32 bits of the 'From' (source) addresses reported through the BTMs (Branch Trace Messages) or BTSs (Branch Trace Stores) may be incorrect.  	 The upper 32 bits of the 'From' address debug information reported through BTMs or BTSs may be incorrect during this transition 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  34  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel Architecture Software Developer's Manual Volume 3: System Programming Guide, including a General Protection Fault (GPF) or other unexpected behaviors. In the event that unpredictable execution causes a GPF the application executing the unsynchronized XMC operation would be terminated by the operating system. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel Architecture Software Developer's Manual Volume 3: System Programming Guide, Section: Handling Self- and Cross-Modifying Code. 	  For the steppings affected, see the Summary Tables of Changes. 
  MSRs Actual Frequency Clock Count (IA32_APERF) or Maximum Frequency Clock Count (IA32_MPERF) May Contain Incorrect Data after a Machine Check Exception (MCE)  	  When an MCE occurs during execution of a RDMSR instruction for MSRs Actual Frequency Clock Count (IA32_APERF) or Maximum Frequency Clock Count (IA32_MPERF), the current and subsequent RDMSR instructions for these MSRs may contain incorrect data.  	 After an MCE event, accesses to the IA32_APERF and IA32_MPERF MSRs may return incorrect data. A subsequent reset will clear this condition. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	 Software should avoid memory accesses that wrap around the respective 16bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  Split Locked Stores May not Trigger the Monitoring Hardware  	 	NA	NA	NA
 when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  35   Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store that spans across cache lines within the monitored address range.	NA	NA	NA	NA
 execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is split across cache lines. 	NA	NA	 Do not use locked stores that span cache lines in the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP CMPS/SCAS Operations May Terminate Early in 64-bit Mode when RCX >= 0X100000000  	  REP CMPS (Compare String) and SCAS (Scan String) instructions in 64-bit mode may terminate before the count in RCX reaches zero if the initial value of RCX is greater than or equal to 0X100000000.  	 Early termination of REP CMPS/SCAS operation may be observed and RFLAGS may be incorrectly updated. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  FXSAVE/FXRSTOR Instructions which Store to the End of the Segment and Cause a Wrap to a Misaligned Base Address (Alignment <= 0x10h) May Cause FPU Instruction or Operand Pointer Corruption  	  If a FXSAVE/FXRSTOR instruction stores to the end of the segment causing a wrap to a misaligned base address (alignment <= 0x10h), and one of the following conditions is satisfied: 1) 32-bit addressing, obtained by using address-size override, when in 64-bit mode 2) 16-bit addressing in legacy or compatibility mode Then, depending on the wrap-around point, one of the below saved values may be corrupted: • • • •  FPU FPU FPU FPU  Instruction Pointer Offset Instruction Pointer Selector Operand Pointer Selector Operand Pointer Offset  	 This erratum could cause FPU Instruction or Operand pointer corruption and may lead to unexpected operations in the floating point exception handler. 	 Avoid segment base mis-alignment and address wrap-around at the segment boundary. 	 36  For the steppings affected, see the Summary Tables of Changes. Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence  
  Cache Data Access Request from One Core Hitting a Modified Line in the L1 Data Cache of the Other Core May Cause Unpredictable System Behavior  	  When request for data from Core 1 results in a L1 cache miss, the request is sent to the L2 cache. If this request hits a modified line in the L1 data cache of Core 2, certain internal conditions may cause incorrect data to be returned to the Core 1.  	 This erratum may cause unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PREFETCHh Instruction Execution under Some Conditions May Lead to Processor Livelock  	  PREFETCHh instruction execution after a split load and dependent upon ongoing store operations may lead to processor livelock.  	 Due to this erratum, the processor may livelock. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  PREFETCHh Instructions May Not be Executed when Alignment Check (AC) is Enabled  	  PREFETCHT0, PREFETCHT1, PREFETCHT2 and PREFETCHNTA instructions may not be executed when Alignment Check is enabled.  	 PREFETCHh instructions may not perform the data prefetch if Alignment Check is enabled. 	 Clear the AC flag (bit 18) in the EFLAGS register and/or the AM bit (bit 18) of Control Register CR0 to disable alignment checking. 	  For the steppings affected, see the Summary Tables of Changes. 
  Upper 32 Bits of the FPU Data (Operand) Pointer in the FXSAVE Memory Image May Be Unexpectedly All 1's after FXSAVE  	  The upper 32 bits of the FPU Data (Operand) Pointer may incorrectly be set to all 1's instead of the expected value of all 0's in the FXSAVE memory image if all of the following conditions are true: • • • •  The processor is in 64-bit mode. The last floating point operation was in compatibility mode Bit 31 of the FPU Data (Operand) Pointer is set. An FXSAVE instruction is executed  	 Software depending on the full FPU Data (Operand) Pointer may behave unpredictably. Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  37   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Concurrent Multi-processor Writes to Non-dirty Page May Result in Unpredictable Behavior  	  When a logical processor writes to a non-dirty page, and another logicalprocessor either writes to the same non-dirty page or explicitly sets the dirty bit in the corresponding page table entry, complex interaction with internal processor activity may cause unpredictable system behavior.  	 This erratum may result in unpredictable system behavior and hang. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor IDLE_DURING_DIV (18h) Count May Not be Accurate  	  Performance monitoring events that count the number of cycles the divider is busy and no other execution unit operation or load operation is in progress may not be accurate.  	 The counter may reflect a value higher or lower than the actual number of events. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Shutdown Condition May Disable Non-Bootstrap Processors  	  When a logical processor encounters an error resulting in shutdown, nonbootstrap processors in the package may be unexpectedly disabled.  38  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 Non-bootstrap logical processors in the package that have not observed the error condition may be disabled and may not respond to INIT#, SMI#, NMI#, SIPI or other events. 	 When this erratum occurs, RESET# must be asserted to restore multi-core functionality. 	  For the steppings affected, see the Summary Tables of Changes. 
  SYSCALL Immediately after Changing EFLAGS.TF May Not Behave According to the New EFLAGS.TF  	  If a SYSCALL instruction follows immediately after EFLAGS.TF was updated and IA32_FMASK.TF (bit 8) is cleared, then under certain circumstances SYSCALL may behave according to the previous EFLAGS.TF.  	 When the problem occurs, SYSCALL may generate an unexpected debug exception, or may skip an expected debug exception. 	 Mask EFLAGS.TF by setting IA32_FMASK.TF (bit 8). 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break (#DB), Machine Check (#MC), etc.)  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VM Bit is Cleared on Second Fault Handled by Task Switch from Virtual-8086 (VM86)  	  Following a task switch to any fault handler that was initiated while the processor was in VM86 mode, if there is an additional fault while servicing the original task switch then the VM bit will be incorrectly cleared in EFLAGS, data segments will not be pushed and the processor will not return to the correct mode upon completion of the second fault handler via IRET.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  39   	 When the OS recovers from the second fault handler, the processor will no longer be in VM86 mode. Normally, operating systems should prevent interrupt task switches from faulting, thus the scenario should not occur under normal circumstances. 	 None Identified 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_FMASK is Reset during an INIT  	  IA32_FMASK MSR (0xC0000084) is reset during INIT.  	 If an INIT takes place after IA32_FMASK is programmed, the processor will overwrite the value back to the default value. 	 Operating system software should initialize IA32_FMASK after INIT. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  40  For the steppings affected, see the Summary Tables of Changes.  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence  
  Last Branch Records (LBR) Updates May be Incorrect after a Task Switch  	  A Task-State Segment (TSS) task switch may incorrectly set the LBR_FROM value to the LBR_TO value.  	 The LBR_FROM will have the incorrect address of the Branch Instruction. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May Be Set Incorrectly  	  The IO_SMI bit in SMRAM's location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by •  A non-I/O instruction.  •  SMI is pending while a lower priority event interrupts  •  A REP I/O read  • 	NA	NA	NA
  •  In systems supporting Intel® Virtualization Technology a fault in the middle of an IO operation that causes a VM Exit  	NA	 SMM handlers may get false IO_SMI indication. 	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  For the steppings affected, see the Summary Tables of Changes. 
  INIT Does Not Clear Global Entries in the TLB  	  INIT may not flush a TLB entry when: •  The processor is in protected mode with paging enabled and the page global enable flag is set (PGE bit of CR4 register)  •  G bit for the page table entry is set  •  TLB entry is present in TLB when INIT occurs  	 Software may encounter unexpected page fault or incorrect address translation due to a TLB entry erroneously left in TLB after INIT. 	 Write to CR3, CR4 (setting bits PSE, PGE or PAE) or CR0 (setting bits PG or PE) registers before writing to memory early in BIOS code to clear all the global entries from TLB. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  41  
  Using Memory Type Aliasing with Memory Types WB/WT May Lead to Unpredictable Behavior  	  Memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory type. Memory type aliasing with the memory types WB and WT may cause the processor to perform incorrect operations leading to unpredictable behavior.  	 Software that uses aliasing of WB and WT memory types may observe unpredictable behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Update of Read/Write (R/W) or User/Supervisor (U/S) or Present (P) Bits without TLB Shootdown May Cause Unexpected Processor Behavior  	  Updating a page table entry by changing R/W, U/S or P bits without TLB shootdown (as defined by the 4 step procedure in "Propagation of Page Table and Page Directory Entry Changes to Multiple Processors" In volume 3A of the IA-32 Intel® Architecture Software Developer's Manual), in conjunction with a complex sequence of internal processor micro-architectural events, may lead to unexpected processor behavior.  	 This erratum may lead to livelock, shutdown or other unexpected processor behavior. Intel has not observed this erratum with any commercially available system. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  BTS Message May Be Lost When the STPCLK# Signal is Active.  	  STPCLK# is asserted to enable the processor to enter a low-power state. Under some circumstances, when STPCLK# becomes active, the BTS (Branch Trace Store) message may be either lost and not written or written with corrupted branch address to the Debug Store area  	 BTS messages may be lost or be corrupted in the presence of STPCLK# assertions. 	 None Identified. 	  42  For the steppings affected, see the Summary Tables of Changes.  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence  
  CMPSB, LODSB, or SCASB in 64-bit Mode with Count Greater or Equal to 248 May Terminate Early  	  In 64-bit Mode CMPSB, LODSB, or SCASB executed with a repeat prefix and count greater than or equal to 248 may terminate early. Early termination may result in one of the following. •  The last iteration not being executed  •  Signaling of a canonical limit fault (#GP) on the last iteration  	 While in 64-bit mode, with count greater or equal to 248, repeat string operations CMPSB, LODSB or SCASB may terminate without completing the last iteration. Intel has not observed this erratum with any commercially available software. 	 Do not use repeated string operations with RCX greater than or equal to 248. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP MOVS/STOS Executing with Fast Strings Enabled and Crossing Page Boundaries with Inconsistent Memory Types may use an Incorrect Data Size or Lead to Memory-Ordering Violations.  	  Under certain conditions as described in the Software Developers Manual section “Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors” the processor performs REP MOVS or REP STOS as fast strings. Due to this erratum fast string REP MOVS/REP STOS instructions that cross page boundaries from WB/WC memory types to UC/WP/WT memory types, may start using an incorrect data size or may observe memory ordering violations.  	 Upon crossing the page boundary the following may occur, dependent on the new page memory type: •  UC the data size of each write will now always be 8 bytes, as opposed to the original data size.  •  WP the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation.  •  WT there may be a memory ordering violation.  	 Software should avoid crossing page boundaries from WB or WC memory type to UC, WP or WT memory type within a single REP MOVS or REP STOS instruction that will execute with fast strings enabled. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from on debug register, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  43   	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault. 	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  Debug Register May Contain Incorrect Information on a MOVSS or POPSS Instruction Followed by SYSRET  	  In IA-32e mode, if a MOVSS or POPSS instruction with a debug breakpoint is followed by the SYSRET instruction; incorrect information may exist in the Debug Status Register (DR6).  	 When debugging or when developing debuggers, this behavior should be noted. This erratum will not occur under normal usage of the MOVSS or POPSS instructions (i.e., following them with a MOV ESP instruction). 	 Do not attempt to put a breakpoint on MOVSS and POPSS instructions that are followed by a SYSRET. 	  For the steppings affected, see the Summary Tables of Changes. 
  EFLAGS Discrepancy on a Page Fault After a Multiprocessor TLB Shootdown  	  This erratum may occur when the processor executes one of the following read-modify-write arithmetic instructions and a page fault occurs during the store of the memory operand: ADD, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, ROL/ROR, SAL/SAR/SHL/SHR, SHLD, SHRD, SUB, XOR, and XADD. In this case, the EFLAGS value pushed onto the stack of the page fault handler may reflect the status of the register after the instruction would have completed execution rather than before it. The following conditions are required for the store to generate a page fault and call the operating system page fault handler:  44  •  The store address entry must be evicted from the DTLB by speculative loads from other instructions that hit the same way of the DTLB before the store has completed. DTLB eviction requires at least three-load operations that have linear address bits 15:12 equal to each other and address bits 31:16 different from each other in close physical proximity to the arithmetic operation.  •  The page table entry for the store address must have its permissions tightened during the very small window of time between the DTLB eviction and execution of the store. Examples of page permission tightening include from Present to Not Present or from Read/Write to Read Only, etc.  •  Another processor, without corresponding synchronization and TLB flush, must cause the permission change.  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 This scenario may only occur on a multiprocessor platform running an operating system that performs “lazy” TLB shootdowns. The memory image of the EFLAGS register on the page fault handler’s stack prematurely contains the final arithmetic flag values although the instruction has not yet completed. Intel has not identified any operating systems that inspect the arithmetic portion of the EFLAGS register during a page fault nor observed this erratum in laboratory testing of software applications. 	 No workaround is needed upon normal restart of the instruction, since this erratum is transparent to the faulting code and results in correct instruction behavior. Operating systems may ensure that no processor is currently accessing a page that is scheduled to have its page permissions tightened or have a page fault handler that ignores any incorrect state. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR, BTS, BTM May Report a Wrong Address when an Exception/Interrupt Occurs in 64-bit Mode  	  An exception/interrupt event should be transparent to the LBR (Last Branch Record), BTS (Branch Trace Store) and BTM (Branch Trace Message) mechanisms. However, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007FFFFFFFFFFF) in 64-bit mode, the LBR return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. Subsequent BTS and BTM operations which report the LBR will also be incorrect.  	 LBR, BTS and BTM may report incorrect information in the event of an exception/interrupt. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. 	 SMM software should not change the value of EFLAGS.VM in SMRAM. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  45  
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMLAUNCH/VMRESUME May Not Fail when VMCS is Programmed to Cause VM Exit to Return to a Different Mode  	  VMLAUNCH/VMRESUME instructions may not fail if the value of the “host address-space size” VM-exit control differs from the setting of IA32_EFER.LMA.  	 Programming the VMCS to allow the monitor to be in different modes prior to VMLAUNCH/VMRESUME and after VM-exit may result in undefined behavior 	 Software should ensure that "host address-space size" VM-exit control has the same value as IA32_EFER.LMA at the time of VMLAUNCH/VMRESUME. 	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	 Software should not generate misaligned stack frames for use with IRET. 	  46  For the steppings affected, see the Summary Tables of Changes.  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence  
  Performance Monitoring Event FP_ASSIST May Not be Accurate  	  Performance monitoring event FP_ASSIST (11H) may be inaccurate as assist events will be counted twice per actual assist in the following specific cases: •  FADD and FMUL instructions with a NaN(Not a Number) operand and a memory operand  •  FDIV instruction with zero operand value in memory  In addition, an assist event may be counted when DAZ (Denormals-Are-Zeros) and FTZ (Flush-To-Zero) flags are turned on even though no actual assist occurs.  	 The counter value for the performance monitoring event FP_ASSIST (11H) may be larger than expected. The size of the error is dependent on the number of occurrences of the above conditions while the event is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPL-Qualified BTS May Report Incorrect Branch-From Instruction Address  	  CPL (Current Privilege Level)-qualified BTS (Branch Trace Store) may report incorrect branch-from instruction address under the following conditions: •  Either BTS_OFF_OS[9] or BTS_OFF_USR[10] is selected in IA32_DEBUGCTLC MSR (1D9H)  •  Privilege-level transitions occur between CPL > 0 and CPL 0 or vice versa.  	 Due to this erratum, the From address reported by BTS may be incorrect for the described conditions. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS Does Not Always Differentiate Between CPL-Qualified Events  	  Performance monitoring counter configured to sample PEBS (Precise Event Based Sampling) events at a certain privilege level may count samples at the wrong privilege level.  	 Performance monitoring counter may be higher than expected for CPLqualified events. Do not use performance monitoring counters for precise event sampling when the precise event is dependent on the CPL value. 	 Do not use performance monitoring counters for precise event sampling when the precise event is dependent on the CPL value. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  47  
  PMI May Be Delayed to Next PEBS Event  	  After a PEBS (Precise Event-Based Sampling) event, the PEBS index is compared with the PEBS threshold, and the index is incremented with every event. If PEBS index is equal to the PEBS threshold, a PMI (Performance Monitoring Interrupt) should be issued. Due to this erratum, the PMI may be delayed by one PEBS event.  	 Debug Store Interrupt Service Routines may observe delay of PMI occurrence by one PEBS event. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  PEBS Buffer Overflow Status Will Not be Indicated Unless IA32_DEBUGCTL[12] is Set  	  IA32_PERF_GLOBAL_STATUS MSR (38EH) bit [62] when set, indicates that a PEBS (Precise Event-Based Sampling) overflow has occurred and a PMI (Performance Monitor Interrupt) has been sent. Due to this erratum, this bit will not be set unless IA32_DEBUGCTL MSR (1D9H) bit [12] (which stops all Performance Monitor Counters upon a PMI) is also set.  	 Unless IA32_DEBUGCTL[12] is set, IA32_PERF_GLOBAL_STATUS[62] will not indicate that a PMI was generated due to a PEBS Overflow. 	 It is possible for the software to set IA32_DEBUGCTL[12] to avoid this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  The BS Flag in DR6 May be Set for Non-Single-Step #DB Exception  	  DR6 BS (Single Step, bit 14) flag may be incorrectly set when the TF (Trap Flag, bit 8) of the EFLAGS Register is set, and a #DB (Debug Exception) occurs due to one of the following: •  DR7 GD (General Detect, bit 13) being bit set;  •  INT1 instruction;  •  Code breakpoint  	 The BS flag may be incorrectly set for non-single-step #DB exception. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  An Asynchronous MCE During a Far Transfer May Corrupt ESP  	  If an asynchronous machine check occurs during an interrupt, call through gate, FAR RET or IRET and in the presence of certain internal conditions, ESP may be corrupted.  48  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 If the MCE (Machine Check Exception) handler is called without a stack switch, then a triple fault will occur due to the corrupted stack pointer, resulting in a processor shutdown. If the MCE is called with a stack switch, e.g. when the CPL (Current Privilege Level) was changed or when going through an interrupt task gate, then the corrupted ESP will be saved on the stack or in the TSS (Task State Segment), and will not be used. 	 Use an interrupt task gate for the machine check handler. 	  For the steppings affected, see the Summary Tables of Changes. 
  In Single-Stepping on Branches Mode, the BS Bit in the PendingDebug-Exceptions Field of the Guest State Area will be Incorrectly Set by VM Exit on a MOV to CR8 Instruction  	  In a system supporting Intel® Virtualization Technology, the BS bit (bit 14 of the Pending-Debug-Exceptions field) in the guest state area will be incorrectly set when all of the following conditions occur: •  The processor is running in VMX non-root as a 64 bit mode guest;  •  The “CR8-load existing” VM-execution control is 0 and the “use TPR shadow” VMexecution is 1;  •  Both BTF (Single-Step On Branches, bit 1) of the IA32_DEBUGCTL MSR (1D9H) Register and the TF (Trap Flag, bit 8) of the RFLAGS Register are set;  •  “MOV CR8, reg” attempts to program a TPR (Task Priority Register) value that is below the TPR threshold and causes a VM exit.  	 A Virtual-Machine will sample the BS bit and will incorrectly inject a SingleStep trap to the guest. 	 A Virtual-Machine Monitor must manually disregard the BS bit in the Guest State Area in case of a VM exit due to a TPR value below the TPR threshold. 	  For the steppings affected, see the Summary Tables of Changes. 
  B0-B3 Bits in DR6 May Not be Properly Cleared After Code Breakpoint  	  B0-B3 bits (breakpoint conditions detect flags, bits [3:0]) in DR6 may not be properly cleared when the following sequence happens: 1) POP instruction to SS (Stack Segment) selector; 2) Next instruction is FP (Floating Point) that gets FP assist followed by code breakpoint.  	 B0-B3 bits in DR6 may not be properly cleared. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  BTM/BTS Branch-From Instruction Address May be Incorrect for Software Interrupts.  	  When BTM (Branch Trace Message) or BTS (Branch Trace Store) is enabled, a software interrupt may result in the overwriting of BTM/BTS branch-from  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  49   instruction address by the LBR (Last Branch Record) branch-from instruction address. 	 A BTM/BTS branch-from instruction address may get corrupted for software interrupts. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Last Branch Records (LBR) Updates May be Incorrect After a Task Switch  	  A Task-State Segment (TSS) task switch may incorrectly set the LBR_FROM value to the LBR_TO value.  	 The LBR_FROM will have the incorrect address of the Branch Instruction. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  REP Store Instructions in a Specific Situation may cause the Processor to Hang  	  During a series of REP (repeat) store instructions a store may try to dispatch to memory prior to the actual completion of the instruction. This behavior depends on the execution order of the instructions, the timing of a speculative jump and the timing of an uncacheable memory store. All types of REP store instructions are affected by this erratum.  	 When this erratum occurs, the processor may live lock and/or result in a system hang. 	 It is possible for BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Events for L1 and L2 Miss May Not be Accurate  	  Performance monitoring events 0CBh with an event mask value of 02h or 08h (MEM_LOAD_RETIRED.L1_LINE_MISS or MEM_LOAD_RETIRED.L2_LINE_MISS) may under count the cache miss events.  	 Performance monitoring events 0CBh with an event mask value of 02h or 08h may show a count which is lower than expected; the amount by which the count is lower is dependent on other conditions occurring on the same load that missed the cache. 	 None Identified. 	 50  For the steppings affected, see the Summary Tables of Changes. Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence  
  Store to WT Memory Data May be Seen in Wrong Order by Two Subsequent Loads  	  When data of Store to WT memory is used by two subsequent loads of one thread and another thread performs cacheable write to the same address the first load may get the data from external memory or L2 written by another core, while the second load will get the data straight from the WT Store.  	 Software that uses WB to WT memory aliasing may violate proper store ordering. 	 Do not use WB to WT aliasing. 	  For the steppings affected, see the Summary Tables of Changes. 
  A MOV Instruction from CR8 Register with 16 Bit Operand Size Will Leave Bits 63:16 of the Destination Register Unmodified  	  Moves to/from control registers are supposed to ignore REW.W and the 66H (operand size) prefix. In systems supporting Intel® Virtualization Technology, when the processor is operating in VMX non-root operation and “use TPR shadow” VM-execution control is set to 1, a MOV instruction from CR8 with a 16 bit operand size (REX.W =0 and 66H prefix) will only store 16 bits and leave bits 63:16 at the destination register unmodified, instead of storing zeros in them.  	 Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Non-Temporal Data Store May be Observed in Wrong Program Order  	  When non-temporal data is accessed by multiple read operations in one thread while another thread performs a cacheable write operation to the same address, the data stored may be observed in wrong program order (i.e. later load operations may read older data).  	 Software that uses non-temporal data without proper serialization before accessing the non-temporal data may observe data in wrong program order. 	 Software that conforms to the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, section “Buffering of Write Combining Memory Locations” will operate correctly. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitor SSE Retired Instructions May Return Incorrect Values  	  Performance Monitoring counter SIMD_INST_RETIRED (Event: C7H) is used to track retired SSE instructions. Due to this erratum, the processor may  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  51   inaccurately also count certain other types of instructions resulting in higher than expected values. 	 Performance Monitoring counter SIMD_INST_RETIRED may report count higher than expected. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Reports Architectural Performance Monitoring Version 2 is Supported, When Only Version 1 Capabilities are Available  	  CPUID leaf 0Ah reports the architectural performance monitoring version that is available in EAX[7:0]. Due to this erratum CPUID reports the supported version as 2 instead of 1.  	 Software will observe an incorrect version number in CPUID.0Ah.EAX [7:0] in comparison to which features are actually supported. 	 Software should use the recommended enumeration mechanism described in the Architectural Performance Monitoring section of the Intel® 64 and IA-32 Architectures Software Developer's Manual, Volume 3: System Programming Guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  Unaligned Accesses to Paging Structures May Cause the Processor to Hang  	  When an unaligned access is performed on paging structure entries, accessing a portion of two different entries simultaneously, the processor may live lock.  52  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 When this erratum occurs, the processor may live lock causing a system hang. 	 Do not perform unaligned accesses on paging structure entries. 	  For the steppings affected, see the Summary Tables of Changes. 
  Microcode Updates Performed During VMX Non-root Operation Could Result in Unexpected Behavior  	  When Intel® Virtualization Technology is enabled, microcode updates are allowed only during VMX root operations. Attempts to apply microcode updates while in VMX non-root operation should be silently ignored. Due to this erratum, the processor may allow microcode updates during VMX nonroot operations if not explicitly prevented by the host software.  	 Microcode updates performed in non-root operation may result in unexpected system behavior. 	 Host software should intercept and prevent loads to IA32_BIOS_UPDT_TRIG MSR (79H) during VMX non-root operations. There are two mechanism that can be used (1) Enabling MSR access protection in the VM-execution controls or (2) Enabling selective MSR protection of IA32_BIOS_UPDT_TRIG MSR. 	  For the steppings affected, see the Summary Tables of Changes. 
  INVLPG Operation for Large (2M/4M) Pages May be Incomplete under Certain Conditions  	  The INVLPG instruction may not completely invalidate Translation Look-aside Buffer (TLB) entries for large pages (2M/4M) when both of the following conditions exist: •  Address range of the page being invalidated spans several Memory Type Range Registers (MTRRs) with different memory types specified  •  INVLPG operation is preceded by a Page Assist Event (Page Fault (#PF) or an access that results in either A or D bits being set in a Page Table Entry (PTE))  	 Stale translations may remain valid in TLB after a PTE update resulting in unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 Software should ensure that the memory type specified in the MTRRs is the same for the entire address range of the large page. 	  For the steppings affected, see the Summary Tables of Changes. 
  Page Access Bit May be Set Prior to Signaling a Code Segment Limit Fault  	  If code segment limit is set close to the end of a code page, then due to this erratum the memory page Access bit (A bit) may be set for the subsequent page prior to general protection fault on code segment limit.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  53   	 When this erratum occurs, a non-accessed page which is present in memory and follows a page that contains the code segment limit may be tagged as accessed. 	 Erratum can be avoided by placing a guard page (non-present or nonexecutable page) as the last page of the segment or after the page that includes the code segment limit. 	  For the steppings affected, see the Summary Tables of Changes. 
  Update of Attribute Bits on Page Directories without Immediate TLB Shootdown May Cause Unexpected Processor Behavior  	  Updating a page directory entry (or page map level 4 table entry or page directory pointer table entry in IA-32e mode) by changing read/Write (R/W) or User/Supervisor (U/S) or Present (P) bits without immediate TLB shootdown (as described by the 4 step procedure in "Propagation of Page Table and Page Directory Entry Changes to Multiple Processors" In volume 3A of the Intel® 64 and IA-32 Architecture Software Developer's Manual), in conjunction with a complex sequence of internal processor micro-architectural events, may lead to unexpected processor behavior.  	 This erratum may lead to livelock, shutdown or other unexpected processor behavior. Intel has not observed this erratum with any commercially available software. 	 None Identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Invalid Instructions May Lead to Unexpected Behavior  	NA	 The processor may behave unexpectedly due to invalid instructions. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  EFLAGS, CR0, CR4 and the EXF4 Signal May be Incorrect after Shutdown  	  When the processor is going into shutdown due to an RSM inconsistency failure, EFLAGS, CR0 and CR4 may be incorrect. In addition the EXF4 signal may still be asserted. This may be observed if the processor is taken out of shutdown by NMI#.  	 A processor that has been taken out of shutdown may have an incorrect EFLAGS, CR0 and CR4. In addition the EXF4 signal may still be asserted. 54  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Counter MACRO_INSTS.DECODED May Not Count Some Decoded Instructions  	  MACRO_INSTS.DECODED performance monitoring counter (Event 0AAH, Umask 01H) counts the number of macro instructions decoded, but not necessarily retired. The event is undercounted when the decoded instructions are a complete loop iteration that is decoded in one cycle and the loop is streamed by the LSD (Loop Stream Detector), as described in the Optimizing the Front End section of the Intel® 64 and IA-32 Architectures Optimization Reference Manual.  	 The count value returned by the performance monitoring counter MACRO_INST.DECODED may be lower than expected. The degree of undercounting is dependent on the occurrence of loop iterations that are decoded in one cycle and whether the loop is streamed by the LSD while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  The Stack Size May be Incorrect as a Result of VIP/VIF Check on SYSEXIT and SYSRET  	  The stack size may be incorrect under the following scenario: •  The stack size was changed due to a SYSEXIT or SYSRET  •  PVI (Protected Mode Virtual Interrupts) mode was enabled (CR4.PVI == 1)  •  Both the VIF (Virtual Interrupt Flag) and VIP (Virtual Interrupt Pending) flags of the EFLAGS register are set  	 If this erratum occurs the stack size may be incorrect, consequently this may result in unpredictable system behavior. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event SIMD_UOP_TYPE_EXEC.MUL is Counted Incorrectly for PMULUDQ Instruction  	  Performance Monitoring Event SIMD_UOP_TYPE_EXEC.MUL (Event select 0B3H, Umask 01H) counts the number of SIMD packed multiply micro-ops executed. The count for PMULUDQ micro-ops may be lower than expected. No other instruction is affected.  	 The count value returned by the performance monitoring event SIMD_UOP_TYPE_EXEC.MUL may be lower than expected. The degree of Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  55   undercount depends on actual occurrences of PMULUDQ instructions, while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Storage of PEBS Record Delayed Following Execution of MOV SS or STI  	  When a performance monitoring counter is configured for PEBS (Precise Event Based Sampling), overflow of the counter results in storage of a PEBS record in the PEBS buffer. The information in the PEBS record represents the state of the next instruction to be executed following the counter overflow. Due to this erratum, if the counter overflow occurs after execution of either MOV SS or STI, storage of the PEBS record is delayed by one instruction.  	 When this erratum occurs, software may observe storage of the PEBS record being delayed by one instruction following execution of MOV SS or STI. The state information in the PEBS record will also reflect the one instruction delay. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Store Ordering May be Incorrect between WC and WP Memory Types  	  According to Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A "Methods of Caching Available", WP (Write Protected) stores should drain the WC (Write Combining) buffers in the same way as UC (Uncacheable) memory type stores do. Due to this erratum, WP stores may not drain the WC buffers.  	 Memory ordering may be violated between WC and WP stores. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Updating Code Page Directory Attributes without TLB Invalidation May Result in Improper Handling of Code #PF  	  Code #PF (Page Fault exception) is normally handled in lower priority order relative to both code #DB (Debug Exception) and code Segment Limit Violation #GP (General Protection Fault). Due to this erratum, code #PF may be handled incorrectly, if all of the following conditions are met:  56  •  A PDE (Page Directory Entry) is modified without invalidating the corresponding TLB (Translation Look-aside Buffer) entry  •  Code execution transitions to a different code page such that both o  The target linear address corresponds to the modified PDE  o  The PTE (Page Table Entry) for the target linear address has an A (Accessed) bit that is clear Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   •  One of the following simultaneous exception conditions is present following the code transition o  Code #DB and code #PF  o  Code Segment Limit Violation #GP and code #PF  	 Software may observe either incorrect processing of code #PF before code Segment Limit Violation #GP or processing of code #PF in lieu of code #DB. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event CPU_CLK_UNHALTED.REF May Not Count Clock Cycles According to the Processors Operating Frequency  	  Performance Counter MSR_PERF_FIXED_CTR2 (MSR 30BH) that counts CPU_CLK_UNHALTED.REF clocks, should count these clock cycles at a constant rate that is determined by the maximum resolved boot frequency, as programmed by BIOS. Due to this erratum, the rate is instead set by the maximum core-clock to bus-clock ratio of the processor, as indicated by hardware.  	 No functional impact as a result of this erratum. If the maximum resolved boot frequency as programmed by BIOS is different from the frequency implied by the maximum core-clock to bus-clock ratio of the processor as indicated by hardware, then the following effects may be observed: •  Performance Monitoring Event CPU_CLK_UNHALTED.REF will count at a rate different than the TSC (Time Stamp Counter)  •  When running a system with several processors that have different maximum core-clock to bus-clock ratios, CPU_CLK_UNHALTED.REF monitoring events at each processor will be counted at different rates and therefore will not be comparable.  	 Calculate the ratio of the rates at which the TSC and the CPU_CLK_UNHALTED.REF performance monitoring event count (this can be done by measuring simultaneously their counted value while executing code) and adjust the CPU_CLK_UNHALTED.REF event count to the maximum resolved boot frequency using this ratio. 	  For the steppings affected, see the Summary Tables of Changes. 
  (E)CX May Get Incorrectly Updated When Performing Fast String REP STOS With Large Data Structures  	  When performing Fast String REP STOS commands with data structures [(E)CX*Data Size] larger than the supported address size structure (64K for 16-bit address size and 4G for 32-bit address size) some addresses may be processed more than once. After an amount of data greater than or equal to the address size structure has been processed, external events (such as interrupts) will cause the (E)CX registers to be incremented by a value that  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  57   corresponds to 64K bytes for 16 bit address size and 4G bytes for 32 bit address size. 	 (E)CX may contain an incorrect count which may cause some of the STOS operations to re-execute. Intel has not observed this erratum with any commercially available software. 	 Do not use values in (E)CX that when multiplied by the data size give values larger than the address space size (64K for 16-bit address size and 4G for 32-bit address size). 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event BR_INST_RETIRED May Count CPUID Instructions as Branches  	  Performance monitoring event BR_INST_RETIRED (C4H) counts retired branch instructions. Due to this erratum, two of its sub-events mistakenly count for CPUID instructions as well. Those sub events are: BR_INST_RETIRED.PRED_NOT_TAKEN (Umask 01H) and BR_INST_RETIRED.ANY (Umask 00H).  	 The count value returned by the performance monitoring event BR_INST_RETIRED.PRED_NOT_TAKEN or BR_INST_RETIRED.ANY may be higher than expected. The extent of over counting depends on the occurrence of CPUID instructions, while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event MISALIGN_MEM_REF May Over Count  	  Performance monitoring event MISALIGN_MEM_REF (05H) is used to count the number of memory accesses that cross an 8-byte boundary and are blocked until retirement. Due to this erratum, the performance monitoring event MISALIGN_MEM_REF also counts other memory accesses.  	 The performance monitoring event MISALIGN_MEM_REF may over count. The extent of over counting depends on the number of memory accesses retiring while the counter is active. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
 Prevent Triggering of the Monitoring Hardware  	  The MONITOR instruction is used to arm the address monitoring hardware for	NA	NA	NA
 memory store operations to the monitored address range. Due to this erratum, REP STOS/MOVS fast string operations to the monitored address  58  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   range may prevent the actual triggering store to be propagated to the monitoring hardware.	NA	NA	NA	NA
 continue program execution if a REP STOS/MOVS targets the monitored address range. 	NA	NA	 Software can avoid this erratum by not using REP STOS/MOVS store operations within the monitored address range. 	  For the steppings affected, see the Summary Tables of Changes. 
  False Level One Data Cache Parity Machine-Check Exceptions May be Signaled  	  Executing an instruction stream containing invalid instructions/data may generate a false Level One Data Cache parity machine-check exception.  	 The false Level One Data Cache parity machine-check exception is reported as an uncorrected machine-check error. An uncorrected machine-check error is treated as a fatal exception by the operating system and may cause a shutdown and/or reboot. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Memory Access May Get a Wrong Memory Type Following a #GP due to WRMSR to an MTRR Mask  	  The TLB (Translation Lookaside Buffer) may indicate a wrong memory type on a memory access to a large page (2M/4M Byte) following the recovery from a #GP (General Protection Fault) due to a WRMSR to one of the IA32_MTRR_PHYSMASKn MSRs with reserved bits set.  	 When this erratum occurs, a memory access may get an incorrect memory type leading to unexpected system operation. As an example, an access to a memory mapped I/O device may be incorrectly marked as cacheable, become cached, and never make it to the I/O device. Intel has not observed this erratum with any commercially available software. 	 Software should not attempt to set reserved bits of IA32_MTRR_PHYSMASKn MSRs. 	  For the steppings affected, see the Summary Tables of Changes. 
  PMI While LBR Freeze Enabled May Result in Old/Out-of-date LBR Information  	  When Precise Event-Based Sampling (PEBS) is configured with Performance Monitoring Interrupt (PMI) on PEBS buffer overflow enabled and Last Branch Record (LBR) Freeze on PMI enabled by setting FREEZE_LBRS_ON_PMI flag (bit 11) to 1 in IA32_DEBUGCTL (MSR 1D9H), the LBR stack is frozen upon  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  59   the occurrence of a hardware PMI request. Due to this erratum, the LBR freeze may occur too soon (i.e. before the hardware PMI request). 	 Following a PMI occurrence, the PMI handler may observe old/out-of-date LBR information that does not describe the last few branches before the PEBS sample that triggered the PMI. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  VMCALL failure due to corrupt MSEG location may cause VM Exit to load the machine state incorrectly  	  In systems supporting Intel® Virtualization Technology, if a VMCALL failure occurs due to a corrupt Monitor Segment (MSEG), subsequent VM Exits may load machine state incorrectly.  	 Occurrence of this erratum may result in a VMX abort. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Overlap of an Intel® VT APIC Access Page in a Guest with the DS Save Area May Lead to Unpredictable Behavior  	  Logging of a branch record or a PEBS (precise-event-based-sampling) record to the DS (debug store) save area that overlaps with the APIC access page may lead to unpredictable behavior.  	 Guest software configured to log branch records or PEBS records cannot specify the DS (debug store) save area within the APIC-access page. Under any expected usage model this type of overlap is not expected to exist. One should be aware of the fact that the specified DS address is of linear form while the APIC access page is of a physical form. Any solution that wishes to avoid this condition will need to comprehend the linear-to-physical translation of the DS related address pointers with respect to the mapping of the physical APIC access page to avoid such an overlap. Under normal circumstances for correctly written software, such an overlap is not expected to exist. Intel has not observed this erratum with any commercially available software. 	 For a fully comprehensive workaround, the VMM should not allow the logging of branch or PEBS records while guest software is running if the "virtualize APIC accesses" VM-execution control is 1. 	  60  For the steppings affected, see the Summary Tables of Changes.  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence  
  VTPR Write Access During Event Delivery May Cause an APIC-Access VM Exit  	  VTPR write accesses should not cause APIC-access VM exits but instead should cause data to be written to the virtual-APIC page. Due to this erratum, a VTPR write access during event delivery may cause an APICaccess VM exit with no data being written to the virtual-APIC page.  	 VTPR accesses are accesses to offset 80H on the APIC-access page. VTPR write accesses can occur during event delivery when pushing data on the stack. Because event delivery performs multiple stack pushes, an event delivery that includes a VTPR write access will also include at least one other write to the APIC-access page. That other write will cause an APIC-access VM exit. Thus, even in the presence of this erratum, any event delivery that includes a VTPR write access will cause an APIC-access VM exit. The only difference with respect to correct behavior will be with regard to page offset saved in the exit qualification by the APIC-access VM exit. A VMM should be able to emulate the event delivery correctly even with the incorrect offset. 	 The VMM should emulate any event delivery that causes an APIC-access VM exit in the same way regardless of the offset saved in the exit qualification. 	  For the steppings affected, see the Summary Tables of Changes. 
  BIST Failure After Reset  	  The processor may show an erroneous BIST (built-in self test) result in bit [17] of EAX register when coming out of reset.  	 When this erratum occurs, an erroneous BIST failure will be reported in EAX bit [17]. This failure can be ignored since it is not accurate. 	 It is possible for BIOS to workaround this erratum by masking off bit [17] of the EAX register after coming out of reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  Performance Monitoring Event FP_MMX_TRANS_TO_MMX May Not Count Some Transitions  	  Performance Monitor Event FP_MMX_TRANS_TO_MMX (Event CCH, Umask 01H) counts transitions from x87 Floating Point (FP) to MMX™ instructions. Due to this erratum, if only a small number of MMX instructions (including EMMS) are executed immediately after the last FP instruction, a FP to MMX transition may not be counted.  	 The count value for Performance Monitoring Event FP_MMX_TRANS_TO_MMX may be lower than expected. The degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. Intel has not observed this erratum with any commercially available software. 	 None identified. Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  61   	  For the steppings affected, see the Summary Tables of Changes. 
  When One Core Executes SEXIT the Other Core's Last Branch Recording May be Incorrect  	  In processors supporting Intel® Trusted Execution Technology when one core is executing SEXIT and the other core is executing a control-transfer instruction, the FROM_IP field contained in the last branch information may be incorrect for the following: •  LBR (Last Branch Record) MSRs  •  BTM (Branch Traces Messages) on the bus  •  BTS (Branch Trace Store) records written by the debug store mechanism  	 Due to this erratum, last branch information may be incorrect after one core executes SEXIT. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A GETSEC[ENTERACCS] Instruction Executed Immediately after GETSEC[WAKEUP] Instruction May Result in a Processor Hang  	  In dual core processor systems supporting Intel® Trusted Execution Technology, a processor hang or unpredictable system behavior may occur if the ILP (Initiating Logical Processor) executes GETSEC[WAKEUP] and then executes GETSEC[ENTERACCS] without making sure that the RLP (Responding Logical Processor) has woken up in between these two instructions.  	 This may cause the processor to hang or execute code down an unintended path. 	 Software must be written to ensure that the RLP has woken-up in response to GETSEC[WAKEUP] instruction and then execute GETSEC[ENTERACCS] instruction. 	  For the steppings affected, see the Summary Tables of Changes. 
  Instruction Fetch May Cause a Livelock During Snoops of the L1 Data Cache  	  A livelock may be observed in rare conditions when instruction fetch causes multiple level one data cache snoops.  	 Due to this erratum, a livelock may occur. Intel has not observed this erratum with any commercially available software. 	 It is possible for BIOS to contain a workaround for this erratum.  62  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   	  For the steppings affected, see the Summary Tables of Changes. 
  Use of Memory Aliasing with Inconsistent Memory Type may Cause a System Hang or a Machine Check Exception  	  Software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (MCE). This would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. If the cacheable address finds its way into the instruction cache, and the non-cacheable address is fetched in the IFU, the processor may invalidate the non-cacheable address from the fetch unit. Any micro-architectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and lack of it will cause a system hang or an MCE.  	 This erratum has not been observed with commercially available software. 	 Although it is possible to have a single physical page mapped by two different linear addresses with different memory types, Intel has strongly discouraged this practice as it may lead to undefined results. Software that needs to implement memory aliasing should manage the memory type consistency. 	  For the steppings affected, see the Summary Tables of Changes. 
  A WB Store Following a REP STOS/MOVS or FXSAVE May Lead to Memory-Ordering Violations  	  Under certain conditions, as described in the Software Developers Manual section "Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors", the processor may perform REP MOVS or REP STOS as write combining stores (referred to as “fast strings”) for optimal performance. FXSAVE may also be internally implemented using write combining stores. Due to this erratum, stores of a WB (write back) memory type to a cache line previously written by a preceding fast string/FXSAVE instruction may be observed before string/FXSAVE stores.  	 A write-back store may be observed before a previous string or FXSAVE related store. Intel has not observed this erratum with any commercially available software. 	 Software desiring strict ordering of string/FXSAVE operations relative to subsequent write-back stores should add an MFENCE or SFENCE instruction between the string/FXSAVE operation and following store-order sensitive code such as that used for synchronization. 	  For the steppings affected, see the Summary Tables of Changes.  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  63  
  VM Exit with Exit Reason “TPR Below Threshold” Can Cause the Blocking by MOV/POP SS and Blocking by STI Bits to be Cleared in the Guest Interruptibility-State Field  	  As specified in Section, “VM Exits Induced by the TPR Shadow”, in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, a VM exit occurs immediately after any VM entry performed with the “use TPR shadow", "activate secondary controls”, and “virtualize APIC accesses” VMexecution controls all set to 1 and with the value of the TPR shadow (bits 7:4 in byte 80H of the virtual-APIC page) less than the TPR-threshold VMexecution control field. Due to this erratum, such a VM exit will clear bit 0 (blocking by STI) and bit 1 (blocking by MOV/POP SS) of the interruptibilitystate field of the guest-state area of the VMCS (bit 0 - blocking by STI and bit 1 - blocking by MOV/POP SS should be left unmodified).  	 Since the STI, MOV SS, and POP SS instructions cannot modify the TPR shadow, bits 1:0 of the interruptibility-state field will usually be zero before any VM entry meeting the preconditions of this erratum; behavior is correct in this case. However, if VMM software raises the value of the TPR-threshold VM-execution control field above that of the TPR shadow while either of those bits is 1, incorrect behavior may result. This may lead to VMM software prematurely injecting an interrupt into a guest. Intel has not observed this erratum with any commercially available software. 	 VMM software raising the value of the TPR-threshold VM-execution control field should compare it to the TPR shadow. If the threshold value is higher, software should not perform a VM entry; instead, it could perform the actions that it would normally take in response to a VM exit with exit reason “TPR below threshold”. 	  For the steppings affected, see the Summary Tables of Changes. 
  Using Memory Type Aliasing with Cacheable and WC Memory Types May Lead to Memory Ordering Violations  	  Memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory types. Memory type aliasing with a cacheable memory type and WC (write combining) may cause the processor to perform incorrect operations leading to memory ordering violations for WC operations.  	 Software that uses aliasing between cacheable and WC memory types may observe memory ordering errors within WC memory operations. Intel has not observed this erratum with any commercially available software. 	 None identified. Intel does not support the use of cacheable and WC memory type aliasing, and WC operations are defined as weakly ordered. 	  64  For the steppings affected, see the Summary Tables of Changes.  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence  
  VM Exit due to Virtual APIC-Access May Clear RF  	  RF (Resume Flag), bit 16 of the EFLAGS/RFLAGS register, is used to restart instruction execution without getting an instruction breakpoint on the instruction following a debug breakpoint exception. Due to this erratum, in a system supporting Intel® Virtualization Technology, when a VM Exit occurs due to Virtual APIC-Access (Advanced Programmable Interrupt ControllerAccess) the EFLAGS/RFLAGS saved in the VMCS (Virtual-Machine Control Structure) may contain an RF value of 0.  	 When this erratum occurs, following a VM Exit due to a Virtual APIC-access, the processor may unintentionally break on the subsequent instruction after VM entry. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  Fixed Function Performance Counters MSR_PERF_FIXED_CTR1 (30AH) and MSR_PERF_FIXED_CTR2 (30BH) are Not Cleared When the Processor is Reset  	  The Fixed Function Performance Counters that count the number of core cycles and reference cycles when the core is not in a halt state are not cleared when the processor is reset.  	 The MSR_PERF_FIXED_CTR1 and MSR_PERF_FIXED_CTR2 counters may contain unexpected values after reset. 	 BIOS can workaround this erratum by clearing the counters at processor initialization time. 	  For the steppings affected, see the Summary Tables of Changes. 
  VTPR Access May Lead to System Hang  	  The logical processor may hang if an instruction performs a VTPR access and the next instruction to be executed is located on a different code page.  	 Software running VMX non-root operation may cause a logical processor to hang if the virtual-machine monitor (VMM) sets both the "use TPR shadow" and "virtualize APIC accesses" VM-execution controls. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC1_STATUS MSR Bit[60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this  Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  65   erratum, IA32_MC1_STATUS MSR bit[60] instead reports the current value of the IA32_MC1_CTL MSR enable bit. 	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  RSM Instruction Execution under Certain Conditions May Cause Processor Hang or Unexpected Instruction Execution Results  	  RSM instruction execution, under certain conditions triggered by a complex sequence of internal processor micro-architectural events, may lead to processor hang, or unexpected instruction execution results.  	 In the above sequence, the processor may live lock or hang, or RSM instruction may restart the interrupted processor context through a nondeterministic EIP offset in the code segment, resulting in unexpected instruction execution, unexpected exceptions or system hang. Intel has not observed this erratum with any commercially available software. 	 It is possible for the BIOS to contain a workaround for this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  NMIs May Not Be Blocked by a VM-Entry Failure  	  The Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2 specifies that, following a VM-entry failure during or after loading guest state, “the state of blocking by NMI is what it was before VM entry.” If non-maskable interrupts (NMIs) are blocked and the “virtual NMIs” VM-execution control set to 1, this erratum may result in NMIs not being blocked after a VM-entry failure during or after loading guest state.  	 VM-entry failures that cause NMIs to become unblocked may cause the processor to deliver an NMI to software that is not prepared for it. 	 VMM software should configure the virtual-machine control structure (VMCS) so that VM-entry failures do not occur. 	  For the steppings affected, see the Summary Tables of Changes. 
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. However due to this erratum, only  66  Intel  ®  Intel® Core™2 Extreme Processor X6800 and Core™2 Duo Desktop Processor E6000 and E4000 Sequence   Contributory Exceptions and Page Faults will cause a triple fault shutdown, whereas a benign exception may not. 	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None identified. 	  For the steppings affected, see the Summary Tables of Changes. 
  A VM Exit Due to a Fault While Delivering a Software Interrupt May Save Incorrect Data into the VMCS  	  If a fault occurs during delivery of a software interrupt (INTn) in virtual-8086 mode when virtual mode extensions are in effect and that fault causes a VM exit, incorrect data may be saved into the VMCS. Specifically, information about the software interrupt may not be reported in the IDT-vectoring information field. In addition, the interruptibility-state field may indicate blocking by STI or by MOV SS if such blocking were in effect before execution of the INTn instruction or before execution of the VM-entry instruction that injected the software interrupt.  	 In general, VMM software that follows the guidelines given in the section “Handling VM Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide should not be affected. If the erratum improperly causes indication of blocking by STI or by MOV SS, the ability of a VMM to inject an interrupt may be delayed by one instruction. 	 VMM software should follow the guidelines given in the section “Handling VM Exits Due to Exceptions” of Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide. 	  For the steppings affected, see the Summary Tables of Changes. 
  A VM Exit Occuring in IA-32e Mode May Not Produce a VMX Abort When Expected  	  If a VM exit occurs while the processor is in IA-32e mode and the “host address-space size” VM-exit control is 0, a VMX abort should occur. Due to this erratum, the expected VMX aborts may not occur and instead the VM Exit will occur normally. The conditions required to observe this erratum are a VM entry that returns from SMM with the “IA-32e guest” VM-entry control set to 1 in the SMM VMCS and the “host address-space size” VM-exit control cleared to 0 in the executive VMCS.  	 A VM Exit will occur when a VMX Abort was expected. 	 An SMM VMM should always set the “IA-32e guest” VM-entry control in the SMM VMCS to be the value that was in the LMA bit (IA32_EFER.LMA.LMA[bit 10]) in the IA32_EFER MSR (C0000080H) at the time of the last SMM VM Intel® Core™2 Extreme Processor X6800 and Intel® Core™2 Duo Desktop Processor E6000 and E4000 Sequence  67   exit. If this guideline is followed, that value will be 1 only if the “host address-space size” VM-exit control is 1 in the executive VMCS. 	  For the steppings affected, see the Summary Tables of Changes. 
  A 64-bit Register IP-relative Instruction May Return Unexpected Results  	  Under an unlikely and complex sequence of conditions in 64-bit mode, a register IP-relative instruction result may be incorrect.  	 A register IP-relative instruction result may be incorrect and could cause software to read from or write to an incorrect memory location. This may result in an unexpected page fault or unpredictable system behavior. 	 It is possible for the BIOS to contain a workaround for this erratum. 	NA
  A Write to an APIC Register Sometimes May Appear to Have Not Occurred  	  With respect to the retirement of instructions, stores to the uncacheable memory based APIC register space are handled in a non-synchronized way. For example if an instruction that masks the interrupt flag, e.g. CLI, is executed soon after an uncacheable write to the Task Priority Register (TPR) that lowers the APIC priority, the interrupt masking operation may take effect before the actual priority has been lowered. This may cause interrupts whose priority is lower than the initial TPR, but higher than the final TPR, to not be serviced until the interrupt enabled flag is finally set, i.e. by STI instruction. Interrupts will remain pending and are not lost.  	 In this example the processor may allow interrupts to be accepted but may delay their service. 	 This non-synchronization can be avoided by issuing an APIC register read after the APIC register write. This will force the store to the APIC register before any subsequent instructions are executed. No commercial operating system is known to be impacted by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  An xTPR Update Transaction Cycle, if Enabled, May be Issued to the FSB after the Processor has Issued a Stop-Grant Special Cycle  	  According to the FSB (Front Side Bus) protocol specification, no FSB cycles should be issued by the processor once a Stop-Grant special cycle has been issued to the bus. If xTPR update transactions are enabled by clearing the IA32_MISC_ENABLES[bit 23] at the time of Stop-Clock assertion, an xTPR update transaction cycle may be issued to the FSB after the processor has issued a Stop Grant Acknowledge transaction.  	 When this erratum occurs in systems using C-states C2 (Stop-Grant State) and higher the result could be a system hang. 	 BIOS must leave the xTPR update transactions disabled (default). 	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Report a #TS Instead of a #GP Fault  	  A jump to a busy TSS (Task-State Segment) may cause a #TS (invalid TSS exception) instead of a #GP fault (general protection exception).  	 Operation systems that access a busy TSS may get invalid TSS fault instead of a #GP fault. Intel has not observed this erratum with any commercially available software. 	 None 	  For the steppings affected, see the Summary Tables of Changes.   15  
  Writing the Local Vector Table (LVT) when an Interrupt is Pending May Cause an Unexpected Interrupt  	  If a local interrupt is pending when the LVT entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.  	 An interrupt may immediately be generated with the new vector when a LVT entry is written, even if the new LVT entry has the mask bit set. If there is no Interrupt Service Routine (ISR) set up for that vector the system will GP fault. If the ISR does not do an End of Interrupt (EOI) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority. 	 Any vector programmed into an LVT entry must have an ISR associated with it, even if that vector was programmed as masked. This ISR routine must do an EOI to clear any unexpected interrupts that may occur. The ISR associated with the spurious vector does not generate an EOI, therefore the spurious vector should not be used when writing the LVT. 	  For the steppings affected, see the Summary Tables of Changes. 
  MOV To/From Debug Registers Causes Debug Exception  	  When in V86 mode, if a MOV instruction is executed to/from a debug registers, a general-protection exception (#GP) should be generated. However, in the case when the general detect enable flag (GD) bit is set, the observed behavior is that a debug exception (#DB) is generated instead.  	 With debug-register protection enabled (i.e., the GD bit set), when attempting to execute a MOV on debug registers in V86 mode, a debug exception will be generated instead of the expected general-protection fault. 	 In general, operating systems do not set the GD bit when they are in V86 mode. The GD bit is generally set and used by debuggers. The debug exception handler should check that the exception did not occur in V86 mode before continuing. If the exception did occur in V86 mode, the exception may be directed to the general-protection exception handler. 	  16  For the steppings affected, see the Summary Tables of Changes.   
  Using 2M/4M Pages When A20M# Is Asserted May Result in Incorrect Address Translations  	  An external A20M# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. However, if all of the following conditions are met, address bit 20 may not be masked. • paging is enabled • a linear address has bit 20 set • the address references a large page • A20M# is enabled  	 When A20M# is enabled and an address references a large page the resulting translated physical address may be incorrect. This erratum has not been observed with any commercially available operating system. 	 Operating systems should not allow A20M# to be enabled if the masking of address bit 20 could be applied to an address that references a large page. A20M# is normally only used with the first megabyte of memory. 	  For the steppings affected, see the Summary Tables of Changes. 
  Values for LBR/BTS/BTM will be Incorrect after an Exit from SMM  	  After a return from SMM (System Management Mode), the CPU will incorrectly update the LBR (Last Branch Record) and the BTS (Branch Trace Store), hence rendering their data invalid. The corresponding data if sent out as a BTM on the system bus will also be incorrect. Note: This issue would only occur when one of the 3 above mentioned debug support facilities are used.  	 The value of the LBR, BTS, and BTM immediately after an RSM operation should not be used. 	 None 	  For the steppings affected, see the Summary Tables of Changes.   17  
  Incorrect Address Computed For Last Byte of FXSAVE/FXRSTOR Image Leads to Partial Memory Update  	  A partial memory state save of the 512-byte FXSAVE image or a partial memory state restore of the FXRSTOR image may occur if a memory address exceeds the 64KB limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4GB limit while the processor is operating in 32-bit mode.  	 FXSAVE/FXRSTOR will incur a #GP fault due to the memory limit violation as expected but the memory state may be only partially saved or restored. 	 Software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits. 	  For the steppings affected, see the Summary Tables of Changes. 
  A Thermal Interrupt is Not Generated when the Current Temperature is Invalid  	  When the DTS (Digital Thermal Sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (IA32_THERM_STATUS MSR (019Ch) bits [9,7]). Due to this erratum, if the DTS reaches an invalid temperature (as indicated IA32_THERM_STATUS MSR bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.  	 When the temperature reaches an invalid temperature the CPU does not generate a Thermal interrupt even if a programmed threshold is crossed. 	 None 	  For the steppings affected, see the Summary Tables of Changes. 
  Programming the Digital Thermal Sensor (DTS) Threshold May Cause Unexpected Thermal Interrupts  	  Software can enable DTS thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. When programming DTS value, the previous DTS threshold may be crossed. This will generate an unexpected thermal interrupt.  	 Software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold. 	 In the ACPI/OS implement a workaround by temporarily disabling the DTS threshold interrupt before updating the DTS threshold value. 	  18  For the steppings affected, see the Summary Tables of Changes.   
  Returning to Real Mode from SMM with EFLAGS.VM Set May Result in Unpredictable System Behavior  	  Returning back from SMM mode into real mode while EFLAGS.VM is set in SMRAM may result in unpredictable system behavior.  	 If SMM software changes the values of the EFLAGS.VM in SMRAM, it may result in unpredictable system behavior. Intel has not observed this behavior in commercially available software. SMM software should not change the value of EFLAGS.VM in SMRAM. Status For the steppings affected, see the Summary Tables of Changes. 	NA	NA
  Fault on ENTER Instruction May Result in Unexpected Values on Stack Frame  	  The ENTER instruction is used to create a procedure stack frame. Due to this erratum, if execution of the ENTER instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).  	 Data in the created stack frame may be altered following a fault on the ENTER instruction. Please refer to "Procedure Calls For Block-Structured Languages" in IA-32 Intel® Architecture Software Developer’s Manual, Vol. 1, Basic Architecture, for information on the usage of the ENTER instructions. This erratum is not expected to occur in ring 3. Faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. Intel has not observed this erratum on any commercially available software. 	  None  	  For the steppings affected, see the Summary Tables of Changes. 
  With TF (Trap Flag) Asserted, FP Instruction That Triggers an Unmasked FP Exception May Take Single Step Trap before Retirement of Instruction  	  If an FP instruction generates an unmasked exception with the EFLAGS.TF=1, it is possible for external events to occur, including a transition to a lower power state. When resuming from the lower power state, it may be possible to take the single step trap before the execution of the original FP instruction completes.  	 A Single Step trap will be taken when not expected. 	 	  None  For the steppings affected, see the Summary Tables of Changes.   19  
  An Enabled Debug Breakpoint or Single Step Trap May Be Taken after MOV SS/POP SS Instruction if it is Followed by an Instruction That Signals a Floating Point Exception  	  A MOV SS/POP SS instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. This is intended to allow the sequential execution of MOV SS/POP SS and MOV [r/e]SP, [r/e]BP instructions without having an invalid stack during interrupt handling. However, an enabled debug breakpoint or single step trap may be taken after MOV SS/POP SS if this instruction is followed by an instruction that signals a floating point exception rather than a MOV [r/e]SP, [r/e]BP instruction. This results in a debug exception being signaled on an unexpected instruction boundary since the MOV SS/POP SS and the following instruction should be executed atomically.  	 This can result in incorrect signaling of a debug exception and possibly a mismatched Stack Segment and Stack Pointer. If MOV SS/POP SS is not followed by a MOV [r/e]SP, [r/e]BP, there may be a mismatched Stack Segment and Stack Pointer on any exception. Intel has not observed this erratum with any commercially available software, or system. 	 As recommended in the IA32 Intel® Architecture Software Developer’s Manual, the use of MOV SS/POP SS in conjunction with MOV [r/e]SP, [r/e]BP will avoid the failure since the MOV [r/e]SP, [r/e]BP will not generate a floating point exception. Developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum. 	  For the steppings affected, see the Summary Tables of Changes. 
  Code Segment Limit/Canonical Faults on RSM May be Serviced before Higher Priority Interrupts/Exceptions and May Push the Wrong Address Onto the Stack  	  Normally, when the processor encounters a Segment Limit or Canonical Fault due to code execution, a #GP (General Protection Exception) fault is generated after all higher priority Interrupts and exceptions are serviced. Due to this erratum, if RSM (Resume from System Management Mode) returns to execution flow that results in a Code Segment Limit or Canonical Fault, the #GP fault may be serviced before a higher priority Interrupt or Exception (e.g. NMI (Non-Maskable Interrupt), Debug break(#DB), Machine Check (#MC), etc.). If the RSM attempts to return to a noncanonical address, the address pushed onto the stack for this #GP fault may not match the non-canonical address that caused the fault.  	 Operating systems may observe a #GP fault being serviced before higher priority Interrupts and Exceptions. Intel has not observed this erratum on any commercially available software. 	 None 	  20  For the steppings affected, see the Summary Tables of Changes.   
  BTS(Branch Trace Store) and PEBS(Precise Event Based Sampling) May Update Memory outside the BTS/PEBS Buffer  	  If the BTS/PEBS buffer is defined such that: • The difference between BTS/PEBS buffer base and BTS/PEBS absolute maximum is not an integer multiple of the corresponding record sizes • BTS/PEBS absolute maximum is less than a record size from the end of the virtual address space • The record that would cross BTS/PEBS absolute maximum will also continue past the end of the virtual address space  A BTS/PEBS record can be written that will wrap at the 4G boundary (IA32) or 2^64 boundary (EM64T mode), and write memory outside of the BTS/PEBS buffer. 	 Software that uses BTS/PEBS near the 4G boundary (IA32) or 2^64 boundary (EM64T mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the BTS/PEBS buffer. 	 Define BTS/PEBS buffer such that BTS/PEBS absolute maximum minus BTS/PEBS buffer base is integer multiple of the corresponding record sizes as recommended in the IA-32 Intel® Architecture Software Developer’s Manual, Volume 3. 	  For the steppings affected, see the Summary Tables of Changes. 
  Single Step Interrupts with Floating Point Exception Pending May Be Mishandled  	  In certain circumstances, when a floating point exception (#MF) is pending during single-step execution, processing of the single-step debug exception (#DB) may be mishandled.  	 When this erratum occurs, #DB will be incorrectly handled as follows: • #DB is signaled before the pending higher priority #MF (Interrupt 16) • #DB is generated twice on the same instruction 	 None 	  For the steppings affected, see the Summary Tables of Changes.   21  
  Unsynchronized Cross-Modifying Code Operations Can Cause Unexpected Instruction Execution Results  	  The act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (XMC). XMC that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized XMC. Software using unsynchronized XMC to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.  	 In this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the Intel® 64 and IA32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, including a General Protection Fault (#GP) or other unexpected behaviors. 	 In order to avoid this erratum, programmers should use the XMC synchronization algorithm as detailed in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Section: Handling Self- and CrossModifying Code. 	  For the steppings affected, see the Summary Tables of Changes. 
  IO_SMI Indication in SMRAM State Save Area May be Set Incorrectly  	  The IO_SMI bit in SMRAM’s location 7FA4H is set to "1" by the CPU to indicate a System Management Interrupt (SMI) occurred as the result of executing an instruction that reads from an I/O port. Due to this erratum, the IO_SMI bit may be incorrectly set by: •  A SMI that is pending while a lower priority event is executing  • A REP I/O read • A I/O read that redirects to MWAIT 	 SMM handlers may get false IO_SMI indication. 	 The SMM handler has to evaluate the saved context to determine if the SMI was triggered by an instruction that read from an I/O port. The SMM handler must not restart an I/O instruction if the platform has not been configured to generate a synchronous SMI for the recorded I/O port address. 	  22  For the steppings affected, see the Summary Tables of Changes.   
  Writes to IA32_DEBUGCTL MSR May Fail when FREEZE_LBRS_ON_PMI is Set  	  When the FREEZE_LBRS_ON_PMI, IA32_DEBUGCTL MSR (1D9H) bit [11], is set, future writes to IA32_DEBUGCTL MSR may not occur in certain rare corner cases. Writes to this register by software or during certain processor operations are affected.  	 Under certain circumstances, the IA32_DEBUGCTL MSR value may not be updated properly and will retain the old value. Intel has not observed this erratum with any commercially available software. 	 Do not set the FREEZE_LBRS_ON_PMI bit of IA32_DEBUGCTL MSR. 	  For the steppings affected, see the Summary Tables of Changes. 
  Address Reported by Machine-Check Architecture (MCA) on L2 Cache Errors May be Incorrect  	  When an L2 Cache error occurs (Error code 0x010A or 0x110A reported in IA32_MCi_STATUS MSR bits [15:0]), the address is logged in the MCA address register (IA32_MCi_ADDR MSR). Under some scenarios, the address reported may be incorrect.  	 Software should not rely on the value reported in IA32_MCi_ADDR MSR for L2 Cache errors. 	 None 	  For the steppings affected, see the Summary Tables of Changes. 
  Pending x87 FPU Exceptions (#MF) Following STI May Be Serviced Before Higher Priority Interrupts  	  Interrupts that are pending prior to the execution of the STI (Set Interrupt Flag) instruction are normally serviced immediately after the instruction following the STI. An exception to this is if the following instruction triggers a #MF. In this situation, the interrupt should be serviced before the #MF. Because of this erratum, if following STI, an instruction that triggers a #MF is executed while STPCLK#, Enhanced Intel SpeedStep Technology transitions or Thermal Monitor events occur, the pending #MF may be serviced before higher priority interrupts.  	 Software may observe #MF being serviced before higher priority interrupts. 	 None 	  For the steppings affected, see the Summary Tables of Changes.   23  
  Benign Exception after a Double Fault May Not Cause a Triple Fault Shutdown  	  According to the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, “Exception and Interrupt Reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. Due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. However Contributory Exceptions and Page Faults will continue to cause a triple fault shutdown.  	 If a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. Intel has not observed this erratum with any commercially available software. 	 None 	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC1_STATUS MSR Bit [60] Does Not Reflect Machine Check Error Reporting Enable Correctly  	  IA32_MC1_STATUS MSR (405H) bit[60] (EN- Error Enabled) is supposed to indicate whether the enable bit in the IA32_MC1_CTL MSR (404H) was set at the time of the last update to the IA32_MC1_STATUS MSR. Due to this erratum, IA32_MC1_STATUS MSR bit [60] instead reports the current value of the IA32_MC1_CTL MSR enable bit.  	 IA32_MC1_STATUS MSR bit [60] may not reflect the correct state of the enable bit in the IA32_MC1_CTL MSR at the time of the last update. 	 None 	  For the steppings affected, see the Summary Tables of Changes. 
  Split Locked Stores or Locked Stores Through Certain Segments May not Trigger the Monitoring Hardware  	  Logical processors normally resume program execution following the MWAIT, when another logical processor performs a write access to a WB cacheable address within the address range used to perform the MONITOR operation. Due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or O/S timer tick following a locked store within the monitored address range that either spans across cache lines or uses a segment register whose segment base is noncacheline aligned.  	 The logical processor that executed the MWAIT instruction may not resume execution until the next targeted interrupt event or O/S timer tick in the case where the monitored address is written by a locked store which is either split across cache lines or through a segment whose segment base bits 5 to 0 are non-zero. 	 Avoid accessing the monitored address range using either locked stores that split cache lines or locked stores that use a segment with a non-cacheline aligned segment base. It is possible for the BIOS to contain a workaround for this erratum 	  24  For the steppings affected, see the Summary Tables of Changes.   
  When BIST is Enabled, Warm Reset Incorrectly Clears IA32_FEATURE_CONTROL MSR and the Last Exception Record MSRs  	  IA32_FEATURE_CONTROL MSR (3AH), MSR_LER_FROM_LIP MSR (1DDH), and MSR_LER_TO_LIP MSR (1DEH) are cleared during warm reset when BIST (BuiltIn Self Test) is enabled. These MSRs should only be cleared on a power-up reset and not on a warm reset. A warm reset is different from a power-up reset in that PWRGOOD remains active throughout the assertion of RESET#.  	 Due to this erratum, any warm reset will clear IA32_FEATURE_CONTROL MSR, MSR_LER_FROM_LIP MSR, and MSR_LER_TO_LIP MSR content when BIST is enabled. 	 BIOS or other firmware software must save IA32_FEATURE_CONTROL MSR, MSR_LER_FROM_LIP MSR, and MSR_LER_TO_LIP MSR information before warm reset and restore and reprogram the MSRs after the warm reset. 	  For the steppings affected, see the Summary Tables of Changes. 
  LBR/BTM/BTS Information Immediately After a Transition From Legacy/Compatibility Mode to 64-bit Mode May be Incorrect  	  If a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any FROM address recorded by LBR (Last Branch Record), BTM (Branch Trace Message) or BTS (Branch Trace Store) on that second event may incorrectly report the upper 32-bits as zero.  	 Due to this erratum, bits 63:32 of the ‘FROM’ value for LBR/BTM/BTS may be improperly zeroed after a transition to 64 bite mode when the RIP (Instruction Pointer Register) is greater than 4 Gigabyte. 	 None identified. This erratum may be detected by a ‘FROM’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘TO’ address recorded. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction Returns Incorrect Brand String  	  When a CPUID instruction is executed with EAX = 80000002H, 80000003H and 80000004H on an Intel® Atom™ processor, the return value contains the brand string Intel(R) Core(TM) CPU when it should have Intel(R) Atom(TM) CPU.  	 When this erratum occurs, the processor will report the incorrect brand string. 	 	  It is possible for the BIOS to contain a workaround for this erratum.  For the steppings affected, see the Summary Tables of Changes.   25  
  A Logical Processor May Incorrectly Clear Thermal Status Log Indicator During Intel Deep Power Down Technology State Transition  	  When a logical processor enters the Intel Deep Power Down Technology State (e.g. as requested by MWAIT or I/O redirection), it may incorrectly clear the sticky Thermal Status Log flag (bit 1) in IA32_THERM_STATUS MSR (19CH). This erratum will not occur when Hyper-Threading (HT) is disabled.  	 When Hyper-Threading is enabled, a logical processor may incorrectly indicate that the thermal sensor has not tripped since last power-up. 	  It is possible for the BIOS to contain a workaround for this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  The Instruction Cache Does Not Respond to Snoops When All Logical Processors on a Core Are in an Inactive State  	  When all logical processors on a core enter an inactive state (e.g. MWAIT or HLT), the processor may incorrectly stop flushing lines in its instruction cache in response to snoops. This may cause the processor to not detect that memory has been modified and to execute the old instructions after waking up instead of the new contents of memory.  	 The processor may execute incorrect instructions after waking up from an inactive state. 	  It is possible for the BIOS to contain a workaround for this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  LINT0 Assertion and Deassertion During an Inactive State May Cause Unexpected Operation When APIC is Disabled  	  An interrupt delivered via LINT0 pins when the APIC is hardware disabled (IA32_APIC_BASE MSR (1BH) bit [11] is cleared) will usually keep the pin asserted until after the interrupt is acknowledged. However, if LINT0 is asserted and then deasserted before the interrupt is acknowledged and both of the following are true; •  the APIC is hardware disabled (IA32_APIC_BASE MSR bit [11] is clear) and  •  the processor is in an inactive state that was requested by MWAIT, I/O redirection, VM-entry or RSM, then the processor may operate incorrectly.  	 Due to this erratum, the processor may run unexpected code and/or generate an unexpected exception. Intel has not observed this erratum with any commercially available software. 	 If LINT0 is used, it is recommended to either leave the APIC enabled (IA32_APIC_BASE MSR bit [11] set to 1) or do not use MWAIT, I/O redirection, VMentry or RSM to enter an inactive state. 	  26  For the steppings affected, see the Summary Tables of Changes.   
  Processor May Not Wake Up from an Inactive State When an Enhanced Intel® SpeedStep Technology Transition is Pending  	  Due to this erratum, the processor may hang in rare scenarios when it is in an inactive state and there is an Enhanced Intel® SpeedStep Technology transition pending.  	 The processor may hang and be unable to resume execution. A processor reset will be needed to restart processor execution. Intel has not observed this erratum with any commercially available software. 	  It is possible for the BIOS to contain a workaround to this erratum.  	  For the steppings affected, see the Summary Tables of Changes. 
  IRET under Certain Conditions May Cause an Unexpected Alignment Check Exception  	  In IA-32e mode, it is possible to get an Alignment Check Exception (#AC) on the IRET instruction even though alignment checks were disabled at the start of the IRET. This can only occur if the IRET instruction is returning from CPL3 code to CPL3 code. IRETs from CPL0/1/2 are not affected. This erratum can occur if the EFLAGS value on the stack has the AC flag set, and the interrupt handler's stack is misaligned. In IA-32e mode, RSP is aligned to a 16-byte boundary before pushing the stack frame.  	 In IA-32e mode, under the conditions given above, an IRET can get a #AC even if alignment checks are disabled at the start of the IRET. This erratum can only be observed with a software generated stack frame. 	  Software should not generate misaligned stack frames for use with IRET.  	  For the steppings affected, see the Summary Tables of Changes. 
  Thermal Interrupts are Dropped During and While Exiting Intel® Deep Power-Down State  	  Thermal interrupts are ignored while the processor is in Intel Deep Power-Down State as well as during a small window of time while exiting from Intel Deep Power-Down State. During this window, if the PROCHOT signal is driven or the internal value of the sensor reaches the programmed thermal trip point, then the associated thermal interrupt may be lost.  	 In the event of a thermal event while a processor is waking up from Intel Deep PowerDown State, the processor will initiate an appropriate throttle response. However, the associated thermal interrupt generated may be lost. 	 	  None identified.  For the steppings affected, see the Summary Tables of Changes.   27  
  Corruption of CS Segment Register During RSM While Transitioning From Real Mode to Protected Mode  	  During the transition from real mode to protected mode, if an SMI (System Management Interrupt) occurs between the MOV to CR0 that sets PE (Protection Enable, bit 0) and the first far JMP, the subsequent RSM (Resume from System Management Mode) may cause the lower two bits of CS segment register to be corrupted.  	 The corruption of the bottom two bits of the CS segment register will have no impact unless software explicitly examines the CS segment register between enabling protected mode and the first far JMP. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1, in the section titled "Switching to Protected Mode" recommends the far JMP immediately follows the write to CR0 to enable protected mode. Intel has not observed this erratum with any commercially available software. 	  None identified.  	  For the steppings affected, see the Summary Tables of Changes. 
  Processor May Contain Incorrect Data and Hang Upon a Snoop When Combined with Specific Other Internal Conditions  	  In a specific corner case a snoop to a processor may cause incorrect data that will be followed by a hang.  	 Due to this erratum, the processor may contain incorrect data and hang in this specific circumstance. 	  It is possible for the BIOS to contain a workaround for this erratum  	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Instruction Returns Incorrect Value For Leaf 0xA  	  When a CPUID instruction is executed with EAX = 0AH, the value returned in EDX is 0x2501, which reports support for only one fixed-function performance counter and also has an undefined bit [bit 13] set . The value of EDX should be 0x0503, reflecting that three fixed-function performance counters are supported.  	 When this erratum occurs, the processor will report an incorrect value in EDX. 	 	  28  None  For the steppings affected, see the Summary Tables of Changes.   
  GP and Fixed Performance Monitoring Counters With AnyThread Bit Set May Not Accurately Count Only OS or Only USR Events  	  A fixed or GP (general purpose) performance counter with the AnyThread bit (IA32_FIXED_CTR_CTRL MSR (38DH) bit [2] for IA32_FIXED_CTR0, bit [6] for IA32_FIXED_CTR1, bit [10] for IA32_FIXED_CTR2; IA32_PERFEVTSEL0 MSR (186H)/ IA32_PERFEVTSEL1 MSR (187H) bit [21]) set may not count correctly when counting only OS (ring 0) events or only USR (ring >0) events. The counters will count correctly if they are counting both OS and USR events or if the AnyThread bit is clear.  	 A performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. This erratum will only occur on processors supporting multiple logical processors per core. 	  None  	  For the steppings affected, see the Summary Tables of Changes. 
  PMI Request is Not Generated on a Counter Overflow if Its OVF Bit is Already Set in IA32_PERF_GLOBAL_STATUS  	  If a performance counter overflows and software does not clear the corresponding OVF (overflow) bit in IA32_PERF_GLOBAL_STATUS MSR (38Eh) then future overflows of that counter will not trigger PMI (Performance Monitoring Interrupt) requests.  	 If software does not clear the OVF bit corresponding to a performance counter then future counter overflows may not cause PMI request. 	  Software should clear the IA32_PERF_GLOBAL_STATUS.OVF bit in the PMI handler  	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Indicates Wrong L2 Association in Leaf 80000006H  	  When a CPUID instruction is executed with EAX= 80000006H on a processor with a 512K L2 cache, it incorrectly returns 08H in ECX[15:12] which indicates a 16-way set associative L2. The return value in ECX[15:12] should have been 06H to indicate a 8way set associative L2.  	 CPUID will report the L2 set association as 16-way when it should report 8-way. 	 	  None  For the steppings affected, see the Summary Tables of Changes.   29  
  Code Fetch May Occur to Incorrect Address After a Large Page is Split Into 4-KByte Pages  	  If software clears the PS (page size) bit in a present PDE (page directory entry), that will cause linear addresses mapped through this PDE to use 4-KByte pages instead of using a large page after old TLB entries are invalidated. Due to this erratum, if a code fetch uses this PDE before the TLB entry for the large page is invalidated then it may fetch from a different physical address than specified by either the old large page translation or the new 4-KByte page translation. This erratum may also cause speculative code fetches from incorrect addresses.  	 The processor may fetch code from an incorrect address after a large page is converted into 4-Kbyte pages. 	  None  	  For the steppings affected, see the Summary Tables of Changes. 
 	NA	NA	NA	NA
 Processor May Use an Incorrect Translation if the TLBs Contain Two Different Translations For a Linear Address  	  The TLBs may contain both ordinary and large-page translations for a 4-KByte range of linear addresses. This may occur if software modifies a PDE (page-directory entry) that is marked present to set the PS bit (this changes the page size used for the address range). If the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.  	 Due to this erratum, software may not function properly if it sets the PS flag in a PDE and also changes the page frame, permissions, or memory type for the linear addresses mapped through that PDE. 	 Software can avoid this problem by ensuring that the TLBs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type. 	  For the steppings affected, see the Summary Tables of Changes. 
  CPUID Feature Flag Incorrectly Indicates TM2 as Supported  	  Processors with no support for TM2 (Intel® Thermal Monitor 2) falsely report support for TM2 as indicated by TM2 (bit 8) being set in the Feature Flag returned in ECX when executing CPUID with EAX=01H.  	 CPUID Feature Flag TM2 cannot be used to identify processors where TM2 is not supported. 	  None identified.  	  For the steppings affected, see the Summary Tables of Changes. 
  IA32_MC2_STATUS [OVERFLOW] Bit is Not Set When Single-Bit Correctable ECC Error Occurs  30    	  The OVERFLOW bit should be set if the VAL bit (IA32_MC2_STATUS (409H) bit [63]) is set when a new error occurs. Due to this erratum, the OVERFLOW bit (IA32_MC2_STATUS (409H) bit [62]) is only set when a prior uncorrected error (as indicated by the UC bit (IA32_MC2_STATUS (409H) bit [61])) is present at the time the second error occurs  	 Any L2 correctable error will not set the IA32_MC2_STATUS.OVERFLOW bit when overwriting a prior L2 correctable error 	 The frequency of occurrence of this problem is reduced greatly if an operating system regularly polls and clears the machine check banks as this reduces the likelihood of an overflow condition 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 4-Gbyte Boundary in Code That Uses 32-Bit Address Size in 64-bit Mode  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-Gbyte boundary and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a 4-Gbyte boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	 If the FP Data Operand Pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 4-Gbyte boundary. 	  For the steppings affected, see the Summary Tables of Changes. 
  FP Data Operand Pointer May Be Incorrectly Calculated After an FP Access Which Wraps a 64-Kbyte Boundary in 16-Bit Code  	  The FP (Floating Point) Data Operand Pointer is the effective address of the operand associated with the last non-control FP instruction executed by the processor. If an 80-bit FP access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-Kbyte boundary, and the FP environment is subsequently saved, the value contained in the FP Data Operand Pointer may be incorrect.  	 Due to this erratum, the FP Data Operand Pointer may be incorrect. Wrapping an 80bit FP load around a segment boundary in this way is not a normal programming practice. Intel has not observed this erratum with any commercially available software. 	 If the FP Data Operand Pointer is used in an operating system which may run 16-bit FP code, care must be taken to ensure that no 80-bit FP accesses are wrapped around a 64-Kbyte boundary. 	NA